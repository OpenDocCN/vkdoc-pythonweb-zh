# 十二、测试

单元测试是一门艺术，它提取代码的一小部分(称为单元)并测试其功能以确保其正常工作。例如，您可以获取一个小的代码单元，比如一个控制器方法，并断言它返回一个视图类。

单元测试对于任何应用都是至关重要的。有很多框架让单元测试成为事后的想法，但是有了 Masonite，我们希望确保能够测试您的应用对我们来说是绝对重要的。

## 什么是集成测试？

集成测试只是一个比单元测试更宽泛的概念。典型地，它是一个测试，涉及更大的代码片段，或者运行一个类似于用户所做的过程。例如，您可以测试当用户点击一个端点时

*   一封电子邮件被发送

*   数据库中会添加一条记录

*   用户被重定向到仪表板

现在单元测试很棒，但是有时候在小单元中测试代码不允许你在更大的范围内测试，你可能会错过一些未测试的关键方面。因此，在单元测试做不到的地方，你可以做集成测试之类的事情。

我们将在这一章中讨论如何做这两件事。

## 为什么首先要测试？

您应该测试您的应用的原因之一是，确保当您不断添加新功能时，旧功能不会中断。我无法告诉你有多少次我在 Masonite 的一个 requests 类中修改了一小段代码，在一些随机的类中修改了一些东西。

在 Masonite 发布之前，它将在 Python 的最后四个主要版本上运行所有测试。拥有自动化测试有助于确保 Masonite 能够在所有受支持的 Python 版本上完美运行。

现在，人们不测试他们的应用的一个原因是，编写测试需要花费大量的初始时间，而且除了测试之外，有时还需要更长的时间来编写整个功能。建立一个基本的测试来测试应用的简单部分确实要花很多时间。我们通常在不同的路由上主张同样的事情。也许我们断言某个路由上存在中间件，或者没有登录的用户不能访问文件。

对于 Masonite，我们考虑到了这一点，并希望确保尽可能快地设置这些测试。您甚至会看到为什么 Masonite 的自动解析依赖注入方面实际上有助于测试，因为您正在类型提示的所有那些类都可以被注入到您的测试中。因此，如果您的控制器接受请求类，您可以模拟请求，然后您可以在测试中构建一个新的类，并将其直接注入到您的控制器方法中。

对您的应用进行单元测试的另一个原因是，可能有一个极其复杂的业务逻辑规则需要一直工作。比如有特定物品需要有物品限制，物品销售限制。这两件事情中的一件失败可能意味着业务诉讼，这是你真的不希望失败的事情。

最后，单元测试的原因是为了重构。当重构你的代码时，如果你有一个测试，你可以确保代码在重构前和重构后的工作方式是一样的。这些都是追求单元测试的原因，在我们开始创建我们的测试之前，我们将谈论 Masonite 如何处理所有这些。

## 我们的测试在哪里？

因此，在我们开始实际创建测试之前，最好知道我们实际上要把测试放在哪里，或者甚至知道我们要如何运行它们。所有的测试都在`tests`目录中，这个目录被分成几个不同的目录。

第一个导演叫做“`tests/unit`”。这是你放置所有单元测试的地方。

下一个是“`tests/framework`”。每当你需要扩展框架的时候，你可以在这里放置所有与框架相关的测试。

另一件需要了解的重要事情是我们将要使用的库。因此，您可能会看到奇怪的语法，因为 Masonite 使用 PEP 8 编码标准来解释方法应该是下划线，但 Masonite 测试套件使用内置的`unittest`测试库来编写测试，然后推荐`pytest`来实际运行测试。

我们使用内置的`unittest`库的原因是因为它实际上比`pytest`在概念上更容易理解，我们推荐 pytest 实际运行测试套件的原因是它有一个更容易使用的命令行工具。因此，通过将`unittest`的优点与`pytest`的优点结合起来，我们能够让 Masonite 的测试更加完美。

单元测试库是在 PEP 8 标准存在之前创建的，所以我们的单元测试将主要使用`camelCase`来创建。因为我们不希望开发人员在创建测试时必须在标准之间切换，所以所有的测试方法和断言都使用`camelCase`。这样你就可以在心理上准备好使用(并持续使用)`camelCase`。

## 创建测试

既然我们已经了解了将要看到的内容，那么让我们开始创建我们的第一个测试用例，看看它是什么样子的。

因此，为了创建您的测试，您将运行一个简单的 craft 命令:

```py
$ craft test Home

```

这将在`tests/test_home.py`中创建一个基本的样板测试。我们可以把它留在这里，但是让我们把它拖到`unit`目录中，这样我们就有了一个`tests/unit/test_home.py`文件。

如果我们打开这个文件，我们会看到我们现在要讨论的三个基本部分。

以下是您应该看到的示例:

```py
"""TestHomee Testcase."""

from masonite.testing import TestCase

class TestHome(TestCase):

    """..."""
    transactions = True

    def setUp(self):
        """..."""
        super().setUp()

    def setUpFactories(self):
        """..."""
        pass

```

让我们从上到下浏览一下代码。

我们拥有的第一行只是一个普通的`TestCase`类的导入。这里有我们将用于创建和运行测试的所有方法、定制断言和设置逻辑。

接下来您将看到的是类名。所有的测试都需要以`Test`开始，这样测试库就知道把它作为一个测试而不是一个普通的类来运行。

继续前进，你会看到一个`transaction = True`属性。这将让 Masonite 知道它是否应该运行事务内部的所有测试。在事务内部运行测试非常有用，因此您可以用数据库的相同状态反复运行测试。

接下来你会看到这里有一个`setUp`方法。`setUp`方法将在测试创建之前运行。因此，如果您需要修改容器和覆盖一些默认行为或默认值，您可以在 setup 方法中这样做。

最后，您将看到一个`setUpFactories`方法。这种方法类似于 setup 方法，但是在这里您将做一些事情，比如播种您的数据库，运行您拥有的任何工厂，创建用户，以及在数据库级别设置您的测试所需的所有其他事情。例如，如果您有一个端点需要测试是否有 50 个用户，那么在运行该测试之前创建 50 个用户可能比较好。

最后需要注意的是，默认情况下，所有测试都必须在 SQLite 数据库内部运行。这样做的原因是，如果您使用 MySQL 或 Postgres 之类的东西，有时您会不小心搞砸您的生产数据库，甚至您的正常开发数据库。如果你愿意，你可以通过在你的测试用例上设置`sqlite = False`来禁用它。这样，您可以为任何数据库运行测试。

### 我们的第一个测试

我们的测试方法都应该是下划线，它们将以`test_underscore`开始。现在让我们构建我们的第一个测试。

我们将基于我们在上一节中创建的`TestHome`测试:

出于篇幅原因，我们将只关注我们的方法，但是请确保您将它附加到我们的测试用例中。

```py
def test_can_visit_homepage(self):
    self.get('/').assertContains('Masonite')

```

如果您是从 Masonite 的基础安装编写这个测试，那么这个测试应该可以工作，因为首页显示了 Masonite 启动页面。如果您已经修改了应用，那么将`Masonite`更改为您可以在主页上看到的任何文本(您的`/`路由)。

同样，任何以`assert`开头的方法都可以链接在一起。因此，我们还要检查状态是否为`200`:

```py
def test_can_visit_homepage(self):
    self.get('/').assertContains('Masonite').assertIsStatus(200)

```

现在我们可以用`pytest`运行这个测试。如果您还没有安装，现在就可以安装:

```py
$ pip install pytest

```

现在，我们可以直接进入我们的终端，运行:

```py
$ python -m pytest

```

我们使用`python -m pytest`而不仅仅是`pytest`的原因是前者会将当前工作目录添加到系统路径中。这意味着我们的测试将能够在我们的应用中找到路由、模型和其他任何东西。

## 什么时候给的

尝试找出你将如何构建测试的一个好的技巧是使用一个简单的“给定”..当...的时候..然后..”格式。例如，您可以将一个测试用例分解成"**假设**我是一个访客用户，**当**我去了家的路由，我**然后**将被重定向。"

这个测试可以这样分解:

```py
def test_guest_will_be_redirected(self):
    # Given .. I am a guest user
    # When .. I go to the home route
    response = self.get('/home')

    # Then I will be redirected
    response.assertIsStatus(302)

```

下面是另一个例子:“**假设**我是一个认证用户，**当**我去了家的路由，**然后**我应该看到主页”:

```py
def test_user_sees_home_page(self):
    # Given .. I am an authenticated user
    response = self.actingAs(User.find(1))

    # When .. I go to the home route
    response = self.get('/home')

    # Then .. I should get redirected
    response.assertIsStatus(302)

```

有时候测试真的很复杂，所以像这样把它们分解成简单的步骤会让测试变得非常清晰。

## 测试驱动开发

如果我不触及测试驱动的开发，那将是极其不负责任的。既然我们已经对什么是测试以及如何创建测试有了一些基本的了解，那么让我们来谈谈测试驱动开发，或者简称为 TDD。TDD 是先写测试，然后再写代码的艺术。

我们可以以最后一次测试为例。在那里我们断言"**给定**..我是认证用户”和“**当**..我走回家的路由。”只要我们运行测试，这两个步骤就会失败。所以我们能做的就是继续运行我们的测试，直到我们能通过它们。

在这种情况下，我们首先需要有用户。所以我们可以从创建一些用户开始。我们将遇到的下一个错误是回家的路由。我们将得到一个错误，因为一个主路由不存在。

现在我们已经有了用户和一个本地路由，我们可以将用户传递到路由中并到达那个端点。一旦完成，我们最终可以做出我们的断言。在这种情况下，一个很好的断言可能是用户是否真的可以访问主页，或者他们是否被重定向。

TDD 优于其他测试方法的好处是，它使测试变得更容易，比如事后编写测试。如果你从测试开始，你的代码需要本质上是可测试的。如果你在之后编写测试，可能很难测试你的应用的某些部分，因为你可能没有考虑过以后如何测试它。

例如，你可能在你的控制器中有某种逻辑，它一直在执行。如果您不想在测试中运行这段代码，那么您可以在控制器上设置某种选项，甚至在控制器**上设置一个类似`withoutComplexLogicOption`的 setter 方法，特别是**，这样您就可以在测试中避开这个挑战。就更大的领域逻辑而言，该方法可能没有任何实际用途，但它是一段可测试的代码，您将能够安全地进行重构。

与其他选项相比，我个人更喜欢测试驱动开发，并且在构建 Masonite 时经常使用它。事实上，如果有人打开一个特性或问题的拉请求，我不会告诉他们如何修复他们可能错过的用例，而是给他们写一个快速测试，告诉他们确保在拉请求合并之前通过测试。这允许他们将测试插入到他们的代码中，并一直工作到代码运行为止。非常强大的东西。

## 工厂

工厂是非常有用的代码，允许您快速生成模拟数据。无论您只是想要一个模拟用户，还是需要实现一个复杂的 **When** 子句，工厂都是在运行测试之前将数据导入数据库的方法。

### 创建工厂

工厂都存储在`config/factories.py`文件中。这需要一个函数来返回一个通常是随机的数据集，这个数据集可以运行一次或多次来模拟我们以后可以使用的数据。例如，Masonite 带有用于创建用户的默认工厂。我们能够在种子和测试中使用这些工厂。

为了创建工厂，您必须将工厂注册到模型中。我们将使用我们的`Subscription`模型，这是我们在数据库章节的前几章中制作的。

我们可以通过在`config/factories.py`中创建一个新函数来轻松创建一个工厂，并返回一个简单的列值字典。工厂的格式如下所示:

```py
from app.Subscription import Subscription
# ...

def subscription_factory(faker):
    return {
      'url': faker.uri(),
      'title': faker.sentence()
    }

factory.register(Subscription, systems_factory)

```

请注意，我们只是导入了模型，然后将模型映射到工厂函数。工厂函数采用了一个`faker`实例，这是一个流行的 Python 库，能够非常快速地生成模拟数据。

### 使用工厂

我们现在可以在应用的任何部分使用这些工厂。我们可以导入工厂和模型，然后使用它:

```py
from config.factories import factory
from app.Subscription import Subscription
# ...

systems = factory(Subscription, 50).create()

```

`systems`变量现在保存了 50 个系统的集合。我们现在可以在测试中做任何我们需要做的事情。在接下来的几节中，我们将使用这个工厂来设置我们的测试。

如果你只想创建一个单一的模型，我们可以很容易地得到一个单一的系统:

```py
system = factory(Subscription).create()

```

## 断言数据库值

大多数情况下，您会断言您有特定的数据库值。也许您创建了一个新用户，然后需要确保该用户被持久化到您的数据库中。假设我们有一条`POST`路由来创建新用户。我们的测试可能看起来像这样:

```py
def test_create_users(self):
  self.post('/users', {
    'username': 'user123',
    'email': 'user@example.com',
    'password': 'pass123'
  })

  self.assertDatabaseHas('users.email', 'user@example.com')

```

注意，我们可以很容易地断言 users 表中的 email 列包含值 user@example.com`.`

## 测试环境

当 Masonite 检测到一个测试正在运行时(由于测试运行时设置的特定环境变量)，它将**另外**加载一个`.env.testing`文件，如果存在的话。这个文件可以包含不同于标准`.env`文件的环境变量。

例如，在开发和生产过程中，您可以使用 RabbitMQ 驱动程序来处理队列作业，但也可以选择使用更基本的`async`驱动程序来进行测试。这样，我们就不需要仅仅为了测试而运行队列服务器。

要更改测试的环境变量，您可以创建一个`.env.testing`文件并将变量放入其中，如下所示:

```py
DEBUG=True
DB_CONNECTION=sqlite
DB_DATABASE=testing.db
# ...

```

这些将覆盖任何同名的现有环境变量。