# 10.Django 用户管理

在这一章中，你将学习 Django 管理用户、组和权限。您将了解如何根据用户有条件地显示内容，如何限制 URL 和基于类的视图，以及如何基于用户权限管理 Django 模型记录的 CRUD(创建-读取-更新-删除)权限。

此外，您还将了解如何定制 Django 的内置用户模型以支持额外的数据字段，以及如何自动化用户管理任务，如注册、密码提醒和密码重置电子邮件。最后，您将了解如何创建定制的身份验证后端，以使用不同的技术验证用户凭证，包括允许用户使用脸书、谷歌或 Twitter 帐户访问 Django 应用程序。

## Django 用户系统介绍

Django 用户系统基于内置于 Django 框架中的`django.contrib.auth`包。在本节中，您将了解这个包提供的核心概念，它是各种 Django 应用程序(包括 Django admin)使用的默认用户系统。

### 用户类型、子类型、组和权限

Django 用户类主要有两种类型:`User`和`AnonymousUser`。如果用户验证了自己的身份(即提供了有效的用户名/密码)，Django 会将其识别为`User`。另一方面，如果用户只是在没有任何认证的情况下浏览应用程序，Django 会将他识别为`AnonymousUser`。

任何`User`都可以进一步分为各种子类型中的一种:

*   超级用户。-在 Django admin 中拥有创建、读取、更新和删除数据权限的最强大的用户，包括模型记录和其他用户。
*   工作人员。-标记为 staff 的用户可以访问 Django admin。但是在 Django admin 中创建、读取、更新和删除数据的权限必须明确授予用户。默认情况下，超级用户被标记为 staff。
*   活跃。-所有信誉良好的用户都被标记为活跃用户。被标记为不活跃的用户无法验证自己，这是一种常见的状态，如果有一个待定的注册后步骤(例如，确认电子邮件)或用户被禁止，而您不想删除他的数据。

Django 还提供了一个`Group`类的概念来授予一组用户相同的权限，而不必单独分配给他们。例如，您可以将权限授予某个组，然后将用户分配到该组，以使权限管理更容易。通过这种方式，您可以在一个步骤中撤销或添加一组用户的权限，并快速授予新用户相同的权限。

此外，您可以将 Django 权限粒度地分配给 a `User`或`Group`，以便它们在 Django 模型上执行 CRUD(创建-更新-删除)记录，这是一个通过权限模型记录完成的过程。或者，您也可以在 URL/视图方法或模板内容上分配粗粒度的 Django 权限，以授予`User`、`Group`，甚至`Permission`受让人访问权限。

现在您已经了解了 Django 用户系统背后的基本概念，让我们更详细地探索与 Django 用户相关的更常见的操作。

### 创建用户

您想要创建的第一个用户是超级用户。如果你已经在第 [1 章](01.html)中设置了 Django 管理员，那么你已经有了一个项目超级用户。无论哪种方式，我都会在这里重述这个过程，因为您可以拥有任意数量的超级用户。清单 [10-1](#Par14) 展示了创建超级用户的各种方法。

Tip

参考本书附带的源代码来运行练习，以减少打字和自动访问测试数据。

```
[user@coffeehouse ∼]$ python manage.py createsuperuser
Username (leave blank to use 'admin'):
Email address: admin@coffeehouse.com
Password:
Password (again):
Superuser created successfully.

[user@coffeehouse ∼]$ python manage.py createsuperuser --username=bigboss
                      --email=bigboss@coffeehouse.com
Password:
Password (again):
Superuser created successfully.

[user@coffeehouse ∼]$ python manage.py shell
Python 2.7.3 (default, Apr 10 2013, 06:20:15)
[GCC 4.6.3] on linux2
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
>>> from django.contrib.auth.models import User
>>> user = User.objects.create_superuser(username='angelinvestor',
                                 email='angelinvestor@coffeehouse.com',
                                 password='seedfunding')
>>>

Listing 10-1.Create Django superuser

```

Note

Django 用户名必须是唯一的；先前存在的用户名被拒绝。

正如您在清单 [10-1](#Par14) 中看到的，您可以在`manage.py`实用程序中使用`createsuperuser`命令创建一个超级用户，在这里您需要输入用户名、电子邮件。和密码。你也可以用同样的`createsuperuser`命令创建一个超级用户，使用内嵌参数`--username`和`--email`，在这种情况下，你只需要输入密码。

此外，还可以通过 Django shell 使用带有`create_superuser()`方法的`User`模型类来创建超级用户。注意`create_superuser()`方法是如何要求相同的用户名、电子邮件和密码参数的。

当您以任何一种方式创建超级用户时，该用户也会被自动设置为职员并标记为活动用户，因此您不需要采取任何额外的步骤来访问 Django admin(需要职员权限)或继续进行身份验证(需要将用户标记为活动用户)。

有时候你只想创建一个普通用户，这种情况下你可以使用 Django 的 shell 实用程序，通过`User`模型直接创建一个用户。清单 [10-2](#Par20) 说明了这一过程。

```
[user@coffeehouse ∼]$ python manage.py shell
Python 2.7.3 (default, Apr 10 2013, 06:20:15)
[GCC 4.6.3] on linux2
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
>>> from django.contrib.auth.models import User
>>> user = User.objects.create_user(username='downtownbarista',
                                 email='downtownbarista@coffeehouse.com',
                                 password='cappuccino')
>>> user.is_staff
False
>>> user.is_active
True
>>> user.is_superuser
False
Listing 10-2.Create regular Django user through shell

```

正如您在清单 [10-2](#Par20) 中看到的，在您获得对 Django shell 的访问权之后，您导入`User`模型类，并使用用户名、电子邮件和密码参数调用`create_user()`方法。`create_user()`方法的结果包含新创建的用户。

为了确认`create_user()`方法生成了一个普通用户，您可以在清单 [10-2](#Par20) 中看到一个对各种`User`模型属性的调用，确认用户既不是员工也不是超级用户，只是被标记为活动的。

最后，还可以通过 Django admin 创建用户。要做到这一点，你首先需要确保你拥有 Django admin 的超级用户权限。一旦你进入 Django admin，你会看到一个如图 [10-1](#Fig1) 所示的屏幕，点击“用户”链接。“用户”链接将你带到如图 [10-2](#Fig2) 所示的屏幕，点击右上角的“添加用户+”按钮。点击“添加用户+”按钮，您将进入如图 [10-3](#Fig3) 所示的屏幕，在这里您可以介绍新用户的凭证。

![A441241_1_En_10_Fig3_HTML.jpg](A441241_1_En_10_Fig3_HTML.jpg)

图 10-3。

Django admin to create new user

![A441241_1_En_10_Fig2_HTML.jpg](A441241_1_En_10_Fig2_HTML.jpg)

图 10-2。

Django admin Users list

![A441241_1_En_10_Fig1_HTML.jpg](A441241_1_En_10_Fig1_HTML.jpg)

图 10-1。

Django admin site home page

如果您希望更改以这种方式创建的用户的子类型(即超级用户、职员)，您也可以在 Django admin 中完成，这个过程将在下一节中描述。

### 管理用户

一旦用户在 Django 应用程序中，您将最终管理他。这种管理可以是撤销他的特权、增加他的特权，或者甚至编辑他的简档信息。您可以通过两种方式管理 Django 用户，在 Django admin 中或者通过在 Django shell 中或者直接在您的应用程序中操作`User`模型。

管理用户最简单的方法是直接在 Django admin 中。一旦你进入 Django admin，你会看到如图 [10-1](#Fig1) 所示的屏幕，如果你点击“用户”链接，你会被带到如图 [10-2](#Fig2) 所示的屏幕，其中包含 Django 用户列表。图 [10-2](#Fig2) 中显示的每个 Django 用户都有一个用户名链接，如果你点击这个链接，你会被带到用户页面，如图 [10-4](#Fig4) 、 [10-5](#Fig5) 和 [10-6](#Fig6) 所示，在这里你可以编辑用户的个人资料。

![A441241_1_En_10_Fig6_HTML.jpg](A441241_1_En_10_Fig6_HTML.jpg)

图 10-6。

Django admin change user page - Part 3

![A441241_1_En_10_Fig5_HTML.jpg](A441241_1_En_10_Fig5_HTML.jpg)

图 10-5。

Django admin change user page - Part 2

![A441241_1_En_10_Fig4_HTML.jpg](A441241_1_En_10_Fig4_HTML.jpg)

图 10-4。

Django admin change user page - Part 1

您可以编辑的用户资料的第一部分如图 [10-4](#Fig4) 所示。您可以在这里编辑他的用户名和密码——通过点击小文本末尾的“此表格”链接——他的名字、姓氏以及电子邮件。此外，您可以看到有三个复选框，可以在其中更改用户的活动、员工和超级用户状态。

如果你向下滚动，你会看到你可以编辑的用户资料的第二部分，如图 [10-5](#Fig5) 所示。在这里，您可以将一个用户分配到不同的组，以及分配一个用户对 Django 模型的 CRUD 权限。在这里，我建议您仔细评估为用户分配单独的 CRUD 权限的必要性；一种更灵活的方法是创建组，并为它们分配 CRUD 权限，然后将用户分配到组中，这样权限就更容易跟踪，并可供其他用户重用。

如果你继续向下滚动到最后，你会看到你可以编辑的用户资料的第三部分，如图 [10-6](#Fig6) 所示。在这里，您可以查看和更新用户的上次登录，以及用户的创建日期。在页面的右下角，您可以看到各种保存按钮，用于保存对页面所做的任何更改。此外，在左下角有一个“删除”按钮，可以完全删除用户；但是，我建议您考虑取消选中用户的活动状态来限制访问。这最后一步足以阻止用户再次访问应用程序，并保持他的其他数据不变，以防您想要撤销该操作。

修改用户资料的另一个选项是直接操作他的`User`模型记录。如清单 [10-3](#Par31) 所示，首先查询所需的用户，然后修改模型属性或执行`User`模型助手方法之一。

```
[user@coffeehouse ∼]$ python manage.py shell
Python 2.7.3 (default, Apr 10 2013, 06:20:15)
[GCC 4.6.3] on linux2
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
>>> from django.contrib.auth.models import User
>>> user = User.objects.get(id=1)
>>> user.username = 'superadmin'
>>> user.save()
>>> userbig = User.objects.get(username='bigboss')
>>> userbig.is_superuser
True
>>> userbig.superuser = False
>>> userbig.first_name = 'Big'
>>> userbig.last_name = 'Boss'
>>> userbig.save()
>>> userbig.is_superuser
False
>>> userbig.get_full_name()
u'Big Boss'
>>> userbarista = User.objects.get(email='downtownbarista@coffeehouse.com')
>>> userbarista.email ='barista@coffeehouse.com'
>>> userbarista.save()
>>> userbarista.set_password('mynewpass')
>>> userbarista.check_password('oldpass')
False
>>> userbarista.check_password('mynewpass')
True
Listing 10-3.Manage Django user through shell

```

正如您在清单 [10-3](#Par31) 中看到的，您可以修改图 [10-4](#Fig4) 、 [10-5](#Fig5) 和 [10-6](#Fig6) 中 Django admin 中呈现的相同的`User`配置文件值。请注意，因为您正在进行查询，所以对字段所做的任何更改之后都必须调用对要持久化的字段的引用的`save()`方法。表 [10-1](#Tab1) 和表 [10-2](#Tab2) 包含`User`模型上可用的字段和方法的完整列表。

表 10-2。

Django django.contrib.auth.models.User methods

<colgroup><col> <col></colgroup> 
| 方法 | 描述 |
| --- | --- |
| 获取用户名() | 返回用户的用户名。由于用户模型可以更改为另一个用户模型，因此推荐使用这种方法，而不是直接引用 username 属性。 |
| is_anonymous() | 对于用户，该方法总是返回 False 这只是用来区分用户和匿名用户的一种方式。 |
| is_authenticated() | 对于用户来说，该方法总是返回 True，因为它仅用于确定用户是否已经通过了 AuthenticationMiddleware(表示当前登录的用户)。 |
| 获取全名() | 返回名和姓字段，中间有一个空格。 |
| get_short_name() | 返回名字。 |
| 设置密码(原始密码) | 将用户的密码设置为给定的原始字符串，注意密码哈希。请注意，当 raw_password 为 None 时，密码被设置为不可用的密码，就像使用 set_unusable_password()一样。 |
| 检查密码(原始密码) | 如果给定的原始字符串是用户的正确密码，则返回 True，并注意进行比较的密码哈希。 |
| set_unusable_password() | 将用户标记为未设置密码。请注意，这不同于使用空白字符串作为密码。该用户的 check_password()永远不会返回 True。如果针对现有外部源(例如，LDAP 目录)进行身份验证，这将很有帮助。 |
| has_usable_password() | 如果为用户调用了 set_unusable_password()，则返回 False。 |
| 获取组权限(obj =无) | 为用户返回一组组权限字符串。如果 obj 被传递，则仅返回特定对象的组权限。 |
| 获取所有权限(obj =无) | 为用户返回一组组和用户权限字符串。如果 obj 被传递，则仅返回特定对象的组权限。 |
| has_perm(perm，obj=None) | 如果用户具有指定的权限，则返回 True，其中 perm 的格式为<app label="">。<permission codename="">”。注意如果用户处于非活动状态，该方法总是返回 False。如果 obj 被传递，检查发生在特定的对象上，而不是模型上。</permission></app> |
| has_perms(perm_list，obj=None) | 如果用户拥有每个指定的权限，则返回 True，其中每个 perm 的格式为<app label="">。<permission codename="">”。注意如果用户处于非活动状态，该方法总是返回 False。如果 obj 被传递，检查发生在特定的对象上，而不是模型上。</permission></app> |
| has_module_perms(包名) | 如果用户拥有给定包(即 Django 应用程序标签)中的权限，则返回 True。如果用户不活动，该方法总是返回 False。 |
| email_user(主题，消息，from _ email =无，**kwargs) | 向用户发送电子邮件。如果 from_email 为 None，Django 使用 settings.py 中的缺省 _FROM_EMAIL。还要注意，该方法依赖于 Django 的 send_mail()方法，它向该方法传递**kwargs 参数。有关 send_mail()方法和**kwargs 值的更多详细信息，请参见 Django 电子邮件快捷方式方法， |

表 10-1。

Django django.contrib.auth.models.User fields

<colgroup><col> <col></colgroup> 
| 田 | 描述 |
| --- | --- |
| 用户名 | (必需)30 个字符或更少，可以包含字母数字、_、@、+、。和-字符。 |
| 名字 | (可选)30 个字符或更少。 |
| 姓氏 | (可选)30 个字符或更少。 |
| 电子邮件 | (可选)电子邮件地址。 |
| 密码 | (必需)密码的散列和元数据。注意，Django 不存储原始密码。 |
| 组 | 与 django . contrib . auth . models . group 的多对多关系 |
| 用户权限 | 与 django.contrib.auth.Permission 的多对多关系。 |
| is_staff(布尔值) | 指定用户是否可以访问管理网站。 |
| is_active(布尔值) | 指定用户是否被视为活动用户。 |
| is _ 超级用户 | (布尔值)指定用户是否拥有所有权限，而无需显式分配这些权限。 |
| 最后一次登录 | 用户上次登录的日期时间，如果用户从未登录，则设置为 NULL。 |
| 日期 _ 加入 | 指定帐户创建时间的日期时间。创建帐户时，默认设置为当前日期/时间。 |

Tip

用户模型数据存储在数据库表 auth_user 中。

Password Strength Options

默认情况下，Django 强制密码遵循某些规则，比如不要与用户名相似，包含最少数量的字符，避免常用词，以及强制密码不仅仅由数字组成。这些密码规则是在项目的 settings.py 文件的 AUTH_PASSWORD_VALIDATORS 变量中定义的，如下所示:

```
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

```

这个验证器列表可以被编辑以适应项目的需要，通过删除某些规则或者包含使它们对选项更严格。 [<sup>1</sup>](#Fn1)

### 创建和管理组

Django 组可以在 Django 管理中创建。用一个超级用户帐号，进入 Django admin，你会看到一个类似图 [10-1](#Fig1) 的屏幕，点击“Groups”链接。“组”链接将你带到如图 [10-7](#Fig7) 所示的屏幕，然后点击右上角的“添加组+”按钮。点击“添加群组+”按钮，您将进入如图 [10-8](#Fig8) 所示的屏幕，在这里您可以创建一个新群组并介绍其名称。

![A441241_1_En_10_Fig8_HTML.jpg](A441241_1_En_10_Fig8_HTML.jpg)

图 10-8。

Django admin to create new group

![A441241_1_En_10_Fig7_HTML.jpg](A441241_1_En_10_Fig7_HTML.jpg)

图 10-7。

Django admin Groups list

正如你在图 [10-8](#Fig8) 中看到的，创建一个组所需要的只是一个名字，你可以选择指定给这个组的权限，在应用程序中对 Django 模型进行 CRUD 操作。

组的管理比用户简单，也可以完全从 Django admin 中完成。大多数时候，您最终要做的是将用户分配到组中。

要将用户分配到一个组，当您编辑用户时，您会看到一个选择网格，如图 [10-5](#Fig5) 所示。要编辑一个组的属性-名称和创建-删除-更新 Django 模型权限-你可以在如图 [10-8](#Fig8) 所示的创建它的同一个页面上进行。要从图 [10-7](#Fig7) 所示的群组列表中删除一个群组，选择您想要删除的群组，并从下拉列表中选择动作，如图 [10-9](#Fig9) 所示。

![A441241_1_En_10_Fig9_HTML.jpg](A441241_1_En_10_Fig9_HTML.jpg)

图 10-9。

Django admin to delete group Tip

组模型数据存储在数据库表 auth_group 中。和用户组关系存储在数据库表 auth_user_groups 中。

## 权限类型

默认情况下，Django 项目中的权限会强制执行某些操作。在上一节中，您了解了如何给予用户超级用户、职员和活动状态，所有这些都是用于 Django 管理和 Django 项目的整个访问工作流的权限。此外，您还了解了如何赋予用户或组创建、删除或更新 Django 模型记录的能力，所有这些都是分配给各个 Django 模型的权限。

在这一节中，我将扩展权限的主题，并描述权限的默认行为，以及如何为其他目的创建自己的权限。

### 用户权限:超级用户、员工和活跃用户

在上一节中，您学习了如何为 Django 用户分配不同的子类型:超级用户、职员和活动用户。以下是与这些用户子类型相关联的权限列表:

*   超级用户。-在 Django admin 中创建、读取、更新和删除用户的权限，以及通过 Django admin 创建、读取、更新和删除项目中所有 Django 模型记录的权限。
*   工作人员。-允许访问 Django admin。即使用户被标记为超级用户，用户也必须被标记为职员才能访问 Django admin。标记为 staff 的用户必须在每个 Django 模型上获得额外的权限来执行任务。
*   活跃。-允许登录应用程序(Django admin 或其他地方)。一个不活跃的用户被有效地禁止使用他的凭证来认证一个 Django 项目。例如，为了访问 Django admin，除了 staff 之外，用户必须被标记为 active。此外，Django 项目的任何部分(例如视图或模板)都可以标记为需要活动状态，迫使用户登录。

所有三个用户子类型都作为`User`模型的一部分存储在数据库中，这些子类型可以通过使用属于`User`模型的表 [10-2](#Tab2) 中的方法来确认。虽然`User`权限在 Django admin 中被大量使用，但这并不意味着它们仅限于此。例如，可以依靠`User`权限，如超级用户、职员或 active，来允许或拒绝对 Django 项目其他部分的访问(例如，模板中的链接、url/view 方法或其他操作)。

关于权限实施的下一节将详细描述这些过程。接下来，我将描述与 Django 模型相关的另一种类型的权限。

### 模型权限:添加、更改、删除和自定义

模型权限与创建、删除或更新 Django 模型记录的能力相关联。在本章的第一节中，你可以在图 [10-5](#Fig5) 中看到一个选择网格，它将单个模型上的`add`、`change`和`delete`权限分配给 Django 项目中的每个用户。在图 [10-8](#Fig8) 中，您可以看到一个等价的选择网格，为 Django 项目中的每个组分配相同类型的`add`、`change`和`delete`对单个模型的权限。

这些`add`、`change`和`delete`权限通过权限模型记录在数据库级别进行管理，这些记录是在您运行 Django 模型的第一次迁移时自动创建的。一旦创建了这些类型的权限，管理它们是非常简单的，因为分配是直接在用户上进行的——如图 [10-5](#Fig5) 所示——或者如图 [10-8](#Fig8) 所示的组。

Tip

模型权限数据存储在数据库表 auth_permission 中，该表还引用 django_content_type 表，该表维护已安装的 django 模型的列表。此外，模型权限-用户关系存储在数据库表 auth_user_user_permissions 中，模型权限-组关系存储在数据库表 auth_group_permissions 中。

与用户权限的行为类似，模型权限不一定局限于模型操作。例如，如果一个用户或组有一定的模型权限(例如，如果一个`User`有能力创建一个`Store`模型或改变一个`Item`模型，并允许访问一个页面或链接)，那么允许或拒绝访问一个视图或模板部分是完全可能的。

但是，下一节关于权限实施的内容将详细描述这些过程。接下来，我将描述如何为 Django 模型定制模型权限。

#### 模型元权限选项:默认权限和权限

有时可能需要更改模型的默认权限。默认情况下，所有 Django 模型都被赋予了`add`、`change`和`delete`权限。尽管授予用户和组这些权限是由管理员决定的，但有时可能有必要从 Django 模型中删除部分或全部权限(例如，从数据敏感模型中删除`change`和`delete`权限)。

此外，有时可能还需要向不符合默认`add`、`change`和`delete`权限的模型添加自定义权限(例如，`give_refund`或`can_hire`等权限，用于分配用户/组访问应用程序某些部分的权限)。

要改变给予模型的默认权限(例如，`add`、`change`和`delete`，您可以使用模型的元类`default_permissions`字段。此外，您可以通过模型的元类`permissions`字段向模型的权限添加自定义权限。

清单 [10-4](#Par60) 展示了一个利用模型元`permissions`和`default_permissions`字段的模型类。

```
class Store(models.Model):
    name = models.CharField(max_length=30)    
    address = models.CharField(max_length=30,unique=True)
    city = models.CharField(max_length=30)
    state = models.CharField(max_length=2)
    class Meta:

        default_permissions = ('add',)

        permissions = (('give_refund','Can refund customers'),('can_hire','Can hire employees'))

Listing 10-4.Customize a Django model’s permissions with default_permissions and permissions

```

注意，在清单 [10-4](#Par60) 中，`Store`模型的`default_permissions`字段被设置为(`'add',)`，这实际上删除了`change`和`delete`权限。如果您添加这个模型元语句，您会注意到`Store`模型的默认权限发生了变化，如 UI 图 [10-10](#Fig10) 所示。

![A441241_1_En_10_Fig10_HTML.jpg](A441241_1_En_10_Fig10_HTML.jpg)

图 10-10。

Custom default model permissions and custom model permissions

此外，在清单 [10-4](#Par60) 中，请注意模型元权限字段设置了两个自定义权限:`give_refund`和`can_hire`，其中每个自定义权限由一个元组组成，第一个元素表示代码(在数据库中使用),第二个元素表示友好的 UI 名称。如果您添加这个模型元语句，您会注意到`Store`模型添加了这两个自定义权限，如 UI 图 [10-10](#Fig10) 所示。

## 权限检查和实施

现在您已经了解了不同类型的 Django 权限，我们可以探索如何在它们的主要上下文之外利用这些权限(例如，Django 管理之外的用户权限和 Django CRUD 操作之外的模型权限)。

接下来，您将学习如何在视图、URL、模板、模型和基于类的视图中更改和实施 Django 权限。

### 查看方法权限检查

因为视图方法处理传入的请求并将响应分派给最终用户，所以它们代表了实施权限检查的理想位置。例如，您可以使用查看方法的权限检查来返回不同的内容，这取决于用户是否登录(即，是`User`还是`AnonymousUser`)或者是超级用户、职员还是活动子类型。

清单 [10-5](#Par67) 展示了一个视图方法逻辑内部的权限检查，根据用户的登录状态返回不同的结果，以及另一个使用装饰器根据用户的登录状态限制视图方法访问的变体。

```
# Internal check to see if user is anonymous or not
def homepage(request):
    if request.user.is_anonymous():
        # Logic for AnonymousUser
    else:
        # Logic for User

# Method check to see if user is logged in or not (i.e. a User)
from django.contrib.auth.decorators import login_required

@login_required
def profile(request):
    # Logic for profile

Listing 10-5.Permission check in view methods with internal checks and @login_required

```

Note

由于 Django 默认启用的`AuthenticationMiddleware`，所有视图方法请求(例如`request.user`)都可以使用`User`模型。关于 Django 中间件的更多细节，请参见第 2 章。

清单 [10-5](#Par67) 中的第一个例子使用了所有`User`车型上可用的`is_anonymous()`方法——如表 [10-2](#Tab2) 所述。如果最后一种方法确定发出请求的用户是匿名的——这意味着他没有登录过——就会采取某种行动和响应。另一方面，如果`is_anonymous()`方法确定发出请求的用户已经登录，就会采取另一种行动和响应。

Tip

除了 is_anonymous 方法之外，您还可以使用任何用户模型字段或方法——在表 [10-1](#Tab1) 或表 [10-2](#Tab2) 中——来执行检查(例如，is_staff，is_superuser)。

清单 [10-5](#Par67) 中的第二个例子使用`@login_required()`装饰器将整个视图方法限制为登录用户(即，具有`User`的请求和具有`AnonymousUser`的阻塞请求)。当预先知道 view 方法不需要像清单 [10-5](#Par67) 中的第一个例子那样的条件许可工作流时，最后一个技术是很有帮助的。

还可以对视图方法执行权限检查，以验证用户是否符合特定的权限测试。例如，可以阻止属于特定组的用户或具有特定模型权限的用户使用查看方法。清单 [10-6](#Par73) 展示了使用`@user_passes_test`和`@permission_required`装饰器的三个额外的视图方法权限检查。

```
# Method check to see if User belongs to group called 'Barista'
from django.contrib.auth.decorators import user_passes_test
from django.contrib.auth.models import Group

@user_passes_test(lambda u: Group.objects.get(name='Baristas') in u.groups.all())
def dashboard(request):
    # Logic for dashboard

# Explicit method check, if User is authenticated and has permissions to change Store model

# Explicit method with test
def user_of_stores(user):
    if user.is_authenticated() and user.has_perm("stores.change_store"):
        return True
    else:
        return False

# Method check using method
@user_passes_test(user_of_stores)
def store_manager(request):
    # Logic for store_manager

# Method check to see if User has permissions to add Store model

from django.contrib.auth.decorators import permission_required

@permission_required('stores.add_store')
def store_creator(request):
    # Logic for store_creator

Listing 10-6.Permission check in view methods with @user_passes_test and @permission_required

```

清单 [10-6](#Par73) 中的第一个例子使用了`@user_passes_test`装饰器并定义了一个内嵌测试。代码片段`lambda u: Group.objects.get(name='Baristas') in u.groups.all()`获取名为`Baristas`的`Group`模型记录，并检查请求用户是否属于这个组。如果请求用户不属于`Baristas`组，则测试失败，访问被拒绝；否则，允许用户运行视图方法。

第二个例子也使用了`@user_passes_test`装饰器，但是它依赖于`user_of_stores()`方法来执行测试逻辑，而不是定义一个内联测试。如果测试很复杂，与常规方法相比，很难遵循内联逻辑，这一点尤其有用。正如您在清单 [10-6](#Par73) 中看到的，`user_of_stores()`验证用户是否通过了身份验证，以及他是否拥有对`Store`模型的更新权限——注意字符串`stores.change_store`是 Django 的权限模型记录使用的语法。

清单 [10-6](#Par73) 中的最后一个例子使用了`@permission_required`装饰器，用于验证用户是否有给定的`Permission`记录。在这种情况下，注意装饰器有一个输入字符串`stores.add_store`,它表明只有有权限添加`Store`模型的用户才能运行 view 方法。

What Happens When a User Fails a Permission Check?

对于内部验证检查(例如，在方法体中进行的检查，如`if request.user.is_anonymous():`)您拥有绝对控制权，因此您可以将用户重定向到任何页面，或者添加 flash 消息以显示在模板上。

对于装饰者验证检查`@login_required`、`@user_passes_test`和`@permission_required`，默认的失败行为是将用户重定向到 Django 的登录页面。Django 的默认登录页面 URL 是`/account/login/`，这个值可以用`settings.py`中的`LOGIN_URL`变量覆盖，我将在下一节中提供细节。

对于`@permission_required`装饰器，也可以通过添加`raise_exception=True`属性(例如`@permission_required('stores.add_store',raise_exception=True)`)将失败的测试重定向到 Django 的 HTTP 403(禁止)页面。

### URL 权限检查

在某些情况下，您可以拥有一个 Django 工作流，它不涉及视图方法，只是简单地将控制从 URL 直接发送到静态模板。在这种情况下，也可以直接对 URL 定义进行权限检查。清单 [10-7](#Par81) 展示了类似清单 [10-5](#Par67) 和 [10-6](#Par73) 中应用于`urls.py`中 URL 定义的验证检查。

```
from django.conf.urls import  include, url
from django.views.generic import TemplateView

from django.contrib.auth.decorators import login_required,permission_required,user_passes_test
from django.contrib.auth.models import Group

urlpatterns = [
      url(r'^online/baristas/',
         user_passes_test(lambda u: Group.objects.get(name='Baristas') in u.groups.all())
         (TemplateView.as_view(template_name='online/baristas.html')),name="onlinebaristas"),
      url(r'^online/dashboard/',
         permission_required('stores.add_store')
         (TemplateView.as_view(template_name='online/dashboard.html')),name="onlinedashboard"),
      url(r'^online/',
         login_required(TemplateView.as_view(template_name='online/index.html')),name='online'),
]

Listing 10-7.Permission checks in urls.py for static templates

```

正如您在清单 [10-7](#Par81) 中看到的，导入所需的装饰器后，您只需要在 URL 定义中集成验证测试。`@user_passes_test`和`@permission_required`装饰器被声明为独立的方法，后跟 URL 定义(例如，`user_pass_test()(TemplateView.as_view...)`)。`@login_required`装饰器将`TemplateView`语句作为其输入。应该指出的是，清单 [10-7](#Par81) 中失败测试的行为与清单 [10-5](#Par67) 和 [10-6](#Par73) 中的行为相同，在侧栏“当用户权限检查失败时会发生什么？"

验证检查的另一种可能性是在一组视图方法/URL 上执行它们，这样就不用给每个单独的视图方法添加装饰器了——如清单 [10-6](#Par73) 所示——你只需要为整个组做一次。当通过`include()`方法在`urls.py`中定义 URL 时，这种视图方法/URL 分组过程尤其常见。清单 [10-8](#Par84) 展示了如何对使用`include()`方法的 URL 集合进行验证检查。

```
from django.conf.urls import include, url
from django.core.urlresolvers import RegexURLResolver, RegexURLPattern

class DecoratedURLPattern(RegexURLPattern):
    def resolve(self, *args, **kwargs):
        result = super(DecoratedURLPattern, self).resolve(*args, **kwargs)
        if result:
            result.func = self._decorate_with(result.func)
        return result

class DecoratedRegexURLResolver(RegexURLResolver):
    def resolve(self, *args, **kwargs):
        result = super(DecoratedRegexURLResolver, self).resolve(*args, **kwargs)
        if result:
            result.func = self._decorate_with(result.func)
        return result

def decorated_includes(func, includes, *args, **kwargs):
    urlconf_module, app_name, namespace = includes
    patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)    
    for item in patterns:
        if isinstance(item, RegexURLPattern):
            item.__class__ = DecoratedURLPattern
            item._decorate_with = func

        elif isinstance(item, RegexURLResolver):
            item.__class__ = DecoratedRegexURLResolver
            item._decorate_with = func

    return urlconf_module, app_name, namespace

from django.contrib.auth.decorators import login_required,permission_required,user_passes_test
from django.contrib.auth.models import Group

from coffeehouse.items.urls import urlpatterns as drinks_url_patterns

urlpatterns = [
    url(r'^items/',
       decorated_includes(login_required,include(items_url_patterns,namespace="items"))),
    url(r'^stores/',
      decorated_includes(permission_required('stores.add_store'),
      include('coffeehouse.stores.urls',namespace="stores"))),
    url(r'^social/',
      decorated_includes(user_passes_test(lambda u: Group.objects.get(name='Baristas') in u.groups.all()),
      include('coffeehouse.social.urls',namespace="social"))),
]

Listing 10-8.Permission checks in urls.py for include() definitions

```

因为 Django 在`include()`定义中没有内置的权限检查支持，你可以在清单 [10-8](#Par84) 中看到，我们首先定义了两个自定义类，然后是自定义方法`decorated_includes`。如果您按照清单 [10-8](#Par84) 中的顺序，您可以看到`decorated_includes()`方法接受两个输入参数，首先是权限测试(例如`login_required`、`permission_required`)，然后是带有 URL 定义的标准`include()`方法。还应该指出的是，清单 [10-8](#Par84) 中失败测试的行为与之前清单中的行为相同，在侧栏“当用户权限检查失败时会发生什么？”

### 模板权限检查

Django 项目中另一个可用的权限检查是在模板中，如果您想根据用户的权限显示/隐藏内容(例如链接)，这个过程会很有帮助。清单 [10-9](#Par87) 展示了一系列 Django 模板语法示例。

```
{% if user.is_authenticated %}
   {#  Content for authenticated users  #}
{% endif %}

{% if perms.stores.add_store %}
   {#  Content for users that can add stores #}
{% endif %}

{% for group in user.groups.all %}
   {% if group.name == 'Baristas'  %}
        {# Content for users with 'Baristas' group #}
   {% endif %}
{% endfor %}

Listing 10-9.Permission checks in templates

```

Note

由于 Django 的`auth`上下文处理器，用于在模板中执行权限检查的`user`和 perms 变量是可用的，该处理器在默认情况下是启用的——参见第 [3 章](03.html)关于 Django 上下文处理器使用的详细信息。

您可以在清单 [10-9](#Par87) 中看到，所有模板语法示例都使用了`user`和`perms`变量来执行条件权限检查。第一个例子检查用户是否通过了`is_authenticated`的认证。第二个例子使用 Django 的权限语法`stores.add_store`验证持有用户权限的`perms`是否有权创建`Store`模型记录。清单 [10-9](#Par87) 中的第三个例子遍历一个用户组，检查用户是否在`Baristas`组中；如果是，它将为这类用户输出内容。

Tip

Django 模板中检查属性的循环效率非常低。尽管清单 [10-9](#Par87) 中的最后一个例子可以工作，但这是一个非常低效的机制。更好的解决方案是创建一个自定义过滤器，并在过滤器中执行直接查询(例如，{ `% if user|has_group:"Baristas" %}`，其中`has_group`过滤器包含大部分逻辑检查)。在这种情况下，我选择了清单 [10-9](#Par87) 中的语法，将所有内容放在一个地方，但是要知道，对于这种类型的逻辑，更有效的解决方案是使用第 [3](03.html) 章中描述的自定义过滤器。

### 基于类的查看权限检查

正如你在第 [2](02.html) 章和第 [9](09.html) 章的结尾所学到的，基于类的视图为视图方法中包含的逻辑提供了更好的可重用性和封装。然而，由于基于类的视图的组成方式，它们需要一种不同于清单 [10-5](#Par67) 和 [10-6](#Par73) 中常规视图方法的方法来检查权限。

虽然从技术上来说，您可以在基于类的视图中检查权限——就像在标准视图方法中一样——通过定义基于类的视图的`get()`和/或`post()`方法，这种技术也迫使您声明视图的大部分逻辑，如果您试图做的只是合并权限检查，这在基于类的视图中是低效的。

清单 [10-10](#Par94) 展示了在基于类的视图中执行权限检查的一系列选项。

```
from django.views.generic import ListView
from django.views.generic.detail import DetailView
from django.views.generic.edit import CreateView, UpdateView, DeleteView
from django.utils.decorators import method_decorator
from django.core.urlresolvers import reverse_lazy
from django.contrib.messages.views import SuccessMessageMixin

from django.contrib.auth.decorators import login_required,user_passes_test
from django.contrib.auth.models import Group

from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin, PermissionRequiredMixin

class ItemList(LoginRequiredMixin,ListView):
    model = Item
    context_object_name = 'items'
    template_name = 'items/index.html'

class ItemDetail(UserPassesTestMixin,DetailView):
    model = Item
    pk_url_kwarg = 'item_id'    
    template_name = 'items/detail.html'
    def test_func(self):

        return self.request.user.is_authenticated

class ItemCreation(PermissionRequiredMixin,SuccessMessageMixin,CreateView):
    model = Item
    form_class = ItemForm
    success_url = reverse_lazy('items:index')
    success_message = "Item %(name)s created successfully"
    permission_required = ('items.add_item',)

@method_decorator(login_required, name='dispatch')
class ItemUpdate(SuccessMessageMixin,UpdateView):
    model = Item
    pk_url_kwarg = 'item_id'    
    form_class = ItemForm
    success_url = reverse_lazy('items:index')
    success_message = "Item %(name)s updated successfully"

@method_decorator(user_passes_test(lambda u: Group.objects.get(name='Baristas') in u.groups.all()), name='dispatch')
class ItemDelete(DeleteView):
    model = Item
    pk_url_kwarg = 'item_id'    
    success_url = reverse_lazy('items:index')

Listing 10-10.Permission checks in class-based views

```

清单[10-10](#Par94)T0】中的第一个基于类的视图使用`LoginRequiredMixin` mixin 来强制只有登录的用户才能访问基于类的视图。第二个基于类的视图`ItemDetail`使用另一个名为`UserPassesTestMixin`的 mixin 来确保只有通过权限测试的用户才被允许访问基于类的视图。要为使用`UserPassesTestMixin` mixin 的基于类的视图定义权限测试，请注意使用了`test_func()`方法。最后一个方法通过`self.request`获得对用户的访问权，并基于测试返回一个`True`或`False`值，在清单 [10-10](#Par94) 中只需调用`is_authenticated`即可。

清单 [10-10](#Par94) `ItemCreation`中的第三个基于类的视图使用`PermissionRequiredMixin` mixin 来强制只有拥有特定模型权限的用户才被允许访问基于类的视图。为了在使用`PermissionRequiredMixin` mixin 的基于类的视图上声明模型权限，使用了带有权限元组值的`permission_required`选项。在清单 [10-10](#Par94) 的情况下，`('items.add_item',)`值遵循模型权限语法`<app_name>.<app_permission>`，确保只有有权向`items`应用添加`Item`记录的用户才被允许访问基于类的视图。

清单[10-10](#Par94)T0】和`ItemDelete`中最后两个基于类的视图利用`@method_decorator`装饰器来实施基于类的权限。`@method_decorator`装饰器是专门为将标准视图方法装饰器——如清单 [10-5](#Par67) 和 [10-6](#Par73) 中使用的那些——应用于基于类的视图方法而设计的，它接受两个参数:一个装饰器和基于类的视图方法，在该方法上应用装饰器。在清单 [10-10](#Par94) 的例子中，您可以看到`ItemUpdate`基于类的视图将`login_required`装饰器应用于`dispatch()`方法，只允许登录的用户访问基于类的视图。而`ItemDelete`基于类的视图将`user_passes_test`装饰器应用于`dispatch()`方法，只允许属于`Baristas`组的用户访问基于类的视图。

## 用户认证和自动管理

在本章的第一节中，您学习了如何创建用户。但是回想一下，要使这个过程正常工作，您要么必须使用 Django 命令行工具，要么必须使用 Django admin。这些技术虽然有效，但并不是为访问应用程序的最终用户设计的，也不会扩展。

类似地，到本章的这一点为止，用户登录和注销的唯一位置是通过 Django admin 认证表单。最后一种形式对最终用户来说也不是理想的位置，不仅因为它缺少为应用程序设计的布局，还因为它不适合从不打算与项目数据库交互的用户。

如果您计划让最终用户在应用程序中进行身份验证，那么您需要为用户提供一种注册、登录和注销的方式，以及让用户记住和更改密码的方式。支持`User`模型的同一个`django.contrib.auth`包还包括一系列用于创建用户认证工作流的预构建结构。

第一个可用于验证用户身份的预建机制是一组 URL，允许用户登录和注销应用程序，允许用户更改他们的密码，以及允许用户通过电子邮件通知重置他们的密码。

清单 [10-11](#Par103) 展示了如何将全套的`django.contrib.auth`URL 添加到主`urls.py`文件中——使用一条`include`语句——以及等效的单个`url`语句，以防您想要有选择地挑选在项目中使用哪些 URL。

```
from django.conf.urls import url
from django.contrib.auth import views

# Option 1 to include all urls (See option 2 for included urls)
urlpatterns = [
    url(r'^accounts/', include('django.contrib.auth.urls')),
]

# Option 2) (Explicit urls, all included in django.contrib.auth)
urlpatterns = [
    url(r'^accounts/login/$', views.LoginView.as_view(), name='login'),
    url(r'^accounts/logout/$', views.LogoutView.as_view(), name='logout'),

    url(r'^accounts/password_change/$', views.PasswordChangeView.as_view(), name='password_change'),
    url(r'^accounts/password_change/done/$', views.PasswordChangeDoneView.as_view(), name='password_change_done'),

    url(r'^accounts/password_reset/$', views.PasswordResetView.as_view(), name='password_reset'),
    url(r'^accounts/password_reset/done/$', views.PasswordResetDoneView.as_view(), name='password_reset_done'),
    url(r'^accounts/reset/(?P<uidb64>[0-9A-Za-z_\-]+)/(?P<token>[0-9A-Za-z]{1,13}-[0-9A-Za-z]{1,20})/$',
        views.PasswordResetConfirmView.as_view(), name='password_reset_confirm'),
    url(r'^accounts/reset/done/$', views.PasswordResetCompleteView.as_view(), name='password_reset_complete'),
]

Listing 10-11.Configure urls from django.contrib.auth package

```

清单 [10-11](#Par103) 中的第一个选项在`accounts` url 上配置所有的`django.contrib.auth`URL。这引发了一个问题，为什么是`accounts`的网址？因为，默认情况下，所有的`django.contrib.auth`动作都使用这个 url 作为它们的根(例如，在前面的章节中，回想一下试图访问需要登录的资源会执行到`/accounts/login`的重定向)。因此，通过将这个 url `include()`语句与`django.contrib.auth.urls`一起使用，所有的`django.contrib.auth`动作都获得了一个有效的 url，它也得到必要的视图方法逻辑的支持！但是稍后将更多地讨论视图方法逻辑。

因为 url `include()`语句有一个‘使用所有 url 或者不使用’的行为，清单 [10-11](#Par103) 中的第二个选项代表使用粒度 url 语句来配置相同的`django.contrib.auth`URL。如果您想要禁用某些`django.contrib.auth`URL，但仍保持其他`django.contrib.auth`URL 活动(例如，禁用密码更改 URL，但保持登录和注销 URL)，最后一个选项很有帮助。

正如你所看到的，使用清单 [10-11](#Par103) 中的任一选项都可以为你提供一个快速的解决方案，将`django.contrib.auth`动作连接到 URL，后者也被连接到默认的基于类的视图，这些视图也是`django.contrib.auth`包的一部分。

### 登录和注销工作流

登录和注销工作流的入口点——如清单 [10-11](#Par103) 所示——分别是`/accounts/login/`和`/accounts/logout/`URL。如果在`/accounts/login/` url 上进行调用，则触发`django.contrib.auth.views.LoginView`基于类的视图，如果在`/accounts/logout/` url 上进行调用，则触发`django.contrib.auth.views.LogoutView`基于类的视图。

像所有 Django 内置的基于类的视图一样，`LoginView`和`LogoutView`基于类的视图在代码和配置方面几乎不需要任何东西。它们唯一需要的是一个显示登录表单的模板和一个显示注销成功消息的模板。

`LoginView`基于类的视图在定义为`settings.py`中`TEMPLATES/DIRS`变量一部分的目录下寻找模板`registration/login.html`。并且`LogoutView`基于类的视图寻找模板`registration/logout.html`，也在定义为`settings.py`中`TEMPLATES/DIRS`变量的一部分的目录下。

Tip

关于`registration/login.html`和`registration/logout.html`模板所需的布局和字段，请参见本书附带的源代码。

登录工作流在`settings.py`中提供了两个配置选项，允许您修改其行为，而无需定制`LoginView`基于类的视图。`LOGIN_URL`变量默认为`/accounts/login/`，当用户试图访问需要认证的资源但没有登录时，它被用作重定向到的 url。`LOGIC_REDIRECT`变量默认为`/accounts/profile/`，是用户成功登录后被重定向到的 url。`django.contrib.auth`包没有为`/accounts/profile/` url 提供入口点，因此您必须要么配置这个 url，要么简单地将其更改到不同的位置(例如，`LOGIN_REDIRECT='/'`在成功登录后将用户重定向到主页)。

注销工作流支持`settings.py`中的`LOGOUT_REDIRECT`变量来定义用户注销时被带到哪里。`LOGOUT_REDIRECT`变量默认为`/accounts/logout/`，但是可以更新以将用户重定向到不同的位置(例如，`LOGOUT_REDIRECT='/'`在用户注销后将用户重定向到主页)。

除了创建模板、设置 url——如清单 [10-11](#Par103) 所述——以及可选地更改登录 URL 位置和登录/退出重定向行为，您不需要做任何其他事情来启用由`django.contrib.auth`包提供的登录和注销工作流。如果你想让用户登录，只需将他们指向`/accounts/login/` url，如果你想让他们退出，将他们指向`/accounts/logout/` url。所有其他工作流细节(例如，身份验证、密码验证、错误表单处理、会话到期)由`LoginView`和`LogoutView`基于类的视图负责。

### 密码更改工作流

密码更改工作流需要两个 url 入口点:触发`PasswordChangeView`基于类的视图的`/accounts/password_change/` url 和触发`PasswordChangeDoneView`基于类的视图的`/accounts/password_change/done/` url。

`PasswordChangeView`基于类的视图在定义为`settings.py`中的`TEMPLATES/DIRS`变量的一部分的目录下寻找一个包含表单的模板，以更改`registration/password_change_form.html`中的密码。并且`PasswordChangeDoneView`基于类的视图在`registration/password_change_done.html`中寻找包含成功消息的模板，也在定义为`settings.py`中`TEMPLATES/DIRS`变量的一部分的目录下。

Tip

关于`registration/password_change_form.html`和`registration/password_change_done .html`模板所需的布局和字段，请参见本书附带的源代码。

除了创建模板和设置 urls 如清单 [10-11](#Par103) 所述——您不需要做任何其他事情来启用`django.contrib.auth`包提供的密码更改工作流。如果你想让用户修改他的密码，只需将他们指向`/accounts/password_change/` url。所有其他工作流细节(例如，密码验证、数据库更新、表单错误处理)由`PasswordChangeView`和`PasswordChangeDoneView`基于类的视图负责。

### 密码重置工作流程

密码重置工作流由两个子工作流组成。第一个子工作流捕获用户的电子邮件，并向他发送一封包含重置密码链接的电子邮件。第二个子工作流处理重置链接并验证用户的新密码。

第一个子工作流使用`/accounts/password_reset/` url，它触发`PasswordResetView`基于类的视图，以及`/accounts/password_reset/done/` url，它触发`PasswordResetDoneView`基于类的视图。第二个子工作流使用`/accounts/reset/` url，它触发`PasswordResetConfirmView`基于类的视图，以及`/accounts/reset/done/` url，它触发`PasswordResetCompleteView`基于类的视图。

基于`PasswordResetView`类的视图在`registration/password_reset_form.html`中寻找包含重置用户密码表单的模板，基于`PasswordResetDoneView`类的视图在`registration/password_reset_done.html`中寻找成功消息模板，这两个视图都位于定义为`settings.py`中`TEMPLATES/DIRS`变量一部分的目录下。对于第二个子工作流，`PasswordResetConfirmView`基于类的视图在`registration/password_reset_confirm.html`中寻找带有引入新用户密码的表单的模板，而`PasswordResetCompleteView`基于类的视图在`registration/password_reset_complete.html`中寻找成功消息模板，这两个视图都位于定义为`settings.py`中`TEMPLATES/DIRS`变量的一部分的目录下。

默认情况下，密码重置工作流会生成一封电子邮件，其中包含将用户带到第二个子工作流以重置其密码的说明。同样默认情况下，重置电子邮件包含一个到域`localhost:8000`的链接，可以通过安装 Django 站点`django.contrib.sites`应用进行定制(例如，将`django.contrib.sites`添加到`INSTALLED_APPS`和`settings.py`中的`SITE_ID=1`，并在 Django 管理中更新 id 为 1 的站点以反映一个新的域)。此外，您可以在`registration/password_reset_email.html`模板中定义一个定制的电子邮件布局，并将其放在一个目录下，该目录被定义为`settings.py`中`TEMPLATES`变量的一部分。

Tip

关于`registration/password_reset_form.html, registration/password_reset_done.html`、`registration/password_reset_confirm.html`、`registration/password_reset_complete.html`和`registration/password_reset_email.html`模板所需的布局和字段，请参见本书随附的源代码。

除了创建模板和设置 urls 如清单 [10-11](#Par103) 所述——以及可选地更改默认的电子邮件布局之外，您不需要做任何其他事情来启用或允许用户使用`django.contrib.auth`包提供的工作流记住他们的密码。如果你想让用户记住他的密码，只需将他们指向`/accounts/password_reset/` url。所有其他工作流细节(例如，电子邮件令牌验证、密码验证、数据库更新、表单错误处理)由`PasswordResetView`、`PasswordResetDoneView`、`PasswordResetConfirmView`和`PasswordResetCompleteView`基于类的视图负责。

### 用户注册工作流

用户可以在来自`django.contrib.auth`包的一些构造的帮助下自动注册一个 Django 应用程序。尽管用户注册工作流不像以前的用户相关工作流那样嵌入到`django.contrib.auth`包中，但是仍然很容易创建。

创建用户注册工作流的第一步是配置一个 url 入口点，以允许用户创建一个帐户，如清单 [10-12](#Par126) 所示。

```
# urls.py main
from django.conf.urls import url
from django.contrib.auth import views

from coffeehouse.registration import views as registration_views

urlpatterns = [
    url(r'^accounts/', include('django.contrib.auth.urls')),
    url(r'^accounts/signup/$',registration_views.UserSignUp.as_view(),name="signup"),    
]

Listing 10-12.Configure url for user sing up workflow

```

清单 [10-12](#Par126) 展示了一个在`/accounts/signup/`可访问的 url，此外还有由`django.contrib.auth`包提供的所有 URL，包括之前与用户相关的工作流。请注意，`/accounts/signup/` url 被设置为由来自`coffeehouse.registration`应用程序的`UserSignUp`基于类的视图处理，这意味着您需要为项目创建一个基于类的视图。

清单 [10-13](#Par129) 展示了负责用户注册工作流的`UserSignUp`基于类的视图，它自动创建`User`模型记录，这在以前是使用 Django 命令行工具或 Django admin 完成的。

```
from django.core.urlresolvers import reverse_lazy
from django.http import HttpResponseRedirect
from django.contrib.messages.views import SuccessMessageMixin

from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth.models import User
from django.contrib.auth import authenticate, login

class UserSignupForm(UserCreationForm):
    email = forms.EmailField(required=True)
    class Meta:
        model = User
        fields = ("username", "email", "password1", "password2")

class UserSignUp(SuccessMessageMixin,CreateView):
    model = User
    form_class = UserSignupForm
    success_url = reverse_lazy('items:index')
    success_message = "User created successfully"
    template_name = "registration/signup.html"
    def form_valid(self, form):
        super(UserSignUp,self).form_valid(form)        
        # The form is valid, automatically sign-in the user
        user = authenticate(self.request, username=form.cleaned_data['username'],
                                                 password=form.cleaned_data['password1'])
        if user == None:
            # User not validated for some reason, return standard form_valid() response
            return self.render_to_response(self.get_context_data(form=form))            
        else:
            # Log the user in
            login(self.request, user)
            # Redirect to success url
            return HttpResponseRedirect(self.get_success_url())

Listing 10-13.Signup workflow fulfilled by custom CreateView class-based view

```

清单 [10-13](#Par129) 中的`UserSignUp`基于类的视图是一个标准的`CreateView`基于类的视图，它使用 mixin`SuccessMessageMixin`——如果你不熟悉这种基于类的视图来创建模型记录或 mixin 的概念，请参阅上一章，其中解释了这两个主题。

`UserSignUp`基于类的视图将模型选项设置为`User`,告诉 Django 创建`django.contrib.auth.models.User`记录。接下来，将`form_class`选项设置为`UserSignupForm`，这也在清单 [10-13](#Par129) 中定义。接下来是`success_url`和`success_message`选项，用于在创建`User`记录时指示 url 和成功消息，以及`template_name`选项，用于指定一个带有表单的模板，以捕获`User`字段。

清单 [10-13](#Par129) 中的自定义`UserSignupForm`模型表单基于`django.contrib.auth`包中的`UserCreationForm`。从实用的角度来看，`UserSignUp`基于类的视图可以使用`UserCreationForm`作为它的`form_class`，然而，这个最后的内置表单只包含`username`和`password`字段。在这种情况下，作为用户注册过程的一部分，定制的`UserSignupForm`模型表单将`email`字段添加到基础`UserCreationForm`表单类中。请注意，因为支持`User`模型已经包含了一个`email`字段，所以不需要对模型进行修改。

为了在创建了`User`模型记录后自动登录用户，`UserSignUp`基于类的视图在其`form_valid()`方法中包含了定制逻辑。在清单 [10-13](#Par129) 的例子中，来自`django.contrib.auth`包的`authenticate`方法被表单值调用，验证凭证是否有效。如果凭证是有效的——给定工作流应该是 100%的时间，除非发生不可预见的黑客事件——`authenticate`方法返回一个`User`实例并立即执行`login`方法——也来自`django.contrib.auth`包——创建一个用户会话(即登录),之后控制被重定向到基于类的视图的成功页面。在不可预见的事件中，`authenticate`方法没有返回一个`User`实例，`form_valid()`方法返回它的标准有效载荷，也就是经过验证的形式。

从清单 [10-12](#Par126) 和 [10-13](#Par129) 中可以看到，您可以创建一个用户注册工作流，让用户创建自己的帐户，并减轻从 Django admin 或 Django 命令行工具创建用户帐户的管理负担。

Tip

清单 [10-13](#Par129) 中的注册工作流是许可的，因为它不验证电子邮件并自动让用户登录。这样做是为了简单，并且可能适用于大多数项目。但是您可以在创建`User`记录之前或之后，通过将此逻辑添加到不同的基于类的视图方法中，为注册工作流添加额外的保护措施(例如，发送验证链接，将用户设置为非活动，直到验证链接被点击)。

Tip 2

Django allauth 包(将在本章后面介绍)内置了对电子邮件验证的支持。

## 自定义用户模型字段

默认的 Django `User`模型(即`django.contrib.auth.models.User`类)使用最小的一组数据字段，包括`username`、`email`、`first_name`、`last_name`、`date_joined`和`last_login`；除了权限相关字段`password`、`is_superuser`、`is_staff`和`is_active`。

虽然最后这些字段对于 Django 的内置用户功能来说已经足够了，但是如果您希望存储额外的用户数据(例如年龄、电话、地址)，它们就不够用了。有两种方法可以支持额外的用户数据:创建一个单独的模型来存储额外的数据，并创建一个与之相关的用户关系(例如，一个带有`ForeignKey`的`User`)或者覆盖默认的`django.contrib.auth.models.User`类来创建一个定制的用户类。

清单 [10-14](#Par140) 通过创建一个额外的模型来存储额外的用户数据并创建一个与`django.contrib.auth.models.User`类的关系来展示第一种技术。

```
from django.contrib.auth.models import User
from django.db import models

class UserExtra(models.Model):
    user = models.ForeignKey(User)
    age = models.IntegerField(blank=True,null=True)
    telephone = models.CharField(max_length=15,blank=True,null=True)

Listing 10-14.Model with extra user fields related to default Django user model

```

清单 [10-14](#Par140) 中的`UserExtra`模型的功能类似于任何其他具有`ForeignKey`数据类型的模型，因此，在这些情况下使用时，会涉及一些性能和维护问题。另一方面，用户数据分布在两个数据库表中。一个表用于`User`记录，另一个表用于`UserExtra`记录，这不可避免地需要两个查询或一个连接查询来获取给定用户的所有数据——参见第 [7](07.html) 章了解跨模型关系的查询。从积极的方面来看，这种技术保持了项目的默认 Django `User`模型类的完整性，不需要额外的配置或开发工作。

接下来，让我们看看第二种技术，它包括创建一个定制的用户类，这个过程在清单 [10-15](#Par143) 中进行了说明。

```
# models.py (app registration)
from django.contrib.auth.models import AbstractUser
from django.db import models

class CoffeehouseUser(AbstractUser):
    age = models.IntegerField(blank=True,null=True)
    telephone = models.CharField(max_length=15,blank=True,null=True)

# admin.py (app registration)
from django.contrib import admin
from .models import CoffeehouseUser

class CoffeehouseUserAdmin(admin.ModelAdmin):
    pass

admin.site.register(CoffeehouseUser, CoffeehouseUserAdmin)

# settings.py
AUTH_USER_MODEL = 'registration.CoffeehouseUser'

Listing 10-15.Custom User model to override default Django User model

```

清单 [10-15](#Par143) 中的第一部分显示了用作定制用户类的`CoffeehouseUser`类。注意这个类从`AbstractUser`类继承了它的行为，这个类给了它与默认的`User`类相同的字段和行为(例如`username`、`email`等)。).接下来，`CoffeehouseUser`类使用标准模型字段声明了`age`和`telephone`字段，为定制用户类提供了比默认`User`类多两个字段。

因为自定义的`CoffeehouseUser`类将覆盖项目的默认`User`类，这意味着默认的`django.contrib.auth.models.User`类不再被使用。因此，您必须配置 Django，以便在任何需要用户逻辑的地方使用定制的`CoffeehouseUser`类。

清单 [10-15](#Par143) 中的第二部分展示了从 Django admin 访问新的定制用户类所必需的 Django admin 配置，并且能够创建、读取、更新和删除用户，就像用标准的`django.contrib.auth.models.User`模型类所做的一样。注意下一章将更详细地介绍 Django 管理配置。

最后，清单 [10-15](#Par143) 中的第三部分显示了 Django `settings.py`文件，其中`AUTH_USER_MODEL`设置为`registration.CoffeehouseUser`，其中`registration`表示应用程序名称，`CoffeehouseUser`表示定制用户模型。这最后一个配置确保整个项目中的用户逻辑是在`CoffeehouseUser`模型而不是默认的`User`模型上生成的。

一旦您使用清单 [10-15](#Par143) 中的定制用户模型类和配置运行迁移操作，您将看到 Django 项目用户获得了两个额外的字段。

Caution

类似于清单 [10-15](#Par143) 中的定制用户模型实现应该只在项目开始时进行(例如，第一批项目迁移之一)。

因为用户模型在管理对 Django 项目的访问中起着如此重要的作用，所以您不应该试图在项目中途实现定制的用户模型，如清单 [10-15](#Par143) 中所示。这样做有破坏依赖关系(外键)的风险，这些依赖关系被其他模型用来引用默认的`django.contrib.auth.models.User`模型记录；此外，这还会更改存储用户数据的底层数据库表。通过在项目开始时实现自定义用户模型，您可以保证对用户进行的任何可能的模型依赖都是针对自定义用户记录进行的，并且用户数据从一开始就存储在单个数据库表中。

事实上，如果您计划使用自定义用户模型，但不知道一开始要添加哪些新字段，您可以创建一个占位符用户模型，如下所示:

```
class CoffeehouseUser(AbstractUser):
      pass

```

这个代码片段创建了一个与默认的`django.contrib.auth.models.User`类相同的模型，但是为在定制模型上创建用户依赖关系打下了基础，同时允许向定制模型添加字段，因为像任何其他模型一样，标准迁移需要这些字段。

最后，使用定制用户模型时要考虑的另一个因素——在清单 [10-15](#Par143) 中并不明显——是如何在项目的其他地方引用定制用户模型。当您使用默认的`User`类时，语句`from django.contrib.auth.models import User`在`models.py`和`views.py`文件中引用用户是常见的，但是对于定制模型，这种引用不再适用。

为了支持定制用户模型，Django 提供了助手方法`get_user_model`，该方法返回对在`settings.py`的`AUTH_USER_MODEL`变量中定义的任何用户模型的引用。以这种方式，您可以使用语句`from django.contrib.auth import get_user_model`从项目中的任何地方获得对项目用户模型的引用。下一节包含一个使用`get_user_model`方法的例子。

## 自定义身份验证后端

身份验证过程非常重要，因为它决定了允许哪些用户访问应用程序。Django 使用的默认认证过程包括将用户名和密码(在 web 表单上提供)与数据库中的`User`记录进行比较。如果用户名和密码与`User`记录匹配，则认证过程被认为是成功的，但是如果值不匹配，则认证过程被认为是失败的。

Django 本身包括一系列内置的认证后端类 [<sup>2</sup>](#Fn2) 来支持这个认证过程的变化。此外，在本章的最后一节，我将向您介绍 allauth Django 包，它支持一系列的认证后端(例如，针对社交媒体帐户的认证)。

但是为了从头开始说明自定义身份验证后端的概念，我将创建一个简单的身份验证后端，它依赖于电子邮件进行身份验证，并且可以使用任何用户类型(即自定义用户模型或默认的`User`模型)。

默认情况下，Django 项目使用`django.contrib.auth.backends.ModelBackend`身份验证后端类，用于将最终用户提供的用户名和密码集与数据库中的项目用户进行比较。现在问问你自己，你认为登录凭证、用户名或电子邮件哪个更容易记住？如果你和这个时代的大多数人一样，你很可能已经回复了邮件。

清单 [10-16](#Par162) 展示了一个定制的认证后端，它能够通过电子邮件凭证而不是默认用户名来认证用户。

```
# models.py (registration app)
from django.contrib.auth import get_user_model

class EmailBackend(object):
    def authenticate(self, request, username=None, password=None, **kwargs):
        User = get_user_model()
        try:
            user = User.objects.get(email=username)
        except User.DoesNotExist:
            return None
        else:
            if getattr(user, 'is_active', False) and  user.check_password(password):
                return user
        return None
    def get_user(self, user_id):
        User = get_user_model()        
        try:
            return User.objects.get(pk=user_id)
        except User.DoesNotExist:
            return None

# setting.py
AUTHENTICATION_BACKENDS = ['django.contrib.auth.backends.ModelBackend',       
                                 'coffeehouse.registration.models.EmailBackend']

Listing 10-16.Custom authentication back end to support authentication with email

```

清单 [10-16](#Par162) 为定制认证后端声明了`EmailBackend`类。像所有定制认证后端类一样，您必须至少声明`authenticate()`和`get_user()`方法，其中第一个方法用于定义认证逻辑，第二个方法用于返回请求的用户。

作为基本身份验证工作流的一部分，`authenticate()`方法可以访问终端用户提供的`username`和`password`字段。接下来，您可以看到`authenticate()`方法依靠`get_user_model()`方法助手获得了对项目用户模型的访问，这确保了即使项目使用定制用户模型，认证工作流也是在正确的用户类上完成的，如前一节所述。

一旦获得了对项目的用户类的引用，请注意，`authenticate()`方法使用提供的`username`在`email`字段上为用户执行查询，这有效地允许将用户提供的`username`值作为电子邮件字段进行身份验证。如果用户匹配作为`username`值提供的电子邮件，那么清单 [10-16](#Par162) 中的`try-except-else`块调用`check_password()`来验证匹配用户的密码。如果密码匹配，`authenticate()`返回认证用户，如果密码不匹配，`authenticate()`返回`None`。

清单 [10-16](#Par162) 中的最后一部分是`settings.py`中的`AUTHENTICATION_BACKENDS`变量，它被分配了一个认证后端类列表。在这种情况下，保留默认的`django.contrib.auth.backends.ModelBackend`类，以确保首先尝试用户名/密码的默认认证工作流。接下来，添加清单 [10-16](#Par162) 中的自定义`EmailBackend`身份验证后端类，以确保身份验证工作流将输入数据视为电子邮件/密码集。

从清单 [10-16](#Par162) 中的例子可以看出，通过添加这个简单的定制身份验证后端类，您可以允许用户输入他们的用户名或电子邮件来在 Django 应用程序中进行身份验证。

Tip

如果您使用清单 [10-16](#Par162) 中的自定义身份验证后端类，请将登录表单中的用户名标签更改为‘用户名/电子邮件’,以通知用户他们可以同时使用这两个类别。

## Django allauth 的用户管理

正如您在本章中所看到的，`django.contrib.auth`包提供了大量管理用户和组、权限以及认证工作流的功能。但是您可能也意识到了，`django.contrib.auth`包也可能会受到很多遗留行为的影响，这些行为在当今时代不适用于 web 应用程序。例如，`django.contrib.auth`不支持社交认证之类的东西——这几乎是当今互联网的一项要求——此外，`django.contrib.auth`还被设计为使用开箱即用的用户名，而不是电子邮件——这也是一种非常过时的做法。

仍然因为`django.contrib.auth`包被构建到 Django 中，所以经常有许多 Django 包(例如，Django admin 和其他第三方包)假定 Django 项目使用`django.contrib.auth`包及其功能。

因此，一方面，您必须继续使用`django.contrib.auth`包来维护跨其他 Django 包的用户管理兼容性，这些 Django 包需要使用`django.contrib.auth`，但另一方面，您不希望被 2005 年的做法所束缚，即要求用户提供用户名，并且不允许他们使用社交媒体帐户进行身份验证。

在众多可用于解决 Django 用户管理集成的第三方包和潜在解决方案中，Django allauth 包提供了最佳功能集之一(例如，基于社交认证和电子邮件的用户)，以及与`django.contrib.auth`包的最佳集成。接下来，我将描述 Django allauth 包的设置过程。

### 安装并设置 django-allauth

要安装 Django allauth 包，使用下面的`pip`语句:

```
pip install django-allauth

```

安装完成后，让我们创建一个基本的 Django allauth 配置，以实现以下用户管理特性:

*   使用 email 作为主要的用户标识符，但是保留用户名凭证以与其他包兼容(例如 Django admin)。
*   要求电子邮件验证，以避免垃圾用户。
*   为添加 Django 社交认证(脸书、谷歌、Twitter)奠定基础。)

清单 [10-17](#Par180) 展示了对项目的`settings.py`文件进行必要的添加，以使一个基本 Django allauth 配置具备这些特性。

```
# Ensure the 'django.contrib.sites' is declared in INSTALLED_APPS
# And also add the allauth, allauth.account and allauth.socialaccount to INSTALLED_APPS

INSTALLED_APPS = [
    # Django sites app  required
    'django.contrib.sites',
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
]

# Ensure SITE_ID is set sites app
SITE_ID = 1

# Add the 'allauth' backend to AUTHENTICATION_BACKEND and keep default ModelBackend
AUTHENTICATION_BACKENDS = [ 'django.contrib.auth.backends.ModelBackend',
                           'allauth.account.auth_backends.AuthenticationBackend']

# EMAIL_BACKEND so allauth can proceed to send confirmation emails
# ONLY for development/testing use console
EMAIL_BACKEND='django.core.mail.backends.console.EmailBackend'

# Custom allauth settings
# Use email as the primary identifier
ACCOUNT_AUTHENTICATION_METHOD = 'email'
ACCOUNT_EMAIL_REQUIRED = True
# Make email verification mandatory to avoid junk email accounts
ACCOUNT_EMAIL_VERIFICATION = 'mandatory'
# Eliminate need to provide username, as it's a very old practice
ACCOUNT_USERNAME_REQUIRED = False

Listing 10-17.Base Django allauth settings.py configuration

```

除了清单 [10-17](#Par180) 到`settings.py`文件的变化之外，您还需要在主`urls.py`文件中注册 Django allauth url 入口点。清单 [10-18](#Par182) 展示了您需要对主`urls.py`文件进行的修改。

```
urlpatterns = [
    ...
    url(r'^accounts/', include('allauth.urls')),
    ...
]
Listing 10-18.Django allauth url configuration urls.py

```

正如您在清单 [10-18](#Par182) 中看到的，url 正则表达式告诉 Django 在`/accounts/`路径下挂载 Django allauth`allauth.urls`URL，就像清单 [10-11](#Par103) 中对标准 Django `django.contrib.auth`包 URL 所做的那样。

Django allauth 使用与标准`django.contrib.auth`包几乎完全相同的 url 模式和行为。这意味着 Django allauth 将其登录页面配置在`/accounts/login/` url，注销页面配置在`/accounts/logout/` url。Django allauth 确实在清单 [10-18](#Par182) 的`include()`语句中包含了一系列新的 URL(例如，电子邮件验证)，但是我将在我们继续讨论时描述这些新的 URL。

类似地，标准`django.contrib.auth`包用于认证目的的相同`settings.py`变量也适用于 Django allauth。例如，您可以设置`LOGIN_URL`来覆盖默认的`/accounts/login/` url 位置，也可以设置默认为`/accounts/profile/` url 的`LOGIN_REDIRECT_URL`。事实上，就像`django.contrib.auth`包一样，Django allauth 不包含`/accounts/profile/` url 入口点，所以您也可以覆盖`settings.py`中的`LOGIN_REDIRECT_URL`变量以指向另一个 url(例如，`LOGIN_REDIRECT_URL='/'`在成功登录后将用户重定向到主页)。

最后，一旦您完成了这些配置步骤，您需要执行以下其他步骤来确保 Django allauth 正确运行:

*   从命令行运行`python manage.py migrate`,确保 Django allauth 所需的所有数据库表都已创建。
*   确保`django.contrib.sites`包反映了应用程序的域。默认情况下，`django.contrib.sites`默认为域`example.com`，您可以在 Django admin 中更改该值，以确保某些特性(如电子邮件)使用正确的应用程序域。

### 首先用 Django allauth 中的超级用户登录和注销

首先，使用清单 [10-1](#Par14) 中本章开头概述的任何技术创建一个 Django 超级用户，并记下电子邮件。接下来，直接进入`/accounts/login/`网址，你会看到一个如图 [10-11](#Fig11) 所示的页面。

![A441241_1_En_10_Fig11_HTML.jpg](A441241_1_En_10_Fig11_HTML.jpg)

图 10-11。

Django allauth defult login screen

现在让我们暂停一下，思考一下姜戈·阿劳斯刚刚提供了什么。图 [10-11](#Fig11) 展示了一个登录页面，与`django.contrib.auth`登录工作流不同，你甚至不必为其创建模板。此外，请注意图 [10-11](#Fig11) 中的登录表单要求提供电子邮件凭证，您甚至不需要创建一个自定义认证后端来支持该功能。

接下来，在图 [10-11](#Fig11) 中的登录表单中输入超级用户的电子邮件/密码，并点击“登录”按钮，如果凭证正确，您将被重定向到“验证您的电子邮件地址”页面。这是有意的，请记住清单 [10-17](#Par180) 中的基本 Django allauth 配置强制电子邮件验证(`ACCOUNT_EMAIL_VERIFICATION = 'mandatory'`)；因此，在用户的电子邮件地址被验证之前，访问是被拒绝的。

如果您正在使用清单 [10-17](#Par180) 中描述的相同电子邮件设置——向控制台发送电子邮件——您将会看到类似于清单 [10-18](#Par182) 中运行 Django 开发服务器的电子邮件。

```
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Subject: [coffeehouse.com] Please Confirm Your E-mail Address
From: webmaster@localhost
To: cashier@coffeehouse.com
Date: Wed, 12 Aug 2018 00:57:50 -0000
Message-ID: <20180812005750.15177.32621@laptop>

Hello from coffeehouse.com!

You're receiving this e-mail because user daniel at example.com has given yours as an e-mail address to connect their account.

To confirm this is correct, go to http://localhost:8000/accounts/confirm-email/1aflixsbb6sn14hptkntiyrgvk1r0pppqsurx6fxrs6wmlb96u8y3gotxzep0qie/

Thank you from coffeehouse.com!
coffeehouse.com

Listing 10-18.Confirm email for new user in django-allauth

```

将电子邮件中的验证链接复制并粘贴到您的浏览器中。一旦你点击验证链接，你将被要求确认用户的电子邮件。当您点击“确认”按钮进行最终验证时，您将再次被发送到`/accounts/login/` url，显示一条简短的消息，表明帐户已被确认。

现在再次在图 [10-11](#Fig11) 的登录表单中重新输入超级用户邮箱/密码，并点击“登录”按钮。这一次你将被重定向到`/accounts/profile/` url 或者在`settings.py`的`LOGIN_REDIRECT_URL`变量中定义的 url。

此时，您使用 Django allauth 提供的登录工作流表单作为超级用户登录到应用程序。接下来，直接进入 Django admin `/admin/` url，你可以确认你能够直接访问它！在这种情况下，不需要使用 Django admin 表单重新认证自己，因为您已经使用 Django allauth 工作流登录。

最后，为了退出应用程序，您可以访问`/accounts/logout/` url，在这里您会看到一个确认问题，询问您是否确定要退出，然后单击“退出”按钮实现退出操作。

正如您在本练习中所看到的，Django allauth 提供了与 Django admin 和`django.contrib.auth`包所使用的标准登录工作流的紧密集成，此外还提供了已经概述的特性:电子邮件验证、内置模板、内置电子邮件身份验证工作流，以及与用户名的向后兼容性。

### Django allauth 用户注册

如果你查看图 [10-11](#Fig11) 中所示的`/accounts/login/`网址，你可以看到有一个“注册”链接带你到网址`/accounts/signup/`。点击这个链接，你会看到一个表单，要求输入电子邮件和密码来创建一个用户帐户。

填写完表格后，点击“注册”按钮。如果提交成功，您将被重定向到“验证您的电子邮件地址”页面。这与上一节描述的行为相同，因为 Django allauth 要求在允许访问应用程序之前进行电子邮件验证。

类似地，继续检查 Django allauth 生成的电子邮件，并复制粘贴验证链接以完成用户注册过程。接下来，您可以继续使用这个用户的凭据登录，默认情况下是一个普通用户。

关于这个注册过程的一个有趣的点可能不是很明显，Django allauth 创建了一个只使用他的电子邮件的用户，这提出了一些问题:如果这个用户后来成为超级用户或职员来访问 Django admin 会发生什么？依赖用户名的 Django admin 登录表单会失效吗？没有这样的事；它将按预期工作。

在幕后，Django allauth 创建了一个常规的 Django 用户，并将其与 Django allauth 功能(例如，电子邮件登录、社交认证)集成在一起。这种内置的集成是一个非常好的特性，因为您可以获得 Django allauth 的所有好处，而且用户可以保留 Django 的默认用户管理，同一个用户可以获得 Django admin 访问、超级用户和员工权限、属于组的能力以及权限分配。

Django allauth 创建用户名的惯例是将电子邮件的本地部分(即@)作为用户名句柄。对于多个同名电子邮件创建一个账户的情况，Django allauth 会为用户名分配一个数字(如`nancy@coffeehouse.com=nancy`、`nancy@hotmail.com=nancy2`、`nancy@gmail.com=nancy3`)。

### 使用 Django allauth 重置和更改密码

用户需要的最常见的管理任务之一通常与密码有关，无论是因为忘记密码而重置密码，还是出于安全原因而更改密码。Django allauth 为这两种密码场景提供了内置支持。如果你转到`/accounts/password/reset/`网址，你会看到一个表单，用户可以在其中输入自己的电子邮件来重置密码。

一旦你在最后一个表单上输入了一封电子邮件，点击“重置我的密码”按钮，Django allauth 就会发送一封确认邮件，就像清单 [10-19](#Par207) 中的那封一样，带有一个密码重置链接。

```
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Subject: [coffeehouse.com] Password Reset E-mail
From: webmaster@localhost
To: nancy@coffeehouse.com
Date: Wed, 19 Aug 2018 03:05:09 -0000
Message-ID: <20180819030509.15780.98825@laptop>

Hello from coffeehouse.com!

You're receiving this e-mail because you or someone else has requested a password for your user account at coffeehouse.com.
It can be safely ignored if you did not request a password reset. Click the link below to reset your password.

http://localhost:8000/accounts/password/reset/key/5-44f-0f6fbf1251fd33ee4b40/

Thank you for using coffeehouse.com!
coffeehouse.com
-------------------------------------------------------------------------------

Listing 10-19.Reset email for new password django-allauth

```

接下来，如果您单击电子邮件中的重置链接，您将被带到另一个页面，在那里您可以输入新密码。单击“更改密码”按钮后，如果该过程成功，您将看到一条密码确认提示消息，指示用户密码已更新。

django-allauth 中另一个与密码相关的选项是允许用户在登录时修改密码。如果你转到`/accounts/password/change/`网址，你会看到一个屏幕，上面有一个介绍新密码的表格。单击“更改密码”按钮后，您将在同一屏幕上看到一条确认消息，表明用户密码已更新。

### 使用 Django allauth 添加和更改用户电子邮件

为了帮助用户改变他们最初的电子邮件注册地址，Django allauth 有一个专门的页面来管理电子邮件地址。如果你转到`/accounts/email/`网址，你会看到如图 [10-12](#Fig12) 所示的页面。

![A441241_1_En_10_Fig12_HTML.jpg](A441241_1_En_10_Fig12_HTML.jpg)

图 10-12。

Django allauth email management

如图 [10-12](#Fig12) 所示，除了可以向帐户添加其他电子邮件之外，用户还可以更改其主要电子邮件、重新发送电子邮件验证，甚至删除与帐户相关的电子邮件。

### 更改 Django allauth 的模板

Django allauth 内置模板提供了您在前面章节中看到的基本功能。所有内置模板都从名为`base.html`的模板中继承它们的行为，它们的内容包含在`{% block content %}{% block %}`中。这意味着您可以在您的 Django 项目中创建一个名为`base.html`的模板，其中包含您想要的所有元素(例如，自定义颜色、标题菜单)，并在其中声明`{% block content %}{% block %}`，Django allauth 内置模板将在此上下文中呈现。

如果您想完全定制 Django allauth 使用的模板(例如，包括移动友好的表单或一些其他的深层变化)，您可以在您的 Django 项目中提供覆盖模板。

Django allauth 依赖超过 15 个 HTML 模板和 6 个电子邮件模板；出于这个原因，如果您将 Django allauth 默认模板复制到您的 Django 项目中，然后根据需要修改它们，会更容易。您应该确保 Django allauth 模板与它们原来的`account`子文件夹一起被复制，这些子文件夹应该可以在`settings.py`中的`TEMPLATES`变量的`DIRS`值下被访问。根据您的 Python 安装，默认的 Django allauth 模板可以在路径/ `lib/python3.5/site-packages/allauth/templates/`中找到。

Tip

请参阅该书附带的源代码，其中包括所有 Django allauth 模板的布局。

### Django allauth 背后的模型和数据库表

虽然 Django allauth 利用了 Django 的默认用户模型`django.contrib.auth.models.User`或自定义用户模型(如果它作为`AUTH_USER_MODEL`配置的一部分提供的话),但是 Django allauth 依靠一系列新模型来支持其高级用户管理特性。图 [10-13](#Fig13) 展示了 Django admin 展示的 Django allauth 系列模型。

![A441241_1_En_10_Fig13_HTML.jpg](A441241_1_En_10_Fig13_HTML.jpg)

图 10-13。

Django admin with models for django-allauth

图 [10-13](#Fig13) 所示的第一个 Django allauth 包含对应于“账户”应用程序，包括“电子邮件地址”模型。“电子邮件地址”模型跟踪电子邮件、它们与用户模型记录的关联(例如`django.contrib.auth.models.User`)、主要电子邮件状态以及电子邮件的验证状态。应注意,“电子邮件地址”模型记录存储在`account_emailaddress`数据库表中。

同样值得一提的是，在图 [10-13](#Fig13) 中，您可以看到`django.contrib.auth.models.User`包中的标准“用户”和“组”模型。Django allauth 继续利用项目的用户模型来存储核心用户数据(如密码)

图 [10-13](#Fig13) 中包含的第二组 Django allauth 模型对应于社交账户，用于允许 Django 在社交媒体网站(如脸书、谷歌、Twitter)上进行身份验证，这是本章下一节也是最后一节的主题。

## Django allauth 的社会认证

社交认证包括在第三方网站(如脸书、谷歌、Twitter)上创建工作流(也称为应用程序),让这些网站的用户能够重用他们的身份来访问外部资源，在我们的例子中就是 Django 应用程序。这种能力在 Django 应用程序中是一个非常有价值的特性，因为它允许用户点击几次就可以注册，而不是经历一个更复杂的注册过程。

在最基本的层面上，社会认证过程涉及用户授权的令牌，然后在第三方站点和请求方(即您的 Django 应用程序)之间交换令牌以表明用户的同意。此外，根据应用程序及其配置，请求方(即 Django 应用程序)可以从第三方站点请求基本用户信息(例如电子邮件)以及更详细的信息(例如脸书应用程序中用户的朋友)。

Note

下面几节假设您已经设置了一个基本的 Django allauth 配置，如前一节所述。

### 为不同的社会服务提供者设置 Django allauth

Django allauth 支持许多社交提供者，每个提供者都通过其自己的包得到支持，这些包需要添加到`settings.py`中的`INSTALLED_APPS`列表中，如清单 [10-20](#Par224) 所示。

```
INSTALLED_APPS = [
    # Django sites framework is required
    'django.contrib.sites',
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    'allauth.socialaccount.providers.facebook',
    'allauth.socialaccount.providers.google',
    'allauth.socialaccount.providers.twitter',  
]

SOCIALACCOUNT_PROVIDERS = {'facebook': {}, 'google':{}, 'twitter':{}}

Listing 10-20.Social provider app installation for Django allauth in settings.py

```

正如你在清单 [10-20](#Par224) 中看到的，清单`INSTALLED_APPS`中的最后三个应用程序对应于三个社交提供商:脸书、谷歌和推特。将这些提供者添加到`INSTALLED_APPS`是使他们能够通过 Django allauth 进行社交认证的第一步。

除了`google`、`facebook`和`twitter`应用程序，Django allauth 还支持来自不同提供商 [<sup>3</sup>](#Fn3) 的 50 多个其他社交认证工作流，在同一个`allauth.socialaccount.providers`包下。

在清单 [10-20](#Par224) 中，您还可以看到`SOCIALACCOUNT_PROVIDERS`变量，它有一个对应于每个社交提供者的键字典。每个键都有一个空的字典值，该值最终将包含特定于提供者的配置选项。在接下来的部分中，我将描述如何设置每个社交提供者并填写这些配置值。

Caution

在获得社交提供商的真实连接参数之前，不要将社交提供商配置添加到`settings.py`。由于登录页面和其他工作流身份验证页面中缺少配置，您会得到错误。

除了`SOCIALACCOUNT_PROVIDERS`中的配置参数，您还需要通过 Django admin 添加一个社交提供商的应用凭证作为“社交应用”模型记录。进入 Django admin，点击“社交应用”模型，如图 [10-13](#Fig13) 所示。

接下来，您将看到如图 [10-14](#Fig14) 所示的屏幕，您可以在此编辑和添加社交应用，并点击右上角的“添加社交应用”按钮。在此页面上，您将看到如图 [10-15](#Fig15) 所示的屏幕，您可以在此选择社交提供商并引入与社交应用相关的各种值(如姓名、客户 id、密钥)。目前我们还没有这些值，但是让这个 Django 管理页面保持打开，因为接下来我将描述从哪里获得您添加到清单 [10-20](#Par224) 中的`INSTALLED_APPS`变量的三个社交提供者的值。

![A441241_1_En_10_Fig15_HTML.jpg](A441241_1_En_10_Fig15_HTML.jpg)

图 10-15。

Django social application create/edit page

![A441241_1_En_10_Fig14_HTML.jpg](A441241_1_En_10_Fig14_HTML.jpg)

图 10-14。

Django social application list page

### 和姜戈·阿劳斯一起建立脸书

要在 Django allauth 设置脸书社交认证，您需要一个脸书帐户来创建他们网站上的应用程序。前往[https://developers.facebook.com/apps](https://developers.facebook.com/apps)。如果你之前已经创建了一个脸书应用程序，你会看到如图 [10-16](#Fig16) 所示的屏幕，但是如果你从未创建过应用程序，那么你不会看到应用程序列表，但是你仍然会看到右上角的“添加新应用程序”绿色按钮，如图 [10-16](#Fig16) 所示。

![A441241_1_En_10_Fig16_HTML.jpg](A441241_1_En_10_Fig16_HTML.jpg)

图 10-16。

Facebook application list page

点击图 [10-16](#Fig16) 右上角的“添加新应用”按钮，您将看到如图 [10-17](#Fig17) 所示的弹出窗口。填写应用程序名称(如 Coffeehouse)和联系电子邮件的两个选项，然后点击“创建应用程序 ID”按钮。

![A441241_1_En_10_Fig17_HTML.jpg](A441241_1_En_10_Fig17_HTML.jpg)

图 10-17。

Facebook create application pop-up

当你点击“创建应用程序 ID”按钮时，应用程序创建完毕，你将进入应用程序的主页。接下来，让我们回到图 [10-16](#Fig16) 所示的应用程序列表页面，点击左栏下拉菜单中的“查看所有应用程序”按钮或再次访问 [`https://developers.facebook.com/apps`](https://developers.facebook.com/apps) 网址，稍后你可以点击应用程序列表页面上的应用程序返回应用程序主页。

在脸书应用列表页面(图 [10-16](#Fig16) )上，将鼠标指针悬停在您刚刚创建的应用的右上角，直到出现一个箭头，单击该箭头，并从弹出菜单中单击“创建测试应用”选项，如图 [10-18](#Fig18) 所示。

![A441241_1_En_10_Fig18_HTML.jpg](A441241_1_En_10_Fig18_HTML.jpg)

图 10-18。

Facebook created test application pop-up menu

接下来，会出现一个弹出窗口，您可以在其中为测试应用程序指定一个名称或保留默认名称；据此选择。终止后，您将看到如图 [10-19](#Fig19) 所示的屏幕，显示所有应用配置参数。如果没有看到图 [10-19](#Fig19) ，回到图 [10-16](#Fig16) 的脸书 app 列表页面，再次悬停在右上角，从弹出菜单中选择测试应用。

![A441241_1_En_10_Fig19_HTML.jpg](A441241_1_En_10_Fig19_HTML.jpg)

图 10-19。

Facebook test app main page

在图 [10-19](#Fig19) 中，您可以看到有一个“应用 ID”值，以及一个隐藏的“应用秘密”值，您可以通过单击“显示”按钮来查看。此外，在左侧，您可以看到一系列选项卡，用于进一步定制应用程序的参数。点击左侧栏中的“设置”/“基本”菜单。

在“设置”/“基本”菜单上，在页面底部中间你会看到一个大按钮“+添加平台”，如图 [10-20](#Fig20) 所示。点击“+添加平台”按钮，并在弹出菜单中选择“网站”选项。这将在“+添加平台”按钮上方添加一个“网站”框，在该框的输入字段中添加您的 Django 应用程序的 url(如`http://localhost`)以告知脸书接受来自该域的登录请求——如图 [10-20](#Fig20) 所示——此外，在页面顶部附近的“应用程序域”输入字段中也添加您的 Django 应用程序的 URL——如图 [10-20](#Fig20) 所示。

![A441241_1_En_10_Fig20_HTML.jpg](A441241_1_En_10_Fig20_HTML.jpg)

图 10-20。

Facebook test app configuration for authorized domain requests

接下来，转到 Django admin，在“社交应用”模型创建/编辑页面——如图 [10-15](#Fig15) 所示——通过从提供商列表中选择“脸书”来创建一个脸书应用，在“名称”框中引入一个友好的名称，在“客户端 Id”框中引入脸书的“应用 ID”值，在“密钥”框中引入脸书的“应用秘密”值。

接下来，打开 Django 项目的`settings.py`文件，用清单 [10-21](#Par241) 中所示的脸书配置参数更新`SOCIALACCOUNT_PROVIDERS`变量。

```
SOCIALACCOUNT_PROVIDERS =  { 'facebook':
                               {'METHOD': 'oauth2',
                                'SCOPE': ['email'],
                                'AUTH_PARAMS': {'auth_type': 'reauthenticate'},
                                'LOCALE_FUNC': lambda request: 'en_US',
                                'VERSION': 'v2.4'
                               }
                           }
Listing 10-21.Facebook social provider configuration for Django allauth in settings.py

```

清单 [10-21](#Par241) 中的设置是运行脸书认证的最基本的一组值，但是您可以在 Django allauth 文档中查阅许多其他选项。接下来，启动 Django 应用程序并访问`/accounts/login/`页面尝试登录，您将看到如图 [10-21](#Fig21) 所示的页面。

![A441241_1_En_10_Fig21_HTML.jpg](A441241_1_En_10_Fig21_HTML.jpg)

图 10-21。

Django login with social authentication options

正如你在图 [10-21](#Fig21) 中看到的，与基于 Django allauth 的配置中的登录页面不同，现在有了向脸书、谷歌和 Twitter 注册的选项。点击脸书链接，你将被重定向到脸书页面进行授权，如图 [10-22](#Fig22) 所示。

![A441241_1_En_10_Fig22_HTML.jpg](A441241_1_En_10_Fig22_HTML.jpg)

图 10-22。

Facebook social authorization pop-up

如图 [10-22](#Fig22) 所示，用户被告知该操作将在确认后共享其公共档案和电子邮件。如果用户单击“继续为...”按钮脸书用一个令牌和用户的信息(即，公共配置文件信息和电子邮件)联系 Django 应用程序。此时，Django allauth 创建一个用户，并让他通过常规的 Django allauth 用户创建工作流。

由于之前的 Django allauth 基本配置(此社交配置基于该配置)强制进行电子邮件验证，因此无论脸书认证工作流如何，用户在通过 Django allauth 验证其电子邮件帐户之前，将无法登录应用程序。一旦用户通过 Django allauth 发送的验证链接确认其电子邮件，用户将被标记为已验证，并可以继续登录应用程序-请注意，此电子邮件验证过程不是特定的，也不是社交认证所必需的，您可以禁用它。如果您希望在脸书返回响应后立即允许自动登录。

脸书认证和电子邮件验证完成后，用户可以随时点击“脸书”登录链接登录 Django 应用程序。

在幕后，Django allauth 在“社交应用令牌”和“社交帐户”模型中跟踪社交认证令牌和帐户，这两个模型都可以在 Django admin 中访问。

此外，Django allauth 还通过脸书工作流创建了一个普通的 Django 用户(例如,`django.contrib.auth.models.User`类),因此同一个用户能够利用 Django 的标准认证系统(例如成为超级用户或职员)。但是请注意，这种类型的用户依赖于脸书授权令牌——并且没有密码——因此认证必须始终通过`/accounts/login/`中的社交脸书认证链接来完成，Django admin 不为这种类型的用户工作，因为它需要输入密码。

请记住，除了多个特定于脸书的配置 Django allauth 选项超出了本讨论的范围之外，还有其他社交认证概念(例如，令牌撤销、回叫 URL)需要您自己探索和配置——假设它们不是特定于 Django 的——以便为最终用户提供简化的社交认证流程。

Note

前面的程序是作为脸书‘测试应用’完成的——参见图 [10-18](#Fig18) 。对于 Django 应用程序的实时版本，您必须在同一个脸书应用程序的主(即非测试)通道上执行相同的过程。

### 与姜戈·阿劳斯一起建立谷歌

要在 Django allauth 设置 Google social authentication，你需要一个 Google 帐户在他们的网站上创建一个应用程序。头转向 [`https://console.developers.google.com/`](https://console.developers.google.com/) 。如果你以前创建了谷歌项目，你将登陆一个默认项目。虽然您可以在任何 Google 项目上创建社交认证工作流，但我建议您为此创建一个新项目。

在顶部菜单栏上——在“Google APIs”徽标的右侧——有一个带有默认项目名称的菜单:单击它，会出现一个弹出窗口，其中包含项目列表。在最后一个弹出窗口中，搜索框旁边是一个名为“创建项目”的“+”(加号)按钮。点击“创建项目”按钮，您将被带到图 [10-23](#Fig23) 所示的页面。介绍一个项目名称，然后单击“创建”按钮。

![A441241_1_En_10_Fig23_HTML.jpg](A441241_1_En_10_Fig23_HTML.jpg)

图 10-23。

Google create project page

点击“创建按钮”后，您将进入项目主页，如图 [10-24](#Fig24) 所示。确保您处于刚刚创建的项目中，验证顶部菜单栏中选定项目的名称——位于“Google APIs”徽标的右侧。如果不是正确的项目，单击 project 并从弹出的项目列表中选择合适的项目。

![A441241_1_En_10_Fig24_HTML.jpg](A441241_1_En_10_Fig24_HTML.jpg)

图 10-24。

Google project main page

在图 [10-24](#Fig24) 的左侧菜单中，点击“凭证”选项。接下来，在页面中央，点击“添加凭证”按钮，并从下拉菜单中选择“OAuth 客户端 ID”选项，如图 [10-25](#Fig25) 所示。

![A441241_1_En_10_Fig25_HTML.jpg](A441241_1_En_10_Fig25_HTML.jpg)

图 10-25。

Google project Oauth client ID option

点击“OAuth 客户端 ID”选项后，您将进入“创建客户端 ID”页面，如图 [10-26](#Fig26) 所示。您应该选择“Web 应用程序”选项；但是，请注意页面顶部的警告，指示“要创建 OAuth 客户端 ID，您必须首先在同意屏幕上设置产品名称”。让我们先来看看这个同意屏幕，点击图 [10-26](#Fig26) 中的“配置同意屏幕”按钮，进入图 [10-27](#Fig27) 中的页面。

![A441241_1_En_10_Fig27_HTML.jpg](A441241_1_En_10_Fig27_HTML.jpg)

图 10-27。

Google project OAuth consent screen

![A441241_1_En_10_Fig26_HTML.jpg](A441241_1_En_10_Fig26_HTML.jpg)

图 10-26。

Google project create client ID page

图 [10-27](#Fig27) 中的同意屏幕用于定制当最终用户从一个应用程序(在我们的例子中是 Django 应用程序)寻求授权时，Google 如何接待最终用户。填写必填的“向用户显示的产品名称”字段，并保存更改。一旦保存同意屏幕，您将被带回到图 [10-26](#Fig26) 中的屏幕，在那里您可以选择“网络应用”选项。

在“Web 应用程序”页面中，“名称”字段被赋予默认的“Web 客户端 1”值，您可以相应地进行调整。将“授权 JavaScript origins”选项设置为 Django 应用程序的域(如`http://localhost`)，并将“授权重定向 URIs”选项设置为 Django allauth url `/accounts/google/login/callback/`，这是 Google 在成功认证后联系应用程序的地方——注意，最后一个值必须使用完全限定的域(如`http://localhost/accounts/google/login/callback/`)。

在“Web 应用程序”页面中输入必要的值后，单击“创建”按钮，您将看到如图 [10-28](#Fig28) 所示的弹出窗口，其中显示了应用程序客户端 ID 和客户端密码——如果您关闭该弹出窗口，稍后您可以在左侧的主“凭证”菜单中访问相同的值。

![A441241_1_En_10_Fig28_HTML.jpg](A441241_1_En_10_Fig28_HTML.jpg)

图 10-28。

Google project Client ID and Client Secret

接下来，转到 Django admin，在“社交应用”模型创建/编辑页面(如图 [10-15](#Fig15) 所示)中，通过从提供商列表中选择“Google”来创建一个 Google 应用，在“name”框中引入一个友好名称，在“Client ID”框中引入 Google“Client ID”值，并在“Secret key”框中引入 Google“Client Secret”值

接下来，打开 Django 项目的`settings.py`文件，用清单 [10-22](#Par261) 中所示的 Google 配置参数更新`SOCIALACCOUNT_PROVIDERS`变量。

```
SOCIALACCOUNT_PROVIDERS = { 'google':
                             { 'SCOPE': ['email'],
                               'AUTH_PARAMS': { 'access_type': 'online' }
                             }
                          }
Listing 10-22.Google social provider configuration for django-allauth in settings.py

```

清单 [10-22](#Par261) 中的设置是运行 Google 认证最基本的一组值，但是你可以在 Django allauth 文档中查阅许多其他选项。接下来，启动 Django 应用程序并访问图 [10-21](#Fig21) 中的`/accounts/login/`页面，尝试登录 Google。点击“谷歌”注册链接，你将被重定向到谷歌授权页面，如图 [10-29](#Fig29) 所示。

![A441241_1_En_10_Fig29_HTML.jpg](A441241_1_En_10_Fig29_HTML.jpg)

图 10-29。

Google social authorization page

如图 [10-29](#Fig29) 所示，用户被告知他将在确认后分享他是谁以及他的电子邮件。如果用户点击“Accept ”, Google 会用一个令牌和用户信息(即公开的个人资料信息和电子邮件)联系 Django 应用程序。此时，Django allauth 创建了一个用户，这样他每次只需点击“Google”登录链接就可以登录 Django 应用程序。

因为谷歌本身需要有效的电子邮件才能工作，这意味着通过谷歌认证的用户使用的是有效的电子邮件，因此 Django allauth 跳过了电子邮件验证过程，并自动将用户标记为已验证——不像脸书认证，用户可以继续使用脸书的陈旧和潜在无效的电子邮件。

在幕后，Django allauth 在“社交应用令牌”和“社交帐户”模型中跟踪社交认证令牌和帐户，这两个模型都可以在 Django admin 中访问。

此外，Django allauth 还通过 Google workflow 创建了一个普通的 Django 用户(例如,`django.contrib.auth.models.User`类),因此同一个用户能够利用 Django 的标准认证系统(例如成为超级用户或职员)。然而，请注意，这种类型的用户依赖于 Google 授权令牌——并且没有密码——因此认证必须始终通过`/accounts/login/`中的社交 Google 认证链接来完成，Django admin 不为这种类型的用户工作，因为它需要输入密码。

### 与 Django allauth 一起创建 Twitter

要在 Django allauth 中设置 Twitter 社交认证，您需要一个 Twitter 帐户来在他们的网站上创建一个应用程序。前往 [`https://apps.twitter.com/app/new`](https://apps.twitter.com/app/new) ，你会看到一个如图 [10-30](#Fig30) 所示的屏幕，创建一个 Twitter 应用程序。

![A441241_1_En_10_Fig30_HTML.jpg](A441241_1_En_10_Fig30_HTML.jpg)

图 10-30。

Twitter create app page

填写新 Twitter 应用程序所需的详细信息，确保“回调 URL”字段设置为`http://localhost:8000/accounts/twitter/login/callback/`，这是 Twitter 在成功认证后联系 Django 应用程序的地方。创建应用程序，您将被重定向到 Twitter 应用程序的主页。接下来，单击“密钥和访问令牌”选项卡，您将看到如图 [10-31](#Fig31) 所示的屏幕。

![A441241_1_En_10_Fig31_HTML.jpg](A441241_1_En_10_Fig31_HTML.jpg)

图 10-31。

Twitter app Key and Access Tokens page

接下来，转到 Django admin，在“社交应用”模型创建/编辑页面——如图 [10-15](#Fig15) 所示——从提供者列表中选择“Twitter ”,创建一个 Twitter 应用，在“name”框中引入一个友好名称，在“Client Id”框中引入 Twitter“Consumer Key(API Key)”值，在“Secret key”框中引入 Twitter“Consumer Secret”值。

Django allauth 不支持任何 Twitter 配置选项作为 settings.py 中的`SOCIALACCOUNT_PROVIDERS`变量的一部分，所以您可以跳过这个配置步骤。

接下来，启动您的 Django 应用程序并访问图 [10-21](#Fig21) 中的`/accounts/login/`页面，尝试 Twitter 登录。点击“Twitter”登录链接，您将被重定向到 Twitter 授权页面，如图 [10-32](#Fig32) 所示。

![A441241_1_En_10_Fig32_HTML.jpg](A441241_1_En_10_Fig32_HTML.jpg)

图 10-32。

Twitter social authorization page

正如你在图 [10-32](#Fig32) 中看到的，用户被告知他将在确认后分享推文和其他信息。如果用户点击“授权应用程序”，Twitter 会用一个令牌和用户的信息(即公开的个人资料信息)联系 Django 应用程序。此时，用户被重定向回网站，Django allauth 向用户索要电子邮件以完成帐户创建过程，如图 [10-33](#Fig33) 所示。

![A441241_1_En_10_Fig33_HTML.jpg](A441241_1_En_10_Fig33_HTML.jpg)

图 10-33。

Django allauth email request after Twitter social authorization

请注意，图 [10-33](#Fig33) 中的最后一个电子邮件请求是必要的，因为 Twitter 不提供带有社交认证的电子邮件——尽管很难相信，但这是已知的 Twitter 社交认证限制。

因为基本 Django allauth 配置强制执行电子邮件验证，以避免垃圾邮件，所以用户会收到一封验证电子邮件，在邮件中他必须单击一个链接才能完成激活。

一旦用户通过点击验证电子邮件链接确认了他的电子邮件，他就可以在任何时候通过点击“Twitter”登录链接来登录 Django 应用程序。在幕后，Django allauth 在“社交应用令牌”和“社交帐户”模型中跟踪社交认证令牌和帐户，这两个模型都可以在 Django admin 中访问。

此外，Django allauth 还使用 Twitter 工作流创建了一个普通用户(例如,`django.contrib.auth.models.User`类),因此该用户能够利用 Django 的标准认证系统(例如成为超级用户或职员)。但是请注意，这种类型的用户依赖 Twitter 授权令牌——并且没有密码——因此认证必须始终通过`/accounts/login/`中的社交 Twitter 认证链接来完成，Django admin 不为这种类型的用户工作，因为它需要输入密码。

Footnotes [1](#Fn1_source)

[T2`https://docs.djangoproject.com/en/1.11/topics/auth/passwords/#included-validators`](https://docs.djangoproject.com/en/1.11/topics/auth/passwords/#included-validators)

  [2](#Fn2_source)

[T2`https://docs.djangoproject.com/en/1.11/ref/contrib/auth/#module-django.contrib.auth.backends`](https://docs.djangoproject.com/en/1.11/ref/contrib/auth/#module-django.contrib.auth.backends)

  [3](#Fn3_source)

[T2`http://django-allauth.readthedocs.io/en/latest/providers.html`](http://django-allauth.readthedocs.io/en/latest/providers.html)