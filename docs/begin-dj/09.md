# 9.Django 模型表单和类视图

在前两章中，您学习了如何使用 Django 模型在关系数据库和 Django 项目之间移动数据。尽管这是 Django 模型的主要目的，但是 Django 模型实现的另一组重要功能并不直接绑定到数据库。

在这一章中，你将学习如何创建与 Django 模型不同的 Django 表单，这个过程进一步扩展了 Django 的 DRY(不要重复自己)原则。您将了解 Django 模型如何生成 Django 表单，包括它的字段、验证，以及将它的数据保存到数据库，所有这些都不需要编写第 [6](06.html) 章中描述的许多表单搭建逻辑。

接下来，您将了解 Django 基于类的模型视图。虽然你可以继续使用第 2 章[中介绍的 Django 视图技术——就像第 6 章](02.html)[中的表单技术一样——但是在牢牢掌握 Django 模型之后，你可以进一步将 Django DRY 原则应用到视图中。您将学习如何创建基于类的视图来执行模型 CRUD 操作，从而减少将模型 CRUD 操作合并到视图中所需的逻辑数量。](06.html)

## Django 模型表单结构和工作流程

Django 模型代表了将数据移入和移出数据库的标准方式。但是正如您在前两章中所了解到的，将数据移入和移出数据库的阶段需要您以编程方式操作模型记录(例如，`views.py`文件中的内部视图方法),以在模型上执行所需的 CRUD 操作。

虽然这对于任何 web 框架来说都是非常有效的工作流，但是您可以通过将 Django 模型链接到更自然的输入/输出机制(表单)来改进将数据移入和移出数据库的过程。

一旦您在实际项目中以编程方式创建了足够多的 Django 模型记录，您将会看到一种模式的出现:大多数 Django 模型操作背后的逻辑是由用户交互决定的。最终用户创建`Order`模型记录，最终用户读取`Store`模型记录，管理员更新`Menu`模型记录，或者管理员删除`Item`模型记录。这些最终用户和管理员用什么来交流这些模型操作呢？确切地说，是用户界面(UI)中的表单。

现在让我们看看将表单链接到模型的另一面。在第 [6](06.html) 章中，您学习了 Django 表单，但是您是否意识到在表单数据被处理后，您最有可能对其进行什么操作呢？您最有可能将它保存到数据库中，这涉及到 Django 模型。

因此，本着 Django 的 DRY 原则的精神，模型表单提供了一种使用 Django 模型作为基础来生成 Django 表单以在 Django 模型上执行 CRUD 操作的方法。换句话说，不是创建一个独立的 Django 表单，然后创建必要的“粘合”代码来创建 Django 模型实例，反之亦然，而是创建一个独立的 Django 模型，然后创建必要的表单来对模型记录进行 CRUD 操作，Django 模型表单允许您不重复自己。

## 创建 Django 模型表单

回到第 [6](06.html) 章，您创建了一个 Django 表单来获取姓名、电子邮件和评论。接下来，我们将把这个表单重新设计成一个模型表单，以便能够快速地将数据保存到数据库中。

创建模型表单的第一步是创建一个模型作为数据的基础。清单 [9-1](#Par12) 展示了一个 Django 模型类，紧接在从模型创建的 Django 模型表单之后。

Tip

参考本书附带的源代码来运行练习，以减少打字和自动访问测试数据。

```py
from django import forms

class Contact(models.Model):
      name = models.CharField(max_length=50,blank=True)
      email = models.EmailField()  
      comment = models.CharField(max_length=1000)

class ContactForm(forms.ModelForm):
      class Meta:      
            model = Contact
            fields = '__all__'

Listing 9-1.Django model class and model form

```

清单 [9-1](#Par12) 的第一个重要方面是 Django 模型遵循标准的模型语法，有三个字段使用模型字段来限制模型存储的数据类型。清单 [9-1](#Par12) 中的模型保持简单，以便更好地说明模型形式，但是可以添加你在前两章中学到的任何其他模型功能(例如，验证器、清理方法、元选项)。

清单 [9-1](#Par12) 中的下一个是代表表单的`ContactForm`类，它从`django.forms.ModelForm`类继承了它的行为，最后一个类使它成为一个模型表单。注意`ContactForm`类没有任何表单域，就像你在第 [6](06.html) 章的表 [6-2](https://doi.org/10.1007/978-1-4842-2787-9_6Tab#2) 中学到的那样；相反，它声明了一个类似于模型中使用的`Meta`类部分。

`ContactForm`的`Meta`类部分指定了两个选项:`model`和`fields`。`model`选项指示使用哪个模型来生成表单，在本例中，`Contact`模型也在清单 [9-1](#Par12) 中。`fields`选项指示使用哪些模型字段来生成表单，在这种情况下，`'__all__'`告诉 Django 使用模型中的所有模型`fields`。

清单 [9-1](#Par12) 中`ContactForm`的强大之处在于它使用两条语句创建一个表单，该表单反映了与`Contact`模型相同的字段类型。这不仅避免了重复(例如，在显式表单域中键入)，表单域还继承了模型的验证行为(例如，`models.EmailField()`被翻译成`forms.EmailField`)。但是在我描述完模型表单的基础知识之后，我将很快描述更多关于这个模型到表单继承行为的细节和选项。

一旦有了一个模型表单类，您可能想知道它的处理与标准的 Django 表单有什么不同？实际上很少；你在第 [6](06.html) 章学到的处理、验证和布局表单的概念对模型表单同样有效，如清单 [9-2](#Par18) 所示。

```py
# views.py method to process model form
def contact(request):
    if request.method == 'POST':
        # POST, generate bound form with data from the request
        form = ContactForm(request.POST)
        # check if it's valid:
        if form.is_valid():
            # Insert into DB
            form.save()

            # redirect to a new URL:
            return HttpResponseRedirect('/about/contact/thankyou')
    else:
        # GET, generate unbound (blank) form
        form = ContactForm()
    return render(request,'about/contact.html',{'form':form})

# See chapter 6 for form layout template syntax in about/contact.html

Listing 9-2.Django model form processing

```

在清单 [9-2](#Par18) 中，你可以看到视图方法序列遵循与标准 Django 表单相同的模式。当用户在 view 方法上发出 GET 请求时，会创建一个未绑定表单实例，并发送给用户，并通过`about/contact.html`模板呈现。接下来，当用户通过 POST 请求提交表单时，使用`request.POST`参数创建一个绑定表单，然后使用`is_valid()`方法对其进行验证。如果表单值无效，则有错误的绑定表单被返回给用户，以便他可以纠正错误，如果表单值有效，在清单 [9-2](#Par18) 的特定情况下，用户被重定向到`/about/contact/thankyou`页面。

然而，在清单 [9-2](#Par18) 中，模型表单有一个重要的处理差异。在表单的值被确定为有效之后，在模型表单实例上调用`save()`。这个`save()`方法被绑定到表单的支持模型`save()`方法，这意味着表单数据被结构化为模型记录并保存到数据库中。

如您所知，与创建和处理独立的表单和独立的模型相比，创建和处理模型表单的过程节省了大量时间。

## Django 模型表单选项和字段映射

现在您已经了解了模型表单的基本操作，让我们来看看它的各种选项。大多数模型表单选项都在元类语句中声明，如清单 [9-1](#Par12) 所示。但是，也可以声明常规的表单字段，或者覆盖默认的模型字段行为，或者包含新的表单字段。

### 模型表单必需选项:模型和字段或排除

模型表单从`forms.ModelForm`类继承它们的行为——而不是标准的`forms.Form`类——因此 Django 总是期望表单基于一个模型，这就是元`model`选项的目的。因此`model`选项值总是模型表单的一个要求。

Django 并不期望模型的结构与表单完美匹配，Django 还期望您明确告诉它支持模型的哪些字段应该或不应该成为模型表单的一部分。这可以通过`fields`选项——指示哪些模型字段成为模型表单的一部分——或`exclude`选项——指示哪些模型字段不应该成为模型表单的一部分来实现。总是需要`fields`或`exclude`选项，即使模型表单将包含支持模型的所有字段。注意清单 [9-1](#Par12) 中的模型表单示例是如何声明选项`fields='__all__'`来创建一个模型表单，该表单捕获与它的支持模型相同的一组字段。

当您使用除了`fields='__all__'`(例如，模型字段的缩短列表)或`exclude`选项(例如，要在表单中省略的模型字段的列表)之外的东西来声明模型表单时，请注意您是有意地并且潜在地违反了模型的规则。例如，默认情况下，所有的模型字段都是必需的，因此如果您创建一个省略了某些字段的模型表单——使用`fields`或`exclude`——表单本身可以正常显示，但是模型表单永远不会成功完成其标准工作流，除非您手动添加这些省略的字段。在这种情况下，最终用户将看到“无效表单错误”，因为表单的模型部分由于所需的模型字段值而被破坏。关于模型表单验证和初始化的下一节将描述如何向模型表单中手动添加省略的字段值。

正如您所看到的，您可以创建一个比它的支持模型有更多或更少字段的模型表单。此外，还可以向模型表单添加新的字段——它不是支持模型的一部分——以及定制由模型字段生成的默认表单字段。

为了描述最后两种情况的解决方案，下一节将描述由每个模型字段生成的不同表单字段——这样您就可以确定是否需要自定义默认行为——随后的一节将描述如何自定义和向模型表单添加新字段。

### 模型表单默认字段映射

模型表单遵循一定的规则将表 [7-1](07.html#Tab1) 中描述的模型字段数据类型转换为表 [6-2](06.html#Tab2) 中描述的表单字段数据类型。在大多数情况下，模型字段数据类型被转换成镜像等价的表单字段数据类型。例如，如果模型字段使用`models.CharField`数据类型，则模型表单会将该字段转换为`forms.CharField`数据类型。

表 [9-1](#Tab1) 说明了模型数据类型和表单数据类型之间使用的模型表单映射。请注意，模型和表单之间具有镜像数据类型映射的数据类型包含在表 [9-1](#Tab1) 的第一行中。

表 9-1。

Model form data type mapping between models and forms

<colgroup><col> <col></colgroup> 
| 模型字段 | 表单字段 |
| --- | --- |
| 模特。布尔菲尔德 | 表格。布尔菲尔德 |
| 模特。日期字段 | 表格。日期字段 |
| 模特。日期 | 表格。日期 |
| 模特。德西马菲尔德 | 表格。德西马菲尔德 |
| 模特。邮箱 | 表格。邮箱 |
| 模特。文件字段 | 表格。文件字段 |
| 模特。文件路径字段 | 表格。文件路径字段 |
| 模特。浮田 | 表格。浮田 |
| 模特。像场 | 表格。像场 |
| 模特。整数 | 表格。整数 |
| 模特。IP 地址字段 | 表格。IP 地址字段 |
| 模特。GenericIPAddressField | 表格。GenericIPAddressField |
| 模特。NullBooleanField | 表格。NullBooleanField |
| 模特。斯拉格菲尔德 | 表格。斯拉格菲尔德 |
| 模特。时间字段 | 表格。时间字段 |
| 模特。URLField | 表格。URLField |
| 模型。自动字段模型。BigAutoField | 不在表单中显示，因为自动建模字段是由数据库生成的。 |
| 模特们。毕希菲尔德 | 表格。IntegerField，最小值设置为-9223372036854775808，最大值设置为 9223372036854775807) |
| 模特。类型 | 表格。CharField，如果 null=True，max_length 设置为模型字段的 max_length，empty_value 设置为 None |
| 模特。CommaSeparatedIntegerField | 表格。类型 |
| 模特。外键 | 表格。模型选择字段 |
| 模特。多对多字段 | 表格。模型多重选择字段 |
| 模特。正积分域 | 表格。整数字段，min_value 设置为 0 |
| 模特。PositiveSmallIntegerField | 表格。整数字段，min_value 设置为 0 |
| 模特。SmallIntegerField | 表格。整数 |
| 模特。文本字段 | 表格。CharField，with widget=forms。文本区域 |

正如你在表 [9-1](#Tab1) 中看到的，超过 50%的 Django 模型数据类型直接映射到等价的表单数据类型。大多数剩余的模型数据类型映射到稍微调整的表单数据类型，以更好地适应支持模型类型(例如，`models.PositiveIntegerField`映射到`forms.IntegerField`，但是表单`min_value`值为 0)。

只有表 [9-1](#Tab1) 中的四种模型数据类型没有直接映射到表 [6-2](06.html#Tab2) 中第 [6](06.html) 章描述的表单数据类型。`models.AutoField`和`models.BigAutoField`模型数据类型从不在模型表单中表示，原因很简单，它们的值是由数据库自动分配的，所以它们在表单中没有输入位置。`models.ForeignKey`和`models.ManyToManyField`模型数据类型代表模型关系，这意味着它们的数据来自不同的模型。反过来，`models.ForeignKey`和`models.ManyToManyField`模型数据类型不映射到字符串或数字的常规表单字段，而是映射到表示其他模型数据的表单字段，这就是特殊表单数据类型:`forms.ModelChoiceField`和`forms.ModelMultipleChoiceField`的用途。这最后两个表单字段将在后面的带有关系的模型表单小节中描述。

Tip

要查阅表单域数据类型产生的 HTML(如<input type="“text”">查阅表 [6-2](06.html#Tab2) ，其中包含表单域和表单小部件之间的映射，最后一个小部件产生实际的表单 HTML 标记。

### 模型表单新的和定制的字段:小部件、标签、帮助文本、错误消息、字段类和本地化字段

现在您已经知道了如何将所有模型字段转换为模型表单中的表单字段，让我们来解决如何在模型表单中添加和自定义表单字段的问题。

向模型表单添加新的表单域就像声明一个表单域一样简单，就好像它是一个常规表单一样。还可以自定义模型字段数据类型使用的默认表单字段数据类型(即表 [9-1](#Tab1) 中的映射)，方法是声明一个与模型字段同名的新表单字段，使其优先于默认的模型-表单字段映射。

清单 [9-3](#Par36) 展示了清单 [9-1](#Par12) 中的 Django 模型类和模型表单，更新后包括了一个新的表单字段和一个覆盖默认模型表单字段映射的表单字段。

```py
from django import forms

def faq_suggestions(value):
      # Validate value and raise forms.ValidationError for invalid values
      pass     

class Contact(models.Model):
      name = models.CharField(max_length=50,blank=True)
      email = models.EmailField()  
      comment = models.CharField()

class ContactForm(forms.ModelForm):
      age = forms.IntegerField()

      comment = forms.CharField(widget=forms.Textarea,validators=[faq_suggestions])

      class Meta:      
            model = Contact
            fields = '__all__'

Listing 9-3.Django model form with new and custom field

```

清单 [9-3](#Par36) 首先添加了新的`age`表单字段来捕获表单中的整数值。尽管底层的`Contact`模型从来不知道`age`字段或值，但通过这种修改，模型表单将要求该字段作为表单工作流的一部分提供。

清单 [9-3](#Par36) 中的下一个是`comment`表单字段，它覆盖了同名的底层模型字段。在这种情况下，覆盖`comment`表单字段的目的是添加一个自定义的`widget`，以及添加一个自定义的`validators`方法，以便在表单被认为有效之前验证`comment`值——注意`widget`和`validators`选项都是第 [6](06.html) 章中描述的标准表单选项。

清单 [9-3](#Par36) 中的表单域覆盖机制有优点也有缺点。这样做的好处是您可以完全控制表单域来定义任何选项。缺点是传递给表单域的模型域选项(如`max_length`)丢失，需要作为新表单域语句的一部分重新声明。

为了保留模型字段的底层行为并仍然能够定制某些表单字段选项，除了`model`、`fields`和`exclude`选项之外，模型表单还支持额外的元类选项。清单 [9-4](#Par41) 展示了一个模型表单的附加元选项来覆盖默认的模型表单字段映射，同时保持底层的模型字段行为。

```py
from django import forms

class Contact(models.Model):
      name = models.CharField(max_length=50,blank=True)
      email = models.EmailField()  
      comment = models.CharField()

class ContactForm(forms.ModelForm):
      class Meta:      
            model = Contact
            fields = '__all__'
            widgets = {

               'name': models.CharField(max_length=25),

               'comment': form.Textarea(attrs={'cols': 100, 'rows': 40})

            }

            labels = {

               'name': 'Full name',

               'comment': 'Issue'

            }

            help_texts = {

               'comment': 'Provide a detailed account of the issue to receive a quick answer'

            }

            error_messages = {

               'name': {

               'max_length': "Name can only be 25 characters in length"

                }

            }

            field_classes = {

               'email': EmailCoffeehouseFormField

            },

            localized_fields = '__all__'

Listing 9-4.Django model form with meta options to override default form field behavior

```

清单 [9-4](#Par41) 中的元模型表单选项最重要的方面是它们是表单域选项的复数名称，在第 [6](06.html) 章中有描述。清单 [9-4](#Par41) 中突出显示的模型表单元选项是复数的，因为它们可以将多个表单字段的选项声明为一个字典，其中每个键代表表单字段名称，其值代表选项值。

例如，清单 [9-4](#Par41) 中的`widgets`和`labels`元选项为`name`和`comment`模型表单字段定义了定制部件和标签。`help_texts`元选项为`comment`模型表单字段定义了`help_text`选项，而`error_messages`元选项为`name`模型表单字段上的`max_length`键错误声明了一个定制表单错误消息。

接下来，清单 [9-4](#Par41) 中的`field_classes`元选项用于为`email`模型表单字段声明一个定制表单字段。最后，清单 [9-4](#Par41) 中的`localized_field`元选项被设置为`__all__`以告诉 Django 本地化(即转换成不同的语言)所有模型表单字段。如果省略了`localized_field`选项，那么模型表单字段不会被本地化。值得一提的是，您可以通过将模型表单字段的列表传递给`localized_field`选项来选择性地本地化某些模型表单字段，就像使用`fields`和`exclude`选项一样。

## 有关系的 Django 模型表单

正如您在前两章中所了解到的，Django 模型之间可以有关系，这反过来使得模型具有引用另一个模型中的记录的数据类型(例如，`ForeignKey`，`ManyToManyField`)。

当在模型表单的上下文中使用包含这种数据类型的模型时，Django 依赖于两个特殊的表单字段。默认情况下，`ForeignKey`模型字段转换为`ModelChoiceField`表单字段，`ManyToManyField`模型字段转换为`ModelMultipleChoiceField`表单字段。

`ModelChoiceField`和`ModelMultipleChoiceField`表单字段的好处是它们基于 Django 模型查询生成表单字段。因此，`ModelChoiceField`和`ModelMultipleChoiceField`表单域生成一个包含模型记录的友好的 HTML `<select>/<option>`输入域，而不是用模型数据手工填充表单域。

### 模型选择字段和模型多重选择字段表单字段选项:queryset、empty_label、to_field_name 和 label_from_instance

Tip

`ModelChoiceField`和`ModelMultipleChoiceField`是标准表单字段，可用于任何需要模型数据的 Django 表单。默认情况下，它们被用在有关系的模型表单上，但是它们并不局限于模型表单(即，从`forms.ModelForm`继承的表单)。

Note

`ModelChoiceField`和`ModelMultipleChoiceField`是标准表单字段(即 Django `forms`包的一部分)，也接受标准表单选项:必填、小部件、标签、初始、help_text 和 limit _ choices _ to——如第 [6 章](06.html)所述。

由于`ModelChoiceField`和`ModelMultipleChoiceField`表单字段使用模型记录来获取数据，因此它们明确需要模型查询。对于从`forms.ModelForm`继承其行为的模型表单，它们的基础模型包含一个`ForeignKey`或`ManyToManyField`模型字段，这个模型查询是自动设置的。例如，如果一个`Item`模型包含一个`ForeignKey`到一个`Menu`模型，一个`Item`模型表单在一个表单中显示所有的`Menu`记录，允许用户选择一个单独的`Menu`记录。类似地，如果一个`Store`模型包含一个`ManyToManField`到一个`Amenity`模型，一个`Store`模型表单在一个表单中呈现所有的`Amenity`记录，允许用户选择多个`Amenity`记录。

虽然这种行为在大多数情况下是可以接受的，但当您需要过滤默认行为以使用模型表单字段上的所有模型记录时，或者当这些表单字段用于常规表单(即继承了`forms.Form`)时，可能有必要提供对`ModelChoiceField`或`ModelMultipleChoiceField`表单字段的显式查询。

清单 [9-5](#Par53) 展示了使用`queryset`选项在`ModelChoiceField`和`ModelMultipleChoiceField`表单字段上设置模型查询的两种技术。

```py
from django import forms
from coffeehouse.stores.models import Amenity

class Menu(models.Model):
    name = models.CharField(max_length=30)
    def __str__(self):
        return "%s" % (self.name)

class Item(models.Model):
    menu = models.ForeignKey(Menu, on_delete=models.CASCADE)
    name = models.CharField(max_length=30)
    description = models.CharField(max_length=100)

class ItemForm(forms.ModelForm):
    menu = forms.ModelChoiceField(queryset=Menu.objects.filter(id=1))

    class Meta:       
        model = Item
        fields = '__all__'

class StoreForm(forms.Form):
    name = forms.CharField()    
    address = forms.CharField()
    amenities = forms.ModelMultipleChoiceField(queryset=None)

    def __init__(self, *args, **kwargs):
        super(StoreForm, self).__init__(*args, **kwargs)
        self.fields['amenities'].queryset = Amenity.objects.filter(name__contains='W')

Listing 9-5.Django model form and standard form with custom query for ModelChoiceField and ModelMultipleChoiceField form fields

```

清单 [9-5](#Par53) 中的第一项技术通过用`ItemForm`模型表单上的自定义`ModelChoiceField()`覆盖`menu`字段来定义内联`queryset`值。在这种情况下，不是`ItemForm`模型表单有一个包含所有`Item`记录的`menu`字段，而是将`menu`字段限制为只有包含`id=1`的`Item`记录。

清单 [9-5](#Par53) 中的第二项技术在标准表单上定义了一个空的`queryset`值，该表单在`amenities`字段上使用了一个`forms.ModelMultipleChoiceField()`表单字段。但是在表单的`__init__`方法中，`amenities`字段被设置为一个查询，该查询将其记录限制为包含字母`W`的`Amenity`记录。

值得一提的是，清单 [9-5](#Par53) 中展示的两种`queryset`技术在模型表单和常规表单中同样有效，同样有效的还有`ModelChoiceField()`和`ModelMultipleChoiceField()`表单字段。

默认情况下，不定义`initial`值的`ModelChoiceField()`表单字段生成时会将空的 HTML `<option>---------</option>`选项作为默认字段值。可以通过`empty_label`选项自定义该空选项的值(例如`empty_label='Please select a value'`，输出`<option>Please select a value</option>`)。也可以用`empty_label=None`禁用这个空选项。

默认情况下，`ModelChoiceField()`和`ModelMultipleChoiceField()`表单字段都从模型记录的主键值(即`id)`和模型`__str__`方法表示)生成它们的 HTML `<select>/<option>`输入字段值。例如，给定清单 [9-5](#Par53) 中的`Menu`模型定义，该模型的 HTML `<select>/<option>`输入字段将如下所示:

```py
<select name="menu" required id="id_menu">
     <option value="" selected>---------</option>
     <option value="1">Breakfast</option>
     <option value="2">Salads</option>
     <option value="3">Sandwiches</option>
     <option value="4">Drinks</option>
</select>

```

注意每个`<option> value`对应一个记录的主键`id`值，而`<option>`文本对应一个由模型的`__str__`方法返回的记录的`name`字段。

可以使用`to_field_name`选项定制`ModelChoiceField()`和`ModelMultipleChoiceField()`表单字段中使用的`<option> value`。例如，在最后一个代码片段的上下文中设置`to_field_name='name'`，将 HTML `<select>/<option>`输入字段更改为格式`<option value="Breakfast">Breakfast</option>`。

Caution

使用 to_field_name 值会破坏基础模型表单保存到数据库的能力，因为模型的关系值被设置为与模型关系所期望的主键不同的值。

除了定制`<option> value`之外，通过覆盖`ModelChoiceField()`和`ModelMultipleChoiceField()`表单域中的`label_form_instance`方法，还可以将表单域中的`<option>`文本定制为除模型的`__str__`方法之外的东西。清单 [9-6](#Par64) 展示了一个为此目的设计的定制表单域。

```py
from django import forms
from django.forms import ModelChoiceField

class MenuModelChoiceField(ModelChoiceField):
    def label_from_instance(self, obj):
        return "Menu #%s) %s" % (obj.id,obj.name)

class ItemForm(forms.ModelForm):
    menu = MenuModelChoiceField(queryset=Menu.objects.all())
    class Meta:      
        model = Item
        fields = '__all__'

# HTML menu form field output
<select name="menu" id="id_menu" required>
  <option value="" selected>---------</option>
  <option value="1">Menu #1) Breakfast</option>
  <option value="2">Menu #2) Salads</option>
  <option value="3">Menu #3) Sandwiches</option>
  <option value="4">Menu #4) Drinks</option>
</select>

Listing 9-6.Django custom form field to customize <option> text for ModelChoiceField and ModelMultipleChoiceField form fields

```

清单 [9-6](#Par64) 中的第一步创建了从`ModelChoiceField`表单域继承其行为的`MenuModelChoiceField`定制表单域，并定义了`label_from_instance`方法的实现。在这种情况下，`label_from_instance`方法告诉 Django 生成以`Menu #`静态字符串为前缀的`<option>`文本值，后跟模型的`id`和`name`。注意同样的技术可以用来定制一个`ModelMultipleChoiceField`，只要确保改变定制表单域的继承类。

接下来，通过`menu`字段将清单 [9-6](#Par64) 中的`MenuModelChoiceField`定制表单字段添加到同一清单中的`ItemForm`模型表单中。因为`MenuModelChoiceField`是一个定制的`ModelChoiceField`表单字段，所以有必要指定一个显式的`queryset`值来填充表单字段，在本例中，它对应于所有的`Menu`模型记录。

最后，清单 [9-6](#Par64) 展示了`menu`字段的 HTML `<option>`文本输出遵循自定义`MenuModelChoiceField`自定义表单字段中定义的模式。

## Django 模型表单处理

现在您已经对各种模型表单选项有了坚实的理解，是时候更深入地了解模型表单处理了，这在清单 [9-2](#Par18) 中有简要介绍。

在处理模型表单时要考虑的最重要的因素是您正在处理两个实体:表单和模型。在清单 [9-2](#Par18) 中展示的模型表单处理示例中，这个事实并不太明显，主要是因为表单完全符合支持模型。但是，当您修改任何模型表单部件时，使用表示表单和模型的单个引用可能需要更多的考虑。

### 模型表单初始化:初始和实例

模型表单可以使用两个初始化参数:`initial`和`instance`。`initial`参数的工作方式就像标准的`initial`表单参数——在第 [6](06.html) 章中描述——为未绑定表单提供初始值。`instance`参数用于用一个模型实例初始化一个模型窗体，该模型实例也用于初始化一个未绑定窗体的值。

在所有的模型表单中，正如您在前面章节中所学的，表单定义优先于任何底层的模型定义。这意味着`initial`参数中的所有模型表单值优先于通过`instance`参数定义的值。清单 [9-7](#Par72) 显示了使用`initial`和`instance`参数的模型表单初始化序列。

```py
from coffeehouse.items.models import Item

preloaded_item = Item.objects.get(id=1)

# Model form from Listing 9-6, initialize with instance
form = ItemForm(instance=preloaded_item)

# Unbound form set up with instance values
form.as_p()
  <p>
   <label for="id_menu">Menu:</label>
        <select name="menu" required id="id_menu">
            <option value="">---------</option>     
            <option value="1" selected>Menu #1) Breakfast</option>

            <option value="2">Menu #2) Salads</option>
            <option value="3">Menu #3) Sandwiches</option>
            <option value="4">Menu #4) Drinks</option>
         </select>
  </p>
  <p>
    <label for="id_name">Name:</label>
          <input type="text" name="name"
               value="Whole-Grain Oatmeal" required maxlength="30" id="id_name" />
    </p>
    # Remaining fields committed for brevity

# Model form from Listing 9-6, initialize with instance and override with initial
form2 = ItemForm(initial={'menu':3},instance=preloaded_item)

# Unbound form set up with instance values
form2.as_p()

# Unbound form set up with instance values, but overridden with initial
form2.as_p()
  <p>
   <label for="id_menu">Menu:</label>
        <select name="menu" required id="id_menu">
            <option value="">---------</option>     
            <option value="1">Menu #1) Breakfast</option>
            <option value="2">Menu #2) Salads</option>
            <option value="3" selected>Menu #3) Sandwiches</option>

            <option value="4">Menu #4) Drinks</option>
         </select>
  </p>
   # Remaining fields committed for brevity

Listing 9-7.Django model form initialization with initial and instance

```

清单 [9-7](#Par72) 中的第一步是获取一个`Item`模型记录来填充`ItemForm`模型表单；在这种情况下，进行查询以获得带有`id=1`的`Item`模型记录。接下来，`Item`模型记录被用来用实例值初始化模型表单。在清单 [9-7](#Par72) 中，表单是用标准的`as_p()`表单方法输出的，您可以确认表单字段是预先选择的，以反映底层的模型记录。

清单 [9-7](#Par72) 中的下一个是同一个`ItemForm`模型表单的初始化序列，但是它也结合使用了`initial`参数和`instance`参数。在这种情况下，因为`initial`参数提供了`'menu':3`值，所以未绑定表单的`menu`字段被设置为值`3`，而不是模型记录的实例`menu`值`1`。从而确认`initial`参数值优先于`instance`参数值。

注意，只使用`initial`参数——而不使用`instance`参数——来初始化一个模型表单，就像它是一个常规表单一样，这同样有效。在模型表单的初始化阶段，表单的模型部分不知道任何值，直到模型表单进入验证阶段，底层模型才知道任何表单值。

### 模型表单验证

与模型表单初始化类似，模型表单验证可能看起来是交织在一起的，因为您处理的是一个既引用表单又引用模型的变量。但是只要你知道表单验证的基本步骤——在第 [6](06.html) 章中描述——和模型验证——在第 [7](07.html) 章中描述——模型表单验证就很简单。

回到清单 [9-2](#Par18) ，您学习了如何通过在视图方法(例如`ContactForm(request.POST)`)中传递`request.POST`值来将模型表单转换为绑定表单(即包含用户数据的表单)。一旦有了绑定表单，标准的 Django 表单验证工作流就会继续应用于模型表单:对表单引用调用`is_valid()`方法，根据表单验证规则验证用户提交的数据。如果有任何表单规则不符合，一个`errors`字典将被添加到表单引用中，并给出原因，它将作为一个重新呈现的有错误的表单返回给用户。如果`is_valid()`方法成功，模型表单的处理逻辑就可以进入下一步。

一旦模型表单通过了`is_valid()`方法测试，您实际上可以使用相同的标准表单`cleaned_data()`方法来访问包含有效表单数据内容的字典(例如，`form.cleaned_data()`包含`{'name': '...','email': '...','comment': '...', }`)。但是由于您使用的是模型表单，您更可能采取的步骤是使用表单数据来进一步与模型进行交互。

为了促进这一过程，Django 向表单引用添加了`instance`字段，其中包含了作为模型表单底层模型实例的表单数据。当您在尝试模型操作之前需要或必须操作模型数据时,`instance`字段尤其重要。这是模型表单验证过程中最关键的方面:即使在表单`is_valid()`方法通过并且数据被用于在`instance`字段中构造模型实例之后，这个模型实例数据仍然必须经过模型验证，否则就有被支持的模型验证规则拒绝的风险。

对于简单的模型表单场景，其中模型和表单直接相互映射——如清单 [9-2](#Par18) 中所示——操纵`instance`字段是不必要的(例如，在表单`is_valid()`方法传递之后，您可以调用`form`引用上的`save()`方法来将模型实例保存在`instance`中)。但是对于模型和表单在字段数量上不同的模型表单，您需要在表单`is_valid()`方法传递之后和调用模型表单的`save()`方法之前执行额外的逻辑。

清单 [9-8](#Par82) 展示了模型表单的两个验证过程，其中表单省略了底层模型中的字段。

```py
from django import forms
from django.conf import settings

class Contact(models.Model):
      user = models.ForeignKey(settings.AUTH_USER_MODEL, null=True, default=None)

      name = models.CharField(max_length=50,blank=True)
      email = models.EmailField()  
      comment = models.CharField()

class ContactForm(forms.ModelForm):
      class Meta:      
            model = Contact
            exclude = ['user']

# Option 1) Form model processing with missing value assigned with instance
         if form.is_valid():
            # Check if user is available
            if request.user.is_authenticated():

                # Add missing user to model form
                form.instance.user = request.user

            # Insert into DB
            form.save()

# Option 2) Form model processing with missing value assigned after model form sequence
            if form.is_valid():
            # Save instance but don't commit until model instance is complete
            # form.save() returns a materialized model instance that has yet to be saved
            pending_contact = form.save(commit=False)

             # Check if user is available
            if request.user.is_authenticated():

                # Add missing user to model form
                pending_contact.user = request.user

            # Insert into DB
            pending_contact.save()

Listing 9-8.Django model form with reduced form that requires model update before saving

```

清单 [9-8](#Par82) 中的`Contact`模型类似于前面清单中使用的模型类，但是有额外的`user`字段来注册 Django 用户作为模型记录的一部分。接下来，在清单 [9-8](#Par82) 中是`ContactForm`模型表单——基于最后一个`Contact`模型——它使用`exclude`选项从表单中省略`user`模型字段。

因为您有意从模型表单中省略了`user`字段，最终用户将无法提供它——即使在不太可能的情况下，他也知道他的内部用户。因此，作为验证过程的一部分，有必要更新模型以包含内部用户，这在视图方法的`request`引用中总是可用的。

在清单 [9-8](#Par82) 中的第一个验证序列中，您可以看到在模型表单通过`is_valid()`方法后，会进行一个快速检查来确认用户是否通过了身份验证；如果是，则访问模型的`instance`引用来更新`user`模型字段。一旦完成，模型表单的支持实例包含一个被省略的`user`字段的值，并且在调用`save()`方法时，模型记录与它的所有模型字段的值一起被保存。

清单 [9-8](#Par82) 中的第二个验证序列使用`commit=False`来具体化模型表单的模型实例，而不将其保存到数据库中。一旦完成了这些，模型表单的工作也就完成了，这样就剩下一个需要更新并保存到数据库中的基本模型记录实例。您可以在清单 [9-8](#Par82) 中看到，进行了相同的检查来确认用户是否通过了身份验证，如果是，则更新未保存的模型记录`user`引用，并最终调用模型的`save()`方法将记录提交给数据库。

## Django 模型表单集

正如标准的 Django 表单可以作为一个集合组合在一起成为一个表单集一样，Django 模型表单也可以组合成一个模型表单集。类似地，正如 Django 模型表单类似于标准 Django 表单一样，模型表单集也与标准表单集有很多相似之处。

接下来，我将基于第 [6](06.html) 章最后一部分介绍的关于标准表单集的知识来描述模型表单集的特性。因此，如果您不熟悉表单集术语(例如，工厂和管理表单)，请回过头来阅读最后一节，因为下面的内容假设您已经了解这些基本的表单集概念。

### 模型表单集工厂

`modelformset_factory()`方法是使用模型表单集的核心。`modelformset_factory()`方法最多可以接受 19 个参数，其中 9 个与标准表单集相同，其余的特定于模型表单集。下面的代码片段展示了`modelormset_factory()`方法中每个参数的所有名称和默认值，粗体文本代表模型表单集特定选项。

```py
modelformset_factory(model, queryset=model.objects.all(),
                    form=ModelForm,fields=None, exclude=None,
                  formset=BaseModelFormSet, extra=1, can_order=False, can_delete=False,
                  max_num=None, min_num=None, validate_max=False, validate_min=False,
                  widgets=None, localized_fields=None,labels=None,
                  help_texts=None, error_messages=None,
                  field_classes=None,formfield_callback=None)

```

正如您可以在这个代码片段中确认的那样，`modelformset_factory()`方法唯一需要的参数(即没有默认值)是`model`。每个参数的含义如下:

`model`。-定义要在其上创建表单集的模型类。

`queryset`。-定义 queryset 以创建表单集。默认情况下，所有的模型记录都被用来创建表单集(即`model.objects.all()` queryset，如果使用的话)。

`fields`。-定义模型表单字段作为模型的一部分，以创建模型表单集–就像`fields`元模型表单选项一样。

`exclude`。-定义要作为模型的一部分省略的模型表单字段，以创建模型表单集-就像`exclude`元模型表单选项一样。

`widgets`。-为模型表单定义覆盖小部件以创建模型表单集——就像`widgets`元模型表单选项一样。

`localize_fields`。-定义要本地化的模型表单字段(即支持多种语言)以创建表单集–就像`localize_fields`元模型表单选项一样。

`labels`。-为模型表单定义覆盖标签以创建模型表单集–就像`labels`元模型表单选项一样。

`help_text`。-为模型表单定义覆盖帮助文本以创建模型表单集-就像`help_texts`元模型表单选项一样。

`error_messages`。-为模型表单定义覆盖错误消息，以创建模型表单集–就像`help_texts`元模型表单选项一样。

`field_classes`。-为模型表单定义覆盖字段类以创建模型表单集——就像`field_classes`元模型表单选项一样。

`formsetfield_callback`。-定义在从模型字段创建表单字段之前要执行的方法。通常用于在表单集的上下文中自定义模型表单字段，如前面的模型表单部分所述。

Tip

参见第 [6](06.html) 章了解额外模型表单集 _ 工厂选项的详细信息，该选项已在标准表单集章节中描述。

鉴于模型表单集逻辑是前面描述的模型表单技术和第 [6](06.html) 章中描述的表单集技术的结合，我不会再重复同样的技术。你可以查看这本书的源代码，在`online`应用程序下的第 [9 章](09.html)的源代码中找到一个工作模型表单集的例子。

## 带有模型的基于类的视图

回到第 [2](02.html) 章，您学习了基于类的视图如何允许您创建符合面向对象编程(OOP)原则(例如封装、多态和继承)的视图，从而提高可重用性并缩短实现时间。现在你已经知道 Django 模型是如何工作的，我们可以处理基于类的视图，这些视图与表 [2-10](02.html#Tab10) 的最后一部分描述的模型相集成。

不同于标准的 Django 视图(在第 2 章[的前几节中讨论过)允许开放式逻辑处理请求并生成响应，基于类的模型视图以更模块化的方式封装了针对 Django 模型执行的逻辑。](02.html)

例如，在标准视图方法中创建、读取、更新和删除模型实例的逻辑模式通常遵循非常一致的工作流:从 url 或表单中获取输入数据，对模型执行 CRUD 操作，然后将响应发送给模板。

本着 Django 的 DRY 原则，基于类的模型视图提供了一种减少标准视图方法中使用的样板代码的方法，并使用类字段和方法来定义用于 Django 模型 CRUD 操作的工作流。

### 使用基于类的视图 CreateView 创建模型记录

到目前为止，您已经了解到，在实际项目中创建 Django 模型实例伴随着一系列的构造，包括模型表单、GET/POST 请求处理、模板的使用等等。

Django `CreateView`基于类的视图是专门为减少创建模型记录所需的样板代码而设计的。清单 [9-9](#Par111) 展示了使用`CreateView`类的基于类的视图。

```py
# views.py
from django.views.generic.edit import CreateView
from .models import Item, ItemForm
from django.core.urlresolvers import reverse_lazy

class ItemCreation(CreateView):
    model = Item
    form_class = ItemForm
    success_url = reverse_lazy('items:index')

# models.py
from django import forms
from django.db import models

class Menu(models.Model):
    name = models.CharField(max_length=30)

class Item(models.Model):
    menu = models.ForeignKey(Menu, on_delete=models.CASCADE)
    name = models.CharField(max_length=30)
    description = models.CharField(max_length=100)

class ItemForm(forms.ModelForm):
    class Meta:
        model = Item
        fields = '__all__'
        widgets = {
            'description': forms.Textarea(),
        }

# urls.py
from django.conf.urls import url
from coffeehouse.items import views as items_views

urlpatterns = [
    url(r'^new/$', items_views.ItemCreation.as_view(), name='new'),
]

# templates/items/item_form.html
    <form method="post">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit" class="btn btn-primary">Create</button>
    </form>

Listing 9-9.Django class-based view with CreateView to create model records

```

清单 [9-9](#Par111) 的第一部分展示了基于`ItemCreation`类的视图，它从`CreateView`类继承了它的行为。注意这个视图缺少一个`request`引用、处理逻辑或者`return`语句，所有这些在第 [2](02.html) 章描述的标准视图方法中都很常见。那么`ItemCreation`基于阶级的观点实际上在做什么呢？

因为您预先知道您想要创建一个模型记录，所以由基于`ItemCreation`类的视图使用的`CreateView`类支持所有必要的样板文件逻辑，并且需要最少的代码集来实现它的模型记录创建逻辑。

清单 [9-9](#Par111) 中的`ItemCreation`基于类的视图使用`model`字段告诉 Django 创建`Item`模型记录。此外，`form_class`字段指定了`ItemForm`表单——也在清单 [9-9](#Par111) 中声明——用于创建模型记录。此外，当模型记录创建成功时，`success_url`字段用于将控制权返回给`item:index` url。

Why Reverse_Lazy in Class-Based Views, Instead of Reverse?

由于基于类的视图中模型、视图和 url 的同时导入顺序，使用标准的 reverse()方法来解析 URL 名称可能会导致错误:django . core . exceptions . improperly configured:包含的 URLconf '–-'中似乎没有任何模式。如果您在文件中看到有效的模式，那么问题可能是由循环导入引起的。

reverse_lazy 方法确保只有在所有模型、视图和 url 都被正确导入之后才尝试任何反向 URL 名称解析；因此，这是基于类的视图环境中的常见选择。

您可能仍然会疑惑，如果清单 [9-9](#Par111) 中的`ItemCreation`基于类的视图正在创建模型记录，那么它的`save()`和`is_valid()`方法在哪里？默认情况下没有。因为您只想创建一个模型记录，所以父类`CreateView`负责这个支持逻辑。

清单 [9-9](#Par111) 中的下一部分包含了带有钩子的`urly.py`文件，用于在应用程序中设置基于类的视图。在这种情况下，`ItemCreation`基于类的视图被设置为在`/new` url 上运行，并通过使用基于类的视图`as_view()`方法被声明为`url()`方法的一部分——注意，这种 url 设置技术对所有基于类的视图都是相同的，并在第 [2](02.html) 章末尾对无模型的基于类的视图进行了描述。

那么当用户访问`/new` url 时会发生什么呢？控制被发送到`ItemCreation`基于类的视图。因为这个视图的目的是创建一个`Item`模型记录，所以基于类的视图在遵循约定`<app_name>/<model_name>_form.html`的项目的`TEMPLATES`目录路径下寻找一个呈现表单的模板。

在清单 [9-9](#Par111) 的最后一部分，您可以看到模板`templates/items/item_form.html`，其中`templates`表示一个`TEMPLATES`目录路径值，`items`表示应用程序名称，`item`表示为基于类的视图定义的模型名称。此外，请注意`item_form.html`模板的内容使用了标准的表单布局，您可以像任何 Django 表单一样对其进行调整。

那么清单 [9-9](#Par111) 中的 POST 表单处理程序和错误处理在哪里呢？默认情况下，也没有。一旦用户得到清单 [9-9](#Par111) 底部所示的未绑定表单，表单处理和验证就由`ItemCreation`基于类的视图在幕后处理。如果表单包含错误，模板将被重新呈现——像任何其他表单一样——使用清单 [9-9](#Par111) 中的相同模板。如果表单数据有效，表单处理被认为是成功的，基于类的视图创建一个`Item`模型记录——类似于模型表单——将控制重定向到基于类的视图`success_url`字段中定义的`item:index` url。

正如您在这个例子中看到的，从`CreateView`类继承其行为的基于类的视图减少了创建模型记录所需的样板代码。

### 创建视图字段和方法

虽然乍一看，从`CreateView`类继承其行为的基于类的视图可能显得不灵活，但是可以像任何 Django 构造一样覆盖其默认行为。

事实证明，`CreateView`类从许多其他基于 Django 类的视图中继承了它的行为，这就是赋予了`CreateView`类及其实现子类(如清单 [9-9](#Par111) 中基于类的视图)幕后的力量。`CreateView`类从以下基于类的视图类继承其行为:

```py
django.views.generic.detail.SingleObjectTemplateResponseMixin
django.views.generic.base.TemplateResponseMixin
django.views.generic.edit.BaseCreateView
django.views.generic.edit.ModelFormMixin
django.views.generic.edit.FormMixin
django.views.generic.detail.SingleObjectMixin
django.views.generic.edit.ProcessFormView
django.views.generic.base.View

```

那么，为什么这些课程如此重要呢？因为它们为所有基于类的视图提供了默认行为。清单 [9-9](#Par111) 中的`ItemCreation`基于类的视图中声明的稀疏字段对于`CreateView`基于类的视图来说只有三个字段。可以声明十几个以上的字段和方法——属于这个过去的类列表——来提供行为，比如使用另一个模板而不是`<app_name>/<model_name>_form.html`；指定响应的内容类型(例如，`text/csv`)；模型表单有效或无效时运行的自定义方法；以及声明自定义方法来手动执行 GET 和 POST 工作流逻辑。

Note

基于类的视图从它的父类继承了许多字段和方法。以下选项是最常见的选项；要获得详尽的列表，请查阅每个`CreateView`父类。

#### 基本的 CreateView 选项:模型、form_class 和 success_url 字段

正如您已经在清单 [9-9](#Par111) 中看到的，基于`CreateView`类的视图实现的基本逻辑是使用一个表单创建一个模型记录，这反过来需要一组基本的参数。首先，`model`字段是整个操作的基础，因为基于`CreateView`类的视图必须预先知道要创建哪种类型的模型记录。其次，`form_` `class`也是一个基本参数，因为必须向用户提供一个表单来捕获数据以创建模型记录。

最后，因为成功地创建一个模型记录需要通知用户这个动作并离开表单页面，所以`success_url`字段也是一个基于`CreateView`类的视图的基本部分，用来指示在创建一个模型记录后将用户重定向到哪里。

#### 定制模板名称、MIME 类型和上下文:模板名称和内容类型字段以及 get_context_data()方法

有时依赖于`CreateView`基于类的视图模板命名约定`<app_name>/<model_name>_form.html`是不可行的，要么是因为您有一个预先存在的模板可以重用，要么是因为您不喜欢默认约定。您可以将`template_name`字段声明为基于`CreateView`类的视图的一部分来覆盖这个约定。类似地，也可以覆盖基于类的视图响应所使用的默认 MIME 类型——如果模板包含除了`text/html`(例如`text/csv`)之外的东西——使用`content_type`字段作为`CreateView`基于类的视图的一部分。

此外，您可以通过定义`get_context_data()`方法的实现来改变传递给基于类的视图模板的上下文数据。当你需要传递额外的数据到一个模板——除了`form`引用——或者改变实际的`form`引用到另一个名字时，最后一个过程是很常见的。

清单 [9-10](#Par133) 展示了一个基于`CreateView`类的视图，它利用了`template_name`和`content_type`字段，以及`get_context_data()`方法。

```py
# views.py
from django.views.generic.edit import CreateView
from .models import Item, ItemForm, Menu

class ItemCreation(CreateView):
    template_name = "items/item_form.html"

    context_type = "text/html"

    model = Item
    form_class = ItemForm
    success_url = reverse_lazy('items:index')
    def get_context_data(self,**kwargs):

        kwargs['special_context_variable'] = 'My special context variable!!!'

        context = super(ItemCreation, self).get_context_data(**kwargs)

        return context        

Listing 9-10.Django class-based view with CreateView with template_name, content_type

, and get_context_data()

```

您可以在清单 [9-10](#Par133) 中看到，`template_name`和`content_type`字段被声明为基于类的视图的一部分。在这种特殊情况下，为简单起见，两个字段值都被赋予默认值，使它们变得多余；但是您可以根据自己的需要进行相应的调整。

清单 [9-10](#Par133) 中的`get_context_data()`方法首先添加自定义`special_context_variable`键，使其可用于基于类的视图模板(即`items/item_form.html`)。接下来，调用父类的`get_context_data()`方法(即`CreateView`)来运行其上下文设置逻辑，包括设置模板中也使用的`form`引用。最后，`get_context_data()`方法返回带有所有模板上下文值的`context`引用，以便在模板内部使用。

正如您在清单 [9-10](#Par133) 中看到的，通过简单地在一个基于`CreateView`类的视图中添加字段和覆盖方法，您可以很容易地开始改变它的默认行为。

#### 自定义表单初始化和验证:Initial field、get_initial()、get_form()、form_valid()和 form_invalid()方法

基于`CreateView`类的视图上的`initial`字段就像标准表单的`initial`参数一样为未绑定表单指定默认值。例如，在基于`CreateView`类的视图上声明字段`initial = {'size':'L'}`会将其表单的`size`字段设置为`L`。

表单初始化有时可能需要比单行语句更复杂的需求，其中基于类的视图还提供了方法。`get_initial()`方法的功能类似于标准表单中使用的`__init__`方法——因为您可以引入开放式逻辑来设置默认值——但它的唯一目的是设置`initial`值并返回一个值字典——不像`__init__`方法，您可以引入除默认表单值之外的其他操作(例如，更改小部件、添加验证)。

清单 [9-11](#Par140) 展示了在基于`CreateView`的视图上使用`initial`参数和`get_initial()`方法。

```py
# views.py
from django.views.generic.edit import CreateView
from .models import Item, ItemForm, Menu

class ItemCreation(CreateView):
    initial = {'size':'L'}

    model = Item
    form_class = ItemForm
    success_url = reverse_lazy('items:index')
    def get_initial(self):

        initial_base = super(ItemCreation, self).get_initial()

        initial_base['menu'] = Menu.objects.get(id=1)

        return initial_base

Listing 9-11.Django class-based view with CreateView with initial and get_initial()

```

清单 [9-11](#Par140) 中的第一步是设置`initial`字段，将基于类的视图的表单`size`字段设置为`L`。接下来，声明`get_initial()`方法，为基于类的视图表单添加另一个默认值。

在`get_initial()`方法内部，第一步是调用父类的`get_initial()`方法(即`CreateView`)来运行它的初始设置逻辑；这确保了类别的`initial`字段值(即`{'size':'L'}`)被考虑为`initial`值的一部分。接下来，更新`initial_base`引用，将表单的`menu`字段设置为带有`id=1`的`Menu`记录。最后，清单 [9-11](#Par140) 中的`get_initial()`方法返回一个字典，其中包含由基于类的视图设置的`initial`字段值和在其主体中设置的自定义表单值。

基于`CreateView`类的视图的`get_form()`方法旨在利用表单的完整初始化过程，而不仅仅是像`initial`字段和`get_initial()`方法那样设置其默认值。这使得`get_form()`方法适合于执行更广泛的表单初始化任务，比如设置表单小部件和验证初始化，就像在标准表单的`__init__`方法中所做的那样。包含地，可以使用`get_form()`方法来指定默认的表单值，并且完全放弃使用`initial`和`get_initial()`。清单 [9-12](#Par144) 展示了在基于`CreateView`类的视图中`get_form()`方法的使用。

```py
# views.py
from django.views.generic.edit import CreateView
from .models import Item, ItemForm, Menu

class ItemCreation(CreateView):
    initial = {'size':'L'}

    model = Item
    form_class = ItemForm
    success_url = reverse_lazy('items:index')
    def get_form(self):

        form = super(ItemCreation, self).get_form()

        initial_base = self.get_initial()

        initial_base['menu'] = Menu.objects.get(id=1)

        form.initial = initial_base

        form.fields['name'].widget = forms.widgets.Textarea()

        return form

Listing 9-12.Django class-based view with CreateView with get_form()

```

清单 [9-12](#Par144) 中的`get_form()`方法的第一步是调用父类的`get_form()`方法(即`CreateView`)来获取基础表单。接下来，调用基于类的视图的`get_initial()`方法来获取其`initial`表单值，并使用模型查询为表单的`menu`字段设置默认值。在这种情况下，表单初始化表单字典的值与清单 [9-11](#Par140) 中的值相同。

接下来，使用标准的`initial`表单引用将表单初始化字典分配给基础表单。最后，在返回 form 类的实例之前，在表单的`name`字段上设置一个自定义小部件，覆盖表单`name`字段的默认小部件。

除了初始化任务，还可以定制基于类的视图的表单验证过程。`form_valid()`和`form_invalid()`方法分别用于访问基于类的视图表单被认为成功或错误的点。清单 [9-13](#Par148) 展示了一个在基于`CreateView`类的视图中使用`form_valid()`和`form_invalid()`方法的例子。

```py
# views.py
from django.views.generic.edit import CreateView
from django.http import HttpResponseRedirect
from django.contrib import messages
from .models import Item, ItemForm, Menu

class ItemCreation(CreateView):
    initial = {'size':'L'}
    model = Item
    form_class = ItemForm
    success_url = reverse_lazy('items:index')
    def form_valid(self,form):

        super(ItemCreation,self).form_valid(form)

        # Add action to valid form phase

        messages.success(self.request, 'Item created successfully!')

        return HttpResponseRedirect(self.get_success_url())

    def form_invalid(self,form):

        # Add action to invalid form phase

        return self.render_to_response(self.get_context_data(form=form))

Listing 9-13.Django class-based view with CreateView with form_valid() and form_invalid()

```

正如您在清单 [9-13](#Par148) 中看到的，`form_valid()`方法通过它的`form`输入参数获得对表单实例的访问，这反过来允许您在表单通过验证阶段时在表单上执行操作。在这种情况下，没有对表单本身采取任何操作来简化事情，但是添加了一个额外的逻辑来说明定制过程。

清单 [9-13](#Par148) 中`form_valid()`的第一步是调用父类的`form_valid()`方法(即`CreateView`)来运行其表单验证设置逻辑，这确保了基类的表单验证首先运行，以验证任何违反表单规则的情况(例如，向表单添加错误)。如果对父类的`form_valid()`方法的调用检测到了违反规则的情况，那么该类的`form_valid()`方法(即列出 [9-13](#Par148) 的方法)就会短路并退回到`form_invalid()`方法。如果父方法`form_valid()`通过，清单 [9-13](#Par148) 中的逻辑继续添加一个 Django 消息框架成功消息以呈现给用户。

Tip

还可以通过 mixin 将 Django 消息框架成功消息添加到基于类的视图表单验证过程中。本章的最后一节描述了基于类的视图的混合。

最后，因为您正在处理一个有效的表单工作流，清单 [9-13](#Par148) 中的`form_valid()`方法必须显式地将用户重定向到一个位置来完成它的工作。在这种情况下，标准 Django `HttpResponseRedirect`方法与基于类的视图的`get_success_url()`方法一起使用，最后一个方法获取基于类的视图`success_url`字段值。

清单 [9-13](#Par148) 中的`form_invalid()`方法并不特别处理无效表单。它只是通过基于类的视图方法完成最少量的工作，即将控制返回到同一个模板位置，并添加包含有错误的表单的上下文以呈现给用户。

正如您所看到的，基于`CreateView`类的视图中的`form_valid()`和`form_invalid()`方法的好处是它们允许您定制表单验证工作流，而不需要修改`CreateView`工作流的其他部分(例如，将表单数据保存到数据库)。

#### 自定义视图方法工作流:get()和 post()方法

除了前面对基于类的视图的定制选项之外，还可以使用`get()`或`post()`方法对基于类的视图完成的工作流进行绝对控制。`get()`方法用于接入与基于类的视图相关联的 HTTP GET 工作流，而`post()`方法用于接入与基于类的视图相关联的 HTTP POST 工作流。

虽然使用`get()`或`post()`方法可以为基于类的视图提供最大的灵活性，但是它们也需要显式声明基于类的视图的初始化、验证和重定向序列。这意味着使用`get()`或`post()`方法的基于类的视图可以更类似于标准的开放式 Django 视图——在第 [2](02.html) 章中描述——而不是之前在清单 [9-9](#Par111) 中呈现的简洁的基于类的视图。

尽管如此，有时基于类的视图的吸引力如此之大，使用`get()`或`post()`方法是有保证的。清单 [9-14](#Par158) 展示了一个在基于`CreateView`的视图中使用`get()`和`post()`方法的例子。

```py
# views.py
from django.views.generic.edit import CreateView
from django.shortcuts import render
from django.contrib import messages

class ItemCreation(CreateView):
    initial = {'size':'L'}
    model = Item
    form_class = ItemForm
    success_url = reverse_lazy('items:index')
    template_name = "items/item_form.html"
    def get(self,request, *args, **kwargs):

        form = super(ItemCreation, self).get_form()

        # Set initial values and custom widget

        initial_base = self.get_initial()

        initial_base['menu'] = Menu.objects.get(id=1)

        form.initial = initial_base

        form.fields['name'].widget = forms.widgets.Textarea()

        # return response using standard render() method

        return render(request,self.template_name,

                      {'form':form,

                       'special_context_variable':'My special context variable!!!'})

    def post(self,request,*args, **kwargs):

        form = self.get_form()

        # Verify form is valid

        if form.is_valid():

            # Call parent form_valid to create model record object

            super(ItemCreation,self).form_valid(form)

            # Add custom success message

            messages.success(request, 'Item created successfully!')    
            # Redirect to success page    
            return HttpResponseRedirect(self.get_success_url())

        # Form is invalid

        # Set object to None, since class-based view expects model record object

        self.object = None

        # Return class-based view form_invalid to generate form with errors

        return self.form_invalid(form)

Listing 9-14.Django class-based view with CreateView with get() and post()

```

您可以在清单 [9-14](#Par158) 中看到，`get()`和`post()`方法都可以访问一个`request`输入——一个`HttpRequest`实例——就像标准视图方法一样。这个`request`引用允许基于类的视图访问请求数据，例如 HTTP 元数据(例如，用户的 IP 地址)，这是在第 [2](02.html) 章中详细描述的主题。

清单 [9-14](#Par158) 中`get()`方法的第一步是使用父类的`get_form()`方法(即`CreateView`)创建一个未绑定表单。因为`get()`方法让您可以完全控制工作流，所以使用标准表单语法(例如`form = ItemForm()`)创建未绑定表单同样有效，但是因为它是基于类的视图，所以该示例利用了基于类的视图构造。一旦创建了未绑定表单，就会在表单上设置一系列初始值和一个自定义小部件，就像在前面基于类的视图示例中所做的那样。

一旦未绑定表单准备好了，注意到`get()`方法的`return`语句使用了常规视图方法中使用的标准`render()`方法。在这种情况下，`render()`方法将控制重定向到基于类的视图模板，并用未绑定的`form`和一个额外的`special_context_variable`变量设置模板上下文，以便在模板中使用。

接下来，清单 [9-14](#Par158) 中的`post()`方法负责处理包含用户数据的表单。`post()`方法的第一步是使用基于类的视图`get_form()`类获得一个绑定表单实例。类似于`get()`方法，使用标准表单语法(如`form = ItemForm(request.POST)`)创建绑定表单同样有效。

对于绑定的表单实例，将进行检查以验证用户提供的表单数据是否有效，就像对标准表单(例如，`form.is_valid()`)所做的那样。如果表单数据有效，则调用父类的`is_valid()`方法(即`CreateView`)，确保在表单有效时执行基于类的视图的核心逻辑(例如将表单数据保存到数据库)。这里可以再次使用任何标准的模型构造，但是调用父类的`is_valid()`方法更容易执行这个例程逻辑来创建一个模型对象记录。一旦例程验证逻辑完成，就会添加一条成功消息呈现给最终用户，并重定向到基于类的视图的成功 url。如果表单数据无效，基于类的视图的对象字段被设置为`None`——因为基于类的视图期望在后期处理中处理一个对象记录实例——并且使用负责底层细节的基于类的`form_invalid()`方法返回控制，而不是使用`render()`方法创建标准的视图方法响应。

正如您现在从清单 [9-14](#Par158) 中的例子所理解的，基于`CreateView`类的视图可以像标准视图方法一样灵活。这只是了解和理解基于类的视图所支持的不同字段和方法的问题。当然，如果你觉得基于`CreateView`类的视图的定制逻辑变得过于笨拙，你可以随时回到第 [2](02.html) 章中介绍的标准视图方法。

### 使用基于类的视图 ListView 和 DetailView 读取模型记录

与创建模型记录的过程类似，读取模型记录的过程也遵循一个对所有模型几乎相同的过程:创建一个查询来获取模型记录，然后使用一个模板来显示模型记录。Django `ListView`和`DetailView`基于类的视图是专门为减少分别显示 Django 模型记录列表和单个 Django 模型记录所需的样板代码而设计的。

`ListView`基于类的视图可以快速建立一个模型记录列表的查询，并在模板中显示它们。清单 [9-15](#Par167) 展示了一个基于类的视图，它使用了`ListView`基于类的视图。

```py
# views.py
from django.views.generic.list import ListView
from .models import Item

class ItemList(ListView):
    model = Item

# urls.py
from django.conf.urls import url
from coffeehouse.items import views as items_views

urlpatterns = [
    url(r'^$',items_views.ItemList.as_view(),name="index"),
]

# templates/items/item_list.html
  {% regroup object_list by menu as item_menu_list %}
  {% for menu_section in item_menu_list %}
   <li>{{ menu_section.grouper }}
    <ul>
        {% for item in menu_section.list %}
        <li>{{item.name|title}}</li>    
        {% endfor %}
    </ul>
    </li>
{% endfor %}

Listing 9-15.Django class-based view with ListView to read list of records

```

清单 [9-15](#Par167) 中的第一个定义是`ItemList`类，它继承了基于`ListView`类的视图类的行为。设置为`Item`的`ItemList`类中的`model`字段告诉 Django 生成所有`Item`模型记录的列表(例如`Item.objects.all()`)。

接下来，使用`as_view()`方法将`ListView`基于类的视图连接到一个根 url 正则表达式–`r'^$'`,最后一个方法可用于所有基于类的视图，并且在上一节中也用于设置一个`CreateView`基于类的视图。

最后，清单 [9-15](#Par167) 的最后一部分展示了在`object_list`引用上生成循环的模板`item_list.html`，最后一个是默认的上下文变量，由包含模型记录列表的`ListView`基于类的视图使用。

概括一下，`ListView`基于类的视图最重要的默认行为如下:

记录列表由`model`选项中定义的模型的所有记录组成。

呈现记录列表的模板使用项目的`TEMPLATES`目录路径下的约定`<app_name>/<model_name>_list.html`。

传递给模板(即包含记录的模板)的上下文变量被命名为`object_list`。

正如您在这个例子中看到的，一个基于`ListView`类的视图减少了向一个字段显示模型记录列表所需的样板代码。

`DetailView`基于类的视图是另一个记录读取构造，旨在快速建立单个记录查询并在模板中呈现结果。清单 [9-16](#Par177) 展示了使用`DetailView`类的基于类的视图。

```py
# views.py
from django.views.generic. import DetailView
from .models import Item

class ItemDetail(DetailView):
    model = Item

# urls.py
from django.conf.urls import url
from coffeehouse.items import views as items_views

urlpatterns = [
    url(r'^(?P<pk>\d+)/$',items_views.ItemDetail.as_view(),name="detail"),
]

# templates/items/item_detail.html
<h4> {{item.name|title}}</h4>
<p>{{item.description}}</p>
<p>${{item.price}}</p>
<p>For {{item.get_size_display}} size: Only {{item.calories}} calories
{% if item.drink %}
and {{item.drink.caffeine}} mg of caffeine.</p>
{% endif %}
</p>

Listing 9-16.Django class-based view with DetailView to read model record

```

清单 [9-16](#Par177) 中的第一个定义是`ItemDetail`类，它继承了基于`DetailView`类的视图类的行为。`ItemDetail`类中的`model`字段指向`Item`，它告诉 Django 获取一个`Item`模型记录。与清单 [9-15](#Par167) 中读取所有模型记录的`ListView`基于类的视图类不同，`DetailView`基于类的视图类必须总是将其模型查询限制在单个记录中，这就是基于类的视图 url 定义发挥作用的地方。

清单 [9-16](#Par177) 中的`DetailView`基于类的视图被挂接到一个根 url 正则表达式——`r'^$'`——使用`as_view()`方法——就像其他基于类的视图一样——但是请注意 url 定义包含了`(?P<pk>\d+)` url 参数，该参数被传递给基于类的视图以将模型查询限定为一条记录。

例如，如果在 url `/items/1/`上发出一个请求，`1`被分配给`pk`参数，该参数被传递给基于类的视图，以构建模型查询`Item.objects.get(pk=1)`，该模型查询通过`pk=1`获得`Item`模型记录——注意`pk`字段代表主键，通常相当于`id`字段。

以这种方式，当在`DetailView`基于类的视图上作出的 url 请求改变时(例如`/items/2/`、`/items/3/`)，对模型 a 记录作出的后备查询也改变，并且记录返回以显示在模板中。

最后，清单 [9-16](#Par177) 的最后一部分展示了模板`item_detail.html`，它输出代表模型记录的`item`引用的各个字段。在这种情况下，使用`item`引用是因为`DetailView`基于类的视图为模型记录使用的默认上下文变量是模型本身的名称。

概括一下，`DetailView`基于类的视图最重要的默认行为如下:

模型记录是基于`model`选项和 url `pk`参数确定的，该参数根据模型的主键将查询限定为单个记录。

呈现记录的模板使用项目的`TEMPLATES`目录路径下的约定`<app_name>/<model_name>_detail.html`。

传递给模板(即包含记录的模板)的上下文变量以基于类的视图的`model`命名(例如，如果`model=Item`，则上下文变量命名为`item`)。

正如您在这个例子中看到的，从`DetailView`类继承其行为的基于类的视图减少了呈现单个模型记录所需的样板代码。

### ListView 字段和方法

类似于前面介绍的`CreateView`基于类的视图，可以覆盖`ListView`基于类的视图的许多默认行为。

事实证明，`ListView`基于类的视图继承了许多其他 Django 基于类的视图的行为，如下所示:

```py
django.views.generic.list.MultipleObjectTemplateResponseMixin
django.views.generic.base.TemplateResponseMixin
django.views.generic.list.BaseListView
django.views.generic.list.MultipleObjectMixin
django.views.generic.base.View

```

Note

基于类的视图从它的父类继承了许多字段和方法。以下选项是最常见的选项；要获得详尽的列表，请查阅每个`ListView`父类。

#### 基本 ListView 选项:模型字段

正如您在清单 [9-15](#Par167) 中看到的，基于`ListView`类的视图实现的基本逻辑是从一个模型中创建一个记录列表。因此,`model`字段选项对于指示在哪个模型上创建记录列表至关重要。

接下来的部分描述了如何定制一个基于`ListView`类的视图，包括如何为一个记录列表定界和生成多个页面，以及如何覆盖其他默认行为。

#### 自定义模板上下文引用名称:上下文对象名称

在清单 [9-15](#Par167) 中，您可以看到`ListView`基于类的视图的模板使用了不太友好的上下文变量`object_list`。这是默认行为，但是为了帮助模板编辑器，可以使用不同的上下文变量来包含记录列表。

`context_object_name`字段用于定义一个定制的上下文变量名，以操作模板内的记录列表(如`context_object_name = 'item_list'`)。

Tip

基于`ListView`类的视图也从许多与前面描述的`CreateView`类相同的类中继承它的行为。因此，你也可以使用`template_name`字段来指定一个自定义模板名；用于指定 MIME 类型的`content_type`字段；和`get_context_data()`方法来改变模板使用的上下文。

#### 自定义记录列表:查询集和排序字段以及分页行为

默认情况下，一个基于`ListView`类的视图为属于一个模型的所有记录生成一个列表。虽然这种行为是合理的，但也有必要创建一个基于`ListView`类的视图来返回更有限的标准，在这种情况下，有必要对支持模型查询进行定界。`queryset`字段用于定义一个定制查询来生成一个记录列表。

自定义记录列表的另一个有用选项是指定生成记录列表的字段顺序。类似于模型查询中使用的标准`order_by()`方法，基于`ListView`类的视图可以指定`ordering`字段来定义记录列表的排序顺序。

清单 [9-17](#Par200) 展示了在基于`ListView`类的视图中`queryset`和`ordering`字段的使用。

```py
# views.py
from django.views.generic.list import ListView
from .models import Item

class ItemList(ListView):
    model = Item
    queryset = Item.objects.filter(menu__id=1)

    ordering = ['name']

Listing 9-17.Django class-based view with ListView to reduce record list with queryset

```

正如您在清单 [9-17](#Par200) 中看到的那样，`queryset`字段被分配了一个标准模型查询来生成带有`menu id=1`的`Item`记录。通过这种方式，由`ListView`基于类的视图传递给模板的结果记录列表只包含符合这些标准的`Item`记录。此外，清单 [9-17](#Par200) 还利用了`ordering = ['name']`字段，在这种情况下，它确保生成记录列表的查询按照`Item`模型的`name`字段排序。

虽然`queryset`选项有助于限定基于`ListView`类的视图所显示的记录列表的大小，但有时有必要处理一个大的记录列表，并且仍然能够限定模板中显示的结果数量。对于这种情况，您可以使用分页将大型记录列表拆分到多个页面上。

由于根据定义分页依赖于多个页面的使用，这迫使您不仅要调整基于类的视图定义，还要调整基于类的视图使用的 url 结构和模板以支持多个页面。清单 [9-18](#Par204) 展示了一个基于`ListView`类的视图的分页示例，它基于清单 [9-15](#Par167) 中的示例。

```py
# views.py
from django.views.generic.list import ListView
from .models import Item

class ItemList(ListView):
    model = Item
    paginate_by = 5

# urls.py
from django.conf.urls import url
from coffeehouse.items import views as items_views

urlpatterns = [
    url(r'^$',items_views.ItemList.as_view(),name="index"),
    url(r'^page/(?P<page>\d+)/$',items_views.ItemList.as_view(),name="page"),

]

# templates/items/item_list.html
  {% regroup object_list by menu as item_menu_list %}
{% for menu_section in item_menu_list %}
   <li>{{ menu_section.grouper }}
    <ul>
        {% for item in menu_section.list %}
        <li>{{item.name|title}}</li>    
        {% endfor %}
    </ul>
    </li>
{% endfor %}

{% if is_paginated %}

    {{page_obj}}

{% endif %}

Listing 9-18.Django class-based view with ListView to read list of records with pagination

```

清单 [9-18](#Par204) 中的相关分页逻辑以粗体显示。首先，`paginate_by = 5`被添加到基于类的视图定义中，它告诉 Django 将记录列表限制为每页 5 条记录。由于`ListView`基于类的视图将需要页码来显示查询的前 5 条记录之外的记录——因为页面被限制为 5 个——获取页码的自然位置是通过 url(例如，`/page/1/`创建查询的前 5 条记录的列表，`/page/2/`创建记录 6 到 10 的列表，等等)。).

接下来在清单 [9-18](#Par204) 中，您可以看到一个新的 url 定义，其中的`(?P<page>\d+)`参数连接到了`ListView`基于类的视图。这个 url 定义允许一个匹配正则表达式模式(例如，`/page/1/,/page/2/)`的请求将 url `page`参数值传递给基于类的视图。当基于`ListView`类的视图检测到存在`paginate_by`选项的 url `page`参数值时，它调整对记录列表的查询，以基于页面将适当的记录集返回给模板(例如，`/page/1/`生成整个查询的 1 到 5 的记录列表，`/page/2/`生成整个查询的 6 到 10 的记录列表，等等)。`).`

最后，清单 [9-18](#Par204) 中的最后一部分代表了使用分页的`ListView`基于类的视图的支持模板。`{% is_paginated %}`标签和`{{page_obj}}`上下文引用用于让用户知道他们在整个记录列表的哪一页。

Tip

一个`ListView`基于类的视图也可以使用`get()`基于类的视图方法来获得对视图工作流的完全控制。参见上一节关于`CreateView`基于类的视图，它描述了如何使用它及其含义。

### 详细视图字段和方法

像其他基于类的视图一样，`DetailView`基于类的视图也可以用定制字段和方法来创建，以覆盖它们的默认行为。

事实证明，`DetailView`类从许多其他基于 Django 类的视图中继承了它的行为，这些视图在下面的列表中描述:

```py
django.views.generic.detail.SingleObjectTemplateResponseMixin
django.views.generic.base.TemplateResponseMixin
django.views.generic.detail.BaseDetailView
django.views.generic.detail.SingleObjectMixin
django.views.generic.base.View

```

Note

基于类的视图从它的父类继承了许多字段和方法。以下选项是最常见的选项；要获得详尽的列表，请查阅每个`DetailView`父类。

#### 基本详细信息视图选项:带 pk 参数的模型字段和 url

正如您在清单 [9-16](#Par177) 中看到的，基于`DetailView`类的视图实现的基本逻辑是获取一个模型记录并在模板中显示它。因此,`model`字段是这种基于类的视图的重要部分之一，必须始终提供。

为了获得一个特定的模型记录，一个基于类的视图还必须定义一个 url 参数来帮助它选择一个模型记录。默认情况下，这个 url 参数必须被命名为`pk`，它的值用于使用`pk`字段对`model`值执行查询，这个字段通常相当于模型的`id`字段。

Tip

一个基于类的视图也从前面描述的许多基于类的视图类中继承了它的行为。因此，您也可以使用`template_name`字段来指定一个自定义模板名称；用于指定 MIME 类型的`content_type`字段；改变模板使用的上下文的`get_context_data()`方法；以及`context_object_name`字段来声明不同的上下文变量以访问模板中的记录。

#### 自定义 url 和查询参数:pk_url_kwarg，slug_field 和 slug_url_kwarg

默认情况下，`DetailView`基于类的视图期望一个名为`pk`的 url 参数来决定通过主键查询哪个模型记录。然而，如果你已经有了一个预先存在的 url 或者只是不喜欢这个不明确的 url 参数名，你可以用`pk_url_kwarg`字段指定一个自定义的 url 参数。

例如，在基于`DetailView`类的视图上设置`pk_url_kwarg='item_id'`，允许将 url 定义为`url(r'^(?P<item_id>\d+)/$',items_views.ItemDetail.as_view())`而不是默认的`url(r'^(?P<pk>\d+)/$',items_views.ItemDetail.as_view())`。

尽管使用`pk`字段执行基于`DetailView`类的视图的记录查询是一种常见的做法——考虑到`pk`字段通常是一个带有数据库索引的整数字段，以提高查找性能——有时可能有必要使用另一个模型字段执行基于`DetailView`类的记录查询(例如，创建更多用户/SEO 友好的 URL，如`/item/capuccino/`，而不是`/item/1/`)。

清单 [9-19](#Par220) 展示了一个基于`DetailView`类的视图，它使用`slug_field`选项来允许对模型字段而不是`pk`进行模型记录查询。

```py
# views.py
# views.py
from django.views.generic import DetailView
from .models import Item

class ItemDetail(DetailView):
    model = Item
    slug_field = 'name__iexact'

# urls.py
from django.conf.urls import url
from coffeehouse.items import views as items_views

urlpatterns = [
    url(r'^(?P<slug>\w+)/$',items_views.ItemDetail.as_view(),name="detail"),
]

# Template identical to listing to template in Listing 9-16

Listing 9-19.Django class-based view with DetailView and slug_field option

```

清单 [9-19](#Par220) 中的第一个重要方面是，url 定义有一个名为`slug`的 url 参数，由于使用了`w+`正则表达式，它可以匹配任何单词模式。这意味着像`/items/espresso/`和`/items/latte/`这样的 url 匹配这个 url，不像以前的`DetailView`基于类的 URL 定义使用`pk`参数来匹配数值和`d+`正则表达式。

当一个`DetailView`基于类的视图接收到一个名为`slug`的 url 参数时，它会通知基于类的视图，模型记录查询应该在一个模型字段而不是`pk`上进行。因为这个`slug`值可能是不明确的(例如，它可以表示几个模型字段值中的一个，如名称、成本或描述)，所以有必要限定`slug`值表示哪个模型字段，这就是`slug_field`字段的目的。

在清单 [9-19](#Par220) 的情况下，`slug_field`字段被设置为`name__iexact`，这告诉`DetailView`基于类的视图使用`Item`模型`name`字段上的`slug`值执行不区分大小写的模型查询。不区分大小写的查询由`__iexact`查找提供，在数据库记录值大小写混合的情况下很重要(例如，url `/items/capuccino/`将匹配`Item`名称记录`capuccino`、`Capuccino,`或`CAPUCCINO`)。如果没有大小写发明，`Item`名称记录将需要精确地`capuccino`来匹配 url)。

尽管清单 [9-19](#Par220) 中的示例中没有提供，基于`DetailView`类的视图的另一个可用选项是`slug_url_kwarg`选项，它与前面描述的`pk_url_kwarg`选项类似。

默认情况下，使用 slug 查询(即非`pk`查询)的基于`DetailView`类的视图期望一个名为`slug`的 url 参数来确定对哪个模型字段进行查询以获得记录。但是，如果您已经有一个预先存在的 url 或者只是不喜欢这个不明确的 url 参数名称，您可以使用`slug_url_` `kwarg`字段指定一个自定义的 url 参数。

例如，在基于`DetailView`类的视图上设置`slug_url_kwarg='item_name'`，允许将 url 定义为`url(r'^(?P<item_name>\w+)/$',items_views.ItemDetail.as_view())`而不是默认的`url(r'^(?P<slug>\w+)/$',items_views.ItemDetail.as_view())`。

Tip

一个`DetailView`基于类的视图也可以使用`get()`基于类的视图方法来获得对视图工作流的完全控制。参见上一节关于`CreateView`基于类的视图，描述了如何使用它及其含义。

### 用基于类的视图更新模型记录

当您更新 Django 模型记录时，典型的过程包括从数据库中获取想要更新的模型记录，在表单中显示模型数据以便用户可以进行更改，最后将更改保存回数据库。基于 Django `UpdateView`类的视图是专门为减少更新 Django 模型记录所需的样板代码而设计的。

由于其功能性，`UpdateView`基于类的视图的操作类似于通过表单创建模型记录的`CreateView`和显示模型记录的`DetailView`的组合。清单 [9-20](#Par240) 展示了一个`UpdateView`基于类的视图的例子。

```py
# views.py
from django.views.generic import UpdateView
from .models import Item

class ItemUpdate(UpdateView):
    model = Item
    form_class = ItemForm
    success_url = reverse_lazy('items:index')

# urls.py
from django.conf.urls import url
from coffeehouse.items import views as items_views

urlpatterns = [
     url(r'^edit/(?P<pk>\d+)/$', items_views.ItemUpdate.as_view(), name='edit'),
]

# templates/items/item_form.html
<form method="post">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit" class="btn btn-primary">
          {% if object == None%}Create{% else %}Update{% endif %}
        </button>
</form>

Listing 9-20.Django class-based view with UpdateView to edit a record

```

清单 [9-20](#Par240) 中的第一个定义是从基于`UpdateView`类的视图类继承其行为的`ItemUpdate`类。`ItemUpate`类中的`model`字段为`Item`设置一个值，它告诉 Django 更新`Item`模型记录。此外，因为您正在处理一个更新操作，`Item`模型记录必须以一种形式呈现——这是`from_class`选项的目的——以及定义一个成功的 url 来在更新成功时重定向用户，这是`success_url`选项的目的。

清单 [9-20](#Par240) 中的下一个是链接到`UpdateView`基于类的视图类的 url 定义。因为基于`UpdateView`类的视图必须提供一个特定的模型记录来编辑，所以它依赖于一个 url 参数来限制对单个记录的查询。在这种情况下，注意 url 包含传递给基于类的视图的`pk` url 参数——就像用`DetailView`基于类的视图一样。

例如，如果请求 url `/items/edit/1/`，`1`作为`pk`参数被传递给`UpdateView`基于类的视图，该视图又执行查询`Item.objects.get(pk=1)`来检索记录，并以表格的形式呈现出来以供编辑。

最后，清单 [9-20](#Par240) 中的最后一部分展示了模板`item_form.html`，它显示了要编辑的表单中的记录。默认的`UpdateView`基于类的视图模板的一个重要方面是它与`CreateView`基于类的视图使用的默认模板相同。这是因为两个基于类的视图共享该功能的相同的基于类的父视图类，更不用说表单的目的是相同的(例如，`CreateView`基于类的视图中的表单是空的，供用户填写新的记录数据，而`UpdateView`基于类的视图中的表单是用预填充的记录发送的，以更新记录数据)。

出于这个原因，清单 [9-20](#Par240) 中的模板与清单 [9-9](#Par111) 中用于基于`CreateView`类的视图的模板几乎相同。微小的区别是，如果模板在其上下文中检测到`object`变量的存在，这意味着`UpdateView`基于类的视图正在传递一个记录进行编辑，并且表单按钮被设置为`Update`；否则，如果没有出现`object`变量，这意味着`CreateView`基于类的视图正在调用模板，表单按钮被设置为`Create`。

概括一下，`UpdateView`基于类的视图最重要的默认行为:

要更新的模型记录是根据`model`选项和 url `pk`参数确定的，该参数根据模型的主键将查询限定为单个记录。

呈现表单以更新记录的模板使用项目的`TEMPLATES`目录路径下的约定`<app_name>/<model_name>_form.html`,注意它与`CreateView`基于类的视图使用的默认模板相同，对于这种情况，您可以依靠`object`上下文变量的存在来确定是否是`UpdateView`调用了模板。

传递给模板(即包含记录的模板)的上下文变量被命名为`object`，尽管表单会自动填充这个记录值。

正如您在这个例子中看到的，从`UpdateView`类继承其行为的基于类的视图减少了编辑模型记录所需的样板代码。

### 更新视图字段和方法

像其他基于类的视图一样，`UpdateView`基于类的视图也可以用定制字段和方法来创建，以覆盖它们的默认行为。

事实证明，`UpdateView`类继承了许多其他基于 Django 类的视图的行为，如下所示:

```py
django.views.generic.detail.SingleObjectTemplateResponseMixin
django.views.generic.base.TemplateResponseMixin
django.views.generic.edit.BaseUpdateView
django.views.generic.edit.ModelFormMixin
django.views.generic.edit.FormMixin
django.views.generic.detail.SingleObjectMixin
django.views.generic.edit.ProcessFormView
django.views.generic.base.View

```

Note

基于类的视图从它的父类继承了许多字段和方法。以下选项是最常见的选项；要获得详尽的列表，请查阅每个`UpdateView`父类。

#### 基本更新视图选项:模型、form_class 和 success_url 字段，以及带有 pk 参数的 url

正如您在清单 [9-20](#Par240) 中看到的，基于`UpdateView`类的视图实现的基本逻辑是获取一个模型记录，并以一种形式显示出来以供编辑。因此,`model`字段是这种基于类的视图的重要部分之一，必须始终提供。此外，因为记录是通过表单更新的，所以还需要通过`form_class`选项指定一个表单，以及当更新成功时通过`success_url`选项指定一个成功 url。

为了获得一个特定的模型记录，一个基于`UpdateView`类的视图还必须定义一个 url 参数来帮助它选择一个模型记录进行编辑。默认情况下，这个 url 参数必须被命名为`pk`，它的值用于使用`pk`字段对`model`值执行查询，这个字段通常相当于模型的`id`字段。

Tip

一个基于类的视图也从前面描述的许多基于类的视图类中继承了它的行为。因此，您也可以使用`template_name`字段来指定一个自定义模板名称；用于指定 MIME 类型的`content_type`字段；改变模板使用的上下文的`get_context_data()`方法；以及`context_object_name`字段来声明不同的上下文变量以访问模板中的记录。

此外，因为一个基于`UpdateView`类的视图需要获得一个模型记录，所以它也可以使用`pk_url_kwarg`字段来接受一个不同于`pk`的 url 参数；`slug_field`字段指定一个备选记录查询字段；和`slug_url_kwarg`字段来接受不同于`slug`命名的不同 url 参数。

最后，`UpdateView`基于类的视图也可以使用`get()`和`post()`基于类的视图方法来获得对视图工作流的完全控制。前面的基于类的视图部分描述了如何使用所有这些基于类的视图字段和方法。

### 使用基于类别的视图删除视图删除记录

当您删除 Django 模型记录时，除了执行实际的删除操作之外，向用户显示一个确认页面通常是一个很好的实践。Django `DeleteView`基于类的视图是专门为减少删除模型记录所需的样板代码量而设计的，同时显示一个确认页面。清单 [9-21](#Par251) 展示了一个`DeleteView`基于类的视图示例。

```py
# views.py
from django.views.generic.edit import DeleteView
from .models import Item

class ItemDelete(UpdateView):
    model = Item
    success_url = reverse_lazy('items:index')

# urls.py
from django.conf.urls import url
from coffeehouse.items import views as items_views

urlpatterns = [
    url(r'^delete/(?P<pk>\d+)/$', items_views.ItemDelete.as_view(), name='delete'),  
]

# templates/items/item_confirm_delete.html
  <form method="post">
        {% csrf_token %}
        Do you really want to delete "{{ object }}"?
        <button class="btn btn-primary" type="submit">Yes, remove it!</button>
  </form>

Listing 9-21.Django class-based view with DeleteView to delete record

```

清单 [9-21](#Par251) 中的第一个定义是`ItemDelete`类，它继承了基于`DeleteView`类的视图类的行为。`ItemDelete`类中的`model`字段为`Item`设置一个值，它告诉 Django 删除`Item`模型记录。此外，因为您希望用户确认删除操作，所以还必须声明`success_url`选项，以指定删除操作成功后将用户带到哪里。

清单 [9-21](#Par251) 中的下一个是链接到`DeleteView`基于类的视图类的 url 定义。因为基于类的视图必须被告知删除哪个模型记录，所以它依赖 url 参数来提供这个查询分隔符。在这种情况下，注意 url 包含传递给基于类的视图的`pk` url 参数——就像用`DetailView`基于类的视图一样。

例如，如果请求 url `/items/delete/1/`，`1`作为`pk`参数被传递给`DeleteView`基于类的视图，后者接着执行查询`Item.objects.get(pk=1)`来准备删除记录。

最后，清单 [9-21](#Par251) 的最后一部分展示了用于面向用户的删除序列的`item_confirm_delete.html`模板。注意，这个模板包含一个伪表单(即没有表单字段),带有一个问题和提交按钮。这种伪表单的原因是`item_confirm_delete.html`模板具有双重功能。

如果在一个基于`DeleteView`类的视图上发出一个 HTTP GET 请求，那么一个带有这个伪表单的页面将返回给用户，向他提出问题`Do you really want to delete "{{ object }}"?`，其中`object`是要删除的模型记录。如果用户点击这个伪表单提交按钮，它会向同一个基于`DeleteView`类的视图发出一个 HTTP POST 请求——注意`<form method="post">`标记——调用实际的删除过程。以这种方式，这种具有伪形式的模板允许用户在点击 url 删除链接(例如`/items/delete/1/`)之后确认他是否真的想要删除记录，而不是在点击 url 删除链接时立即删除记录。

概括一下，`DeleteView`基于类的视图最重要的默认行为如下:

要删除的模型记录是根据`model`选项和 url `pk`参数确定的，该参数根据模型的主键将查询限定为单个记录。

呈现表单以更新记录的模板使用项目的`TEMPLATES`目录路径下的约定`<app_name>/<model_name>_confirm_delete.html`。

传递给模板(即包含要删除的记录的模板)的上下文变量被命名为`object`。

对基于`DeleteView`类的视图的 HTTP GET 请求显示来自`<app_name>/<model_name>_confirm_delete.html`模板的确认页面。基于`DeleteView`类的视图上的 HTTP POST 请求执行实际的删除过程。

正如您在这个例子中看到的，从`DeleteView`类继承其行为的基于类的视图减少了删除模型记录所需的样板代码。

### 删除视图字段和方法

像其他基于类的视图一样，`DeleteView`基于类的视图也可以用定制字段和方法来创建，以覆盖它们的默认行为。

事实证明，`DeleteView`类继承了许多其他基于 Django 类的视图的行为，如下所示:

```py
django.views.generic.detail.SingleObjectTemplateResponseMixin
django.views.generic.base.TemplateResponseMixin
django.views.generic.edit.BaseDeleteView
django.views.generic.edit.DeletionMixin
django.views.generic.detail.BaseDetailView
django.views.generic.detail.SingleObjectMixin
django.views.generic.base.View

```

Note

基于类的视图从它的父类继承了许多字段和方法。以下选项是最常见的选项；要获得详尽的列表，请查阅每个`DeleteView`父类。

#### 基本删除视图选项:模型和 success_url 字段以及带有 pk 参数的 url

正如您在清单 [9-21](#Par251) 中看到的，基于`DeleteView`类的视图实现的基本逻辑是获取一个模型记录，并在显示确认页面时删除它。因此,`model`字段是这种基于类的视图的重要部分之一，必须始终提供。此外，因为记录被设置为删除，所以还需要通过`success_url`选项指定一个成功的 url，以便在记录被删除后重定向用户。

为了获得一个特定的模型记录，一个基于类的视图还必须定义一个 url 参数来帮助它选择一个要删除的模型记录。默认情况下，这个 url 参数必须被命名为`pk`，它的值用于使用`pk`字段对`model`值执行查询，这个字段通常相当于模型的`id`字段。

Tip

一个基于类的视图也从前面描述的许多基于类的视图类中继承了它的行为。因此，您也可以使用`template_name`字段来指定一个自定义模板名称；用于指定 MIME 类型的`content_type`字段；改变模板使用的上下文的`get_context_data()`方法；以及`context_object_name`字段来声明不同的上下文变量以访问模板中的记录。

此外，因为一个基于`DeleteView`类的视图需要获得一个模型记录，所以它也可以使用`pk_url_kwarg`字段来接受一个不同于`pk`的 url 参数；`slug_field`字段指定一个备选记录查询字段；和`slug_url_kwarg`字段来接受不同于`slug`命名的不同 url 参数。

最后，`DeleteView`基于类的视图也可以使用`get()`和 post()基于类的视图方法来获得对视图工作流的完全控制。前面的基于类的视图部分描述了如何使用所有这些基于类的视图字段和方法。

### 带有混合的基于类的视图

尽管所有操作模型的基于类的视图通常遵循相同的工作流程来创建、读取、更新和删除模型记录，但是公平地说，在看到前面的基于类的视图部分之后，您会发现自己经常调整基于类的视图的默认行为。

虽然多次调整基于类的视图的方法和字段是完全合理的，但是如果您需要一次又一次地在几十个或几百个基于类的视图中获得相同的功能，这可能会令人厌烦。

当您被迫在基于类的视图中定义一个`get()`或`post()`方法，以包含一些在基于类的视图中不支持的功能(例如，`CreateView`、`ListView`、`DetailView`、`UpdateView`、`DeleteView`)时，这一点尤为明显，这需要输入一个冗长的工作流，如果重复多次，结果可能会是重复的。为了减少基于类的视图上下文中的重复定制，可以使用 mixins。

首先，您已经在基于类的视图环境中使用了 mixins，即使您没有意识到这一点。如果您仔细观察为前面章节中描述的基于类的模型视图提供行为的基于类的视图类，您可能会注意到许多视图类的名称中都包含术语 mixin(例如，`ModelFormMixin`、`FormMixin`、`SingleObjectMixin`)。

软件 mixin 是一个允许类之间的类继承行为的构造，特别强调类继承。当您使用类继承时，父子类关系通常用“是一个”术语来描述(例如，如果饮料类从项目类继承其行为，则饮料是一个项目)。另一方面，mixin 类允许一个类采用 mixin 类的行为，而没有“是 a”行为。

换句话说，mixin 类是向类添加功能的一种方式，mixin 类充当可重用的组件。例如，您可以拥有一个由 Store 类和 OnlineStore 类使用的 mixin Checkout 类，这允许在任何其他类中重用 mixin 类的功能。注意，对于 mixin 类，继承“是 a”行为并不适用，你不能说 Store 是 Checkout 或 OnlineStore 是 Checkout，它更多的是“使用 a”行为。因此，尽管 mixin 类——从语义上来说——用于继承行为，但从技术上来说，它们不使用软件工程中通常所知的继承，因此使用了术语“类继承”。

那么为什么 mixins 对基于类的视图很重要呢？原来，您在上一节中学习的所有基于基类的视图类都是建立在基于类的视图混合之上的。这不仅意味着您可以混合和匹配 mixin 来创建定制的基于类的视图，而且您还可以创建或重用其他 mixin 来增强基于类的视图的功能。

早些时候，当你学习了基于类的视图时，你可能还记得清单 [9-13](#Par148) 中的例子，9-14 增加了一个 Django 框架成功消息，当一个记录被创建时通知用户。在清单 [9-13](#Par148) 的情况下，这需要接入`form_valid()`基于类的视图方法来添加这个消息，而在清单 [9-14](#Par158) 的情况下，这需要接入`post()`基于类的视图方法。尽管这两种方法都非常有效，但是为了添加 Django 框架成功消息的唯一目的，在基于类的视图中声明这两种方法中的任何一种都需要做大量的工作。

通过在基于类的视图上使用 mixin，您可以简化将基于类的视图中的 Django 框架成功消息添加到单个字段，而不需要定制更复杂的方法和/或将逻辑添加到基于类的视图。

清单 [9-22](#Par282) 展示了一个`CreateView`基于类的视图，该视图使用 mixin 来支持将 Django 框架成功消息添加到基于类的视图响应中的功能。

```py
# views.py
from django.views.generic.edit import CreateView

from django.contrib.messages.views import SuccessMessageMixin

from .models import Item, ItemForm

class ItemCreation(SuccessMessageMixin,CreateView):
    model = Item
    form_class = ItemForm
    success_url = reverse_lazy('items:index')
    success_message = "Item %(name)s created successfully"

Listing 9-22.Django class-based view with CreateView and mixin class

```

Caution

在多重继承的基于类的视图(例如`class ItemCreation(SuccessMessageMixin,CreateView)`)的上下文中，Mixin 类应该总是首先声明，以优先于粗粒度的基于类的视图类。

清单 [9-22](#Par282) 的第一个重要方面是`SuccessMessageMixin` mixin 类的`import`语句，这使得任何基于类的视图都能够轻松添加成功消息。接下来，`SuccessMessageMixin` mixin 类和`CreateView`基于类的视图被添加到`ItemCreation`类中，为基于类的视图提供核心功能。注意，mixin 类是使用标准 Python 继承语法添加到基于类的视图中的。

一旦`ItemCreation`基于类的视图获得了对`SuccessMessageMixin` mixin 类行为的访问，生成成功消息所需要的就是在`success_message`字段中定义实际的消息。以这种方式，当在基于类的视图的上下文中发生成功操作时(例如，`success_url`被触发)，基于类的视图自动将`success_message`值添加到请求中以显示给终端用户。

正如您在清单 [9-22](#Par282) 中看到的，将 Django 框架成功消息添加到基于类的视图的过程被大大简化了，并通过 mixin 类实现了可重用性。当您将它与清单 [9-13](#Par148) 和 [9-14](#Par158) 中采用的方法进行比较时，这一点尤其正确，清单 9-13 和清单 9-14 中采用的方法由覆盖基于类的视图方法组成，这些方法需要大量的输入(许多是重复的)来完成一个简单的任务。