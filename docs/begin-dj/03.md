# 3.Django 模板

Django 模板定义了在视图方法处理完请求后发送给最终用户的布局和最终格式。在本章中，您将学习 Django 模板使用的语法、Django 模板可用的配置选项，以及各种 Django 模板构造(例如过滤器、标签、上下文处理器),这些构造允许您创建精细的布局并将格式应用于呈现给最终用户的内容。

## Django 模板语法

虽然有超过 100 个内置的构造可以帮助你构建 Django 模板——所有这些你都将在本章中学习到——但是首先，这些是你需要认识的最重要的语法元素:

*   `{{output_variable}}`。-开头和结尾用双花括号括起来的值表示变量的输出。Django 视图、url 选项或上下文处理器将变量传递到模板中。在模板中，您可以使用`{{}}`来输出变量的内容，以及使用 Python 的点符号来输出变量的更深层次的元素(例如，字段、键、方法)。例如，`{{store.name}}`告诉 Django 模板输出`store`变量的`name`，其中`store`可以是一个`object`，而`name`可以是一个字段，或者`store`可以是一个字典，而`name`可以是一个键。
*   `{% tag %}`。-用百分号括起来的大括号括起来的值称为标记。Django 标签提供了包装在简单语法表示中的复杂格式化逻辑。
*   `variable|filter`。-竖线`|`后声明的值称为过滤器。Django 过滤器提供了一种将格式化逻辑应用于单个变量的方法。

Django 模板中除了这三种变体之外的任何其他语法都被“照原样”处理。这意味着如果一个模板声明了超文本标记语言(HTML)标题`<h1>Welcome!</h1>`，用户将得到一个大的 HTML 标题。就这么简单。

但是让我们来看看一个不太明显的 Django 模板语法行为，它很重要，你必须马上理解，因为它是几乎所有与 Django 模板相关的事物中反复出现的主题。

### 自动转义:HTML 和安全方面的错误

Django 项目在 Web 上运行，所以默认情况下所有模板都被假定为产生 HTML。虽然这是一个合理的假设，但它并不合理，除非你面临以下两种情况之一:

*   你不能确保 Django 模板产生有效的 HTML，事实上可能会产生危险的标记。
*   您希望 Django 模板生成非 HTML 内容，比如逗号分隔值(CSV)、可扩展标记语言(XML)或 JavaScript 对象符号(JSON)。

那么，您怎么可能在 Django 模板中引入无效的 HTML 甚至危险的内容呢？这是互联网，来自其他用户或提供商的内容可能会出现在您的 Django 模板中，从而导致问题(例如，用户提交的数据、第三方服务、来自数据库的内容)。

问题不在于你直接放在 Django 模板中的内容——因为你输入的内容是有效的——问题在于通过变量、标签、过滤器和上下文处理器放置的动态内容，它有可能来自任何地方。让我们使用以下变量对此进行进一步分析:

```py
store_legend = "<b>Open since 1965!</b>"

js_user_date = "<script>var user_date = new Date()</script>"

```

如果带有这种内容的变量进入 Django 模板，并且您试图输出它们，它们会被逐字输出。`store_legend`不会作为 HTML 粗体语句输出，而是由`<b>`和`</b>`包围的语句。类似地，`js_user_date`不会产生带有用户浏览器本地日期的 JavaScript 变量，而是逐字输出`<script>`语句。

这是因为在默认情况下，Django 会自动转义动态结构(即变量、标签、过滤器和上下文处理器)中的内容。表 [3-1](#Tab1) 显示了字符 Django 默认自动转义。

表 3-1。

Characters Django auto-escapes by default

<colgroup><col> <col></colgroup> 
| 原始字符 | 逃到 |
| --- | --- |
| < | < |
| > | > |
| (单引号) | ' |
| “(双引号) | " |
| & | & |

正如您在表 [3-1](#Tab1) 中看到的，Django 自动转义包括将潜在冲突甚至危险的字符——在 HTML 的上下文中——转换成等价的可视表示，也称为转义字符。 [<sup>1</sup>](#Fn1)

之所以这样做，是因为恶意用户或未经检查的来源可以轻松生成包含表 [3-1](#Tab1) 左列字符的内容，这可能会破坏用户界面或执行恶意 JavaScript 代码。所以 Django 为了安全起见会出错，并自动将表 [3-1](#Tab1) 中的字符换成等价的可视化表示。虽然你当然可以禁用表 [3-1](#Tab1) 中字符的自动转义，但这必须显式完成，因为这代表着安全风险。

虽然自动转义对于 HTML 输出来说是一个很好的安全预防措施，但这将我们带到假设 Django 总是生成 HTML 的第二点。如果 Django 模板必须输出 CSV、JSON 或 XML 内容，而像`<`、`>`、`'`(单引号)、`"`(双引号)和`&`这样的字符对内容消费者有特殊的意义，并且不能使用等效的视觉表示，那么会发生什么呢？在这种情况下，您还需要显式禁用 Django 强制的默认自动转义行为。

因此，无论您想通过 Django 模板中的变量输出实际的 HTML，还是输出 CSV、JSON 或 XML，而 Django 没有对这些内容应用 HTML 安全实践，您都需要处理 Django 自动转义。

在 Django 模板中有各种方法来控制自动转义(例如，全局地，单独的变量，单独的过滤器)，你将在本章的学习中了解到这些。但是自动转义是 Django 模板中的一个永恒主题，还有以下相关术语:

*   安全。-如果 Django 模板构造被标记为安全，这意味着表 [3-1](#Tab1) 中没有字符被转义。换句话说，安全等于“我知道我在做什么”输出内容“原样”。
*   逃跑。-如果 Django 模板构造被标记为转义，这意味着表 [3-1](#Tab1) 中的字符被转义。换句话说，escape 等于“确保没有潜在危险的 HTML 字符被输出，使用等效的可视化表示。”
*   自动逃生开/自动逃生关(安全)。-如果 Django 模板使用 auto-escape on，这意味着该范围内的 Django 模板构造应该对表 [3-1](#Tab1) 中的字符进行转义。如果 Django 模板使用自动转义关闭，这意味着该范围内的 Django 模板构造应该“按原样”输出，而不是对表 [3-1](#Tab1) 中的字符进行转义。

就这样，我们结束了关于 Django 自动逃脱这个相当枯燥但重要的话题的谈话。接下来，让我们探索 Django 模板的各种配置选项。

## Django 模板配置

默认情况下，由于`settings.py`中的`TEMPLATES`变量，所有 Django 项目上都启用了 Django 模板。清单 [3-1](#Par27) 展示了 Django 项目中的默认`TEMPLATES`值。

```py
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
Listing 3-1.Default Django template configuration in settings.py

```

`BACKEND`变量表示项目使用 Django 模板。`DIRS`和`APP_DIRS`变量告诉 Django 在哪里定位 Django 模板，这将在下一节解释。`OPTIONS`中的`context_processors`字段告诉 Django 为 Django 项目启用哪些上下文处理器。简而言之，上下文处理器提供了跨所有 Django 模板共享数据的能力，而不需要在 Django 视图中以零碎的方式定义它。

本章后面的部分描述了默认 Django 上下文处理器提供的数据，以及如何编写自己的上下文处理器来共享所有 Django 模板上的定制数据。

### 模板搜索路径

Django 根据变量`DIRS`和`APP_DIRS`中的值决定在哪里寻找模板。正如您在清单 [3-1](#Par27) 中看到的，Django 默认为空的`DIRS`值，并将`APP_DIRS`变量设置为真。

设置为`True`的`APP_DIRS`变量告诉 Django 在名为`templates`的 Django 应用程序子文件夹中寻找模板——如果你从未听说过 Django 应用程序的概念，请看第 [1 章](01.html)，它描述了这个概念。

`APP_DIRS`行为有助于将应用程序的模板包含到应用程序的结构中，但请注意，模板搜索路径不知道应用程序的名称空间。例如，如果你有两个应用程序都依赖于一个名为`index.html`的模板，并且这两个应用程序在`views.py`中都有一个将控制权返回给`index.html`模板的方法(例如`render(request,'index.html')`，那么这两个应用程序都将使用`INSTALLED_APPS`中最顶层声明的应用程序的`index.html`，因此只有一个应用程序将使用预期的`index.html`。

清单 [3-2](#Par34) 中展示的第一组文件夹显示了两个 Django 应用程序，它们具有这种潜在的模板布局冲突。

```py
# Templates directly under templates folder can cause loading conflicts
+---+-<PROJECT_DIR_project_name_conflict>
    |
    +-__init__.py
    +-settings.py
    +-urls.py
    +-wsgi.py
    |
    +-about(app)-+
    |            +-__init__.py
    |            +-models.py
    |            +-tests.py
    |            +-views.py
    |            +-templates-+
    |                        |
    |                        +-index.html
    +-stores(app)-+
                 +-__init__.py
                 +-models.py
                 +-tests.py
                 +-views.py
                 +-templates-+
                             |
                             +-index.html

# Templates classified with additional namespace avoid loading conflicts
+---+-<PROJECT_DIR_project_name_namespace>
    |
    +-__init__.py
    +-settings.py
    +-urls.py
    +-wsgi.py
    |
    +-about(app)-+
    |            +-__init__.py
    |            +-models.py
    |            +-tests.py
    |            +-views.py
    |            +-templates-+
    |                        |
    |                        +-about-+
    |                                |
    |                                +-index.html
    +-stores(app)-+
                 +-__init__.py
                 +-models.py
                 +-tests.py
                 +-views.py
                 +-templates-+
                             |
                             +-stores-+
                                      |
                                      +-index.html

Listing 3-2.Django apps with templates dirs with potential conflict and namespace qualification

```

为了解决这个潜在的模板搜索冲突，推荐的做法是在每个`templates`目录中添加一个额外的子文件夹作为名称空间，如清单 [3-2](#Par34) 中的第二组文件夹所示。

通过这种方式，您可以使用这个额外的命名空间子文件夹将控件重定向到模板，以避免任何歧义。因此，要将控制权发送给`about/index.html`模板，您应该声明`render(request,'about/index.html')`，要将控制权发送给`stores/index.html`，您应该声明`render(request,'stores/index.html')`。

如果您希望禁止这种允许从这些内部应用程序子文件夹加载模板的行为，您可以通过将`APP_DIRS`设置为`FALSE`来实现。

定义 Django 模板的一个更常见的方法是在应用程序结构之外建立一个或多个文件夹来保存 Django 模板。为了让 Django 找到这样的模板，可以使用清单 [3-3](#Par39) 中所示的`DIRS`变量。

```py
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
PROJECT_DIR = os.path.dirname(os.path.abspath(__file__))

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': ['%s/templates/' % (PROJECT_DIR),
                 '%s/dev_templates/' % (PROJECT_DIR),],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

Listing 3-3.
DIRS definition

with relative path in settings.py

```

正如您在清单 [3-3](#Par39) 中看到的，您可以在`DIRS`变量中声明各种目录。Django 在`DIRS`值中寻找模板，然后在应用程序的`templates`文件夹中寻找模板——如果`APP_DIRS`是`TRUE`——直到找到匹配的模板或者抛出`TemplateDoesNotExist`错误。

还要注意清单 [3-3](#Par39) 中的`DIRS`值依赖于由`PROJECT_DIR`变量动态确定的路径。当您在不同的机器上部署 Django 项目时，这种方法很有帮助，因为该路径是相对于顶级 Django 项目目录的(即，`settings.py`和主`urls.py`文件所在的位置)，并且不管 Django 项目安装在哪里(例如，`/var/www/`、`/opt/website/`、`C://website/`)，该路径都会动态调整。

### 无效的模板变量

默认情况下，Django 模板在包含无效变量时不会抛出错误。这是因为与 Django admin 相关的设计选择也使用了 Django 模板。

虽然在大多数情况下这不是一个大问题，但是对于调试任务来说，这可能会令人沮丧，因为 Django 不会通知您拼写错误或未定义的变量。例如，您可以输入`{{datee}}`而不是`{{date}}`，Django 通过输出一个空字符串`''`来忽略这一点，您也可以忘记在视图方法中将一个变量值传递给一个模板，Django 也静默地输出一个空字符串`''`，即使您可能已经在模板中定义了它。

要让 Django 在遇到 Django 模板中的无效变量时通知您，您可以使用`string_if_invalid`选项。清单 [3-4](#Par45) 中显示的`string_if_invalid`的第一个配置选项输出一个可见字符串，而不是空字符串`''`。

```py
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
PROJECT_DIR = os.path.dirname(os.path.abspath(__file__))

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': ['%s/templates/' % (PROJECT_DIR),'%s/dev_templates/' % (PROJECT_DIR),],
        'APP_DIRS': True,
        'OPTIONS': {
            'string_if_invalid': "**** WARNING INVALID VARIABLE %s ****",
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

Listing 3-4.
Output warning message

for invalid template variables with string_if_invalid

```

正如您在清单 [3-4](#Par45) 中看到的，`string_if_invalid`被赋予了字符串`"**** WARNING INVALID VARIABLE %s ****"`。当 Django 遇到一个无效变量时，它用这个字符串替换出现的变量，其中的`%s`变量被替换为无效的变量名，这让您可以很容易地定位哪里和哪些变量是无效的。

`string_if_invalid`选项的另一个配置选项是在遇到无效变量时执行更复杂的逻辑。例如，清单 [3-5](#Par48) 展示了在发现无效变量的情况下，如何引发错误以使模板无法呈现。

```py
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
PROJECT_DIR = os.path.dirname(os.path.abspath(__file__))

class InvalidTemplateVariable(str):
    def __mod__(self,other):
        from django.template.base import TemplateSyntaxError
        raise TemplateSyntaxError("Invalid variable : '%s'" % other)

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': ['%s/templates/' % (PROJECT_DIR),'%s/dev_templates/' % (PROJECT_DIR),],
        'APP_DIRS': True,
        'OPTIONS': {
            'string_if_invalid': InvalidTemplateVariable("%s"),
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

Listing 3-5.
Error generation

for invalid template variables with string_if_invalid

```

在清单[中，3-5](#Par48) `string_if_invalid`被赋予使用`%s`输入变量的`InvalidTemplateVariable`类，它代表无效的变量名——就像清单 [3-4](#Par45) 中的前一个例子一样。

`InvalidTemplateVariable`类很有趣，因为它继承了`str(string)`类的行为，并使用了 Python `__mod__`(模)魔法方法实现。虽然`__mod__`(模)魔术方法适合数字运算，但在这种情况下，它很有用，因为传入的字符串使用了`%`(模)符号，这使得`__mod__`方法运行。在`__mod__`方法中，我们只是用无效的变量名引发`TemplateSyntaxError`错误来暂停模板的执行。

Caution

Django admin 可能会被自定义的`string_if_invalid`值破坏。

由于某些显示的复杂程度，Django 管理模板特别依赖默认的`string_if_invalid`输出空字符串`''`。事实上，这种`string_if_invalid`默认行为通常被认为是一种“特性”，就像它被认为是一种“缺陷”或“烦恼”一样

因此，如果您使用清单 [3-4](#Par45) 或清单 [3-5](#Par48) 中的一种方法来覆盖`string_if_invalid`，请注意您很可能会损坏或中断 Django 管理页面。如果您依赖 Django admin，那么您应该只使用这些技术来调试项目的模板。

### 调试输出

当您使用顶级`DEBUG=True`设置运行 Django 项目并出现错误时，Django 模板会输出一个非常详细的页面，以使调试过程更容易——参见第 [5 章](05.html)了解关于`DEBUG`变量的更多细节，特别是“Django `settings.py`用于真实世界”一节

默认情况下，Django 模板重用顶级的`DEBUG`变量值来配置模板调试活动。在幕后，这个配置是通过`TEMPLATES`变量的`OPTIONS`内的调试字段设置的。图 [3-1](#Fig1) 说明了`DEBUG=True`时错误页面的样子。

![A441241_1_En_3_Fig1_HTML.jpg](A441241_1_En_3_Fig1_HTML.jpg)

图 3-1。

Django error page when DEBUG=True automatically sets template OPTION to ‘debug’:True

正如你在图 [3-1](#Fig1) 中看到的，Django 打印了模板的位置，以及模板本身的一个片段，以便于定位错误。该模板信息是由`'debug':True`选项生成的，该选项是基于顶级`DEBUG`变量设置的。但是，您可以显式地将调试选项设置为`False`，如清单 [3-6](#Par57) 所示，在这种情况下，错误页面将没有任何模板细节，只有回溯信息，如图 [3-2](#Fig2) 所示。

![A441241_1_En_3_Fig2_HTML.jpg](A441241_1_En_3_Fig2_HTML.jpg)

图 3-2。

Django error page when DEBUG=True and explicit OPTION ‘debug’:False

```py
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
PROJECT_DIR = os.path.dirname(os.path.abspath(__file__))

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': ['%s/templates/' % (PROJECT_DIR),'%s/dev_templates/' % (PROJECT_DIR),],
        'APP_DIRS': True,
        'OPTIONS': {
            'debug':False,
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

Listing 3-6.Option with debug equals False omits template details

```

### 自动退出

默认情况下，Django 模板使用安全惯例来自动转义某些字符——如表 [3-1](#Tab1) 所述——包含在动态生成的结构中(例如变量、标签、过滤器)。自动转义将可能破坏用户界面或产生危险结果的字符转换成安全的表示形式，这个过程在本章的第一节中有所描述。

然而，你可以在所有 Django 模板上全局禁用自动转义——并且故意渲染< as as >等...-`OPTIONS`中的`autoescape`字段如清单 [3-7](#Par60) 所示。

```py
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
PROJECT_DIR = os.path.dirname(os.path.abspath(__file__))

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': ['%s/templates/' % (PROJECT_DIR),'%s/dev_templates/' % (PROJECT_DIR),],
        'APP_DIRS': True,
        'OPTIONS': {
            'autoescape':False,
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

Listing 3-7.Option with auto-escape equals False omits auto-escaping on all Django templates

```

值得一提的是，在每个 Django 模板上禁用自动转义的另一种方法——如清单 [3-7](#Par60) 所示——是有选择地禁用自动转义。您可以使用`{% autoescape off %}`标签来禁用 Django 模板的一部分的自动转义，或者使用`safe`过滤器来禁用单个 Django 模板变量的自动转义。

如果你决定禁用所有 Django 模板的自动转义，如清单 [3-7](#Par60) 所示——坦白地说，如果你打算只使用 HTML，由于潜在的安全风险，我不建议这样做——如果需要，你也可以再次精确地启用自动转义。您可以使用`{% autoescape on %}`标签对 Django 模板的一部分启用自动转义，或者使用`escape`过滤器对单个 Django 模板变量进行转义。

### 文件字符集

Python 项目中使用的文件通常在顶部声明一个基于 Python PEP-263 规范的编码值(如`# -*- coding: utf-8 -*-`),[<sup>2</sup>](#Fn2)，以确保文件中的字符被正确解释。在 Django 模板中，你不用这种方式定义底层文件的编码，而是在项目的`settings.py`文件中定义。

有两种方法可以声明 Django 模板的编码字符:显式地作为`TEMPLATES`变量中`OPTIONS`的`file_charset`字段的一部分，或者通过`settings.py`中的顶级`FILE_CHARSET`变量。在`OPTIONS`中的`file_charset`中的显式声明优先于`FILE_CHARSET`赋值，但是`file_charset`的值默认为`FILE_CHARSET`，其本身默认为 utf-8 (Unicode)编码。

所以默认情况下，Django 模板编码被指定为 utf-8 或 Unicode，这是软件中使用最广泛的编码之一。尽管如此，如果您决定将数据合并到与 utf-8 不兼容的 Django 模板中(例如，带有重音符号的西班牙元音，如编码为 ISO-8859-1 的á或é，或日本汉字字符，如漢或者字编码为 JIS)您必须在项目的`settings.py`文件中定义`FILE_CHARSET`值——或者直接在`TEMPLATES`内`OPTIONS`的`file_charset`字段中定义——这样 Django 模板数据才能被正确解释。

Django 模板可以被赋予 Python 标准编码值中的任何编码值。 [<sup>3</sup>](#Fn3)

### 自动访问定制模板标签/过滤器模块

Django 模板可以访问一系列内置的标签和过滤器，不需要任何设置步骤。但是，如果您计划使用第三方模板标签/过滤器模块或者编写自己的模板标签/过滤器模块，那么您需要在每个 Django 模板上设置带有`{% load %}`标签(例如`{% load really_useful_tags_and_filters %}`)的访问，如果您需要访问几十或几百个模板上的特定标签/过滤器，这个过程可能会很烦人。

要自动访问第三方模板标签/过滤器或您自己的模板标签/过滤器，就像它们是内置标签/过滤器一样(即，不需要`{% load %}`标签)，您可以使用`OPTIONS`中的`builtins`字段，如清单 [3-8](#Par71) 所示。

```py
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
PROJECT_DIR = os.path.dirname(os.path.abspath(__file__))

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': ['%s/templates/' % (PROJECT_DIR),'%s/dev_templates/' % (PROJECT_DIR),],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
            'builtins': [
                 'coffeehouse.builtins',
                 'thirdpartyapp.customtags.really_useful_tags_and_filters',
            ],
        },
    },
]

Listing 3-8.Option with builtins to gain automatic access to tags/filters on all templates

```

正如您在清单 [3-8](#Par71) 中看到的，`builtins`字段接受一个模块列表，该列表包含用于内置处理的标签/过滤器。在这种情况下，`coffeehouse.builtins`代表一个名为`coffeehouse`的项目下的`builtins.py`文件——它包含定制的标签/过滤器。而`thirdpartyapp.customtags.really_useful_tags_and_filters`是一个带有标签/过滤器的第三方包，我们也想在 Django 模板中访问它，而不需要使用`{% load %}`标签。

第三方模板标签/过滤器模块和自定义模板标签/过滤器模块的另一个默认行为是，它们需要使用其原始标签/名称作为参考，而后者还需要将其放在注册的 Django 应用程序中名为`templatetags`的文件夹内。这两个默认行为可以用`OPTIONS`中的`libraries`字段覆盖，如清单 [3-9](#Par74) 所示。

```py
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
PROJECT_DIR = os.path.dirname(os.path.abspath(__file__))

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': ['%s/templates/' % (PROJECT_DIR),'%s/dev_templates/' % (PROJECT_DIR),],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
            'libraries': {
                 'coffeehouse_tags': 'coffeehouse.tags_filters.common',
            },
        },
    },
]

Listing 3-9.Option with libraries to register tags/filters with alternative label/name and under any project directory

```

清单 [3-9](#Par74) `'coffeehouse_tags': 'coffeehouse.tags_filters.common'`中的 libraries 语句告诉 Django 从`coffeehouse`项目的`tags_filters`文件夹中加载`common.py`文件——包括定制标签/过滤器——并通过`coffeehouse_tags`引用(例如`{% load coffeehouse_tags %}`)使模板可以访问它。使用清单 [3-9](#Par74) 中的方法，您可以在 Django 项目中的任何地方放置定制的标签/过滤器模块，并且为定制的标签/过滤器模块——或者第三方标签/过滤器模块——分配一个替代的参考值，而不是它们原来的标签/名称。

### 模板加载器

在前面的“模板搜索路径”一节中，我描述了 Django 如何使用`DIRS`和`APP_DIRS`变量搜索模板，这是 Django 模板配置的一部分。然而，我有意忽略了与这个模板搜索过程相关的一个更深层的方面:每个搜索机制都由一个模板加载器支持。

模板加载器是一个 Python 类，它实现了搜索和加载模板所需的实际逻辑。表 [3-2](#Tab2) 展示了 Django 中可用的内置模板加载器。

表 3-2。

Built-in Django template loaders

<colgroup><col> <col></colgroup> 
| 模板加载器类 | 描述 |
| --- | --- |
| django . template . loaders . file system . loader | 在 DIRS 变量中声明的目录中搜索并加载模板。当 DIRS 不为空时，默认启用。 |
| django . template . loaders . app _ directory。装货设备 | 从 INSTALLED_APPS 中声明的所有应用程序中名为 templates 的子目录中搜索并加载模板。当 APP_DIRS 为真时，默认情况下启用。 |
| django . template . loaders . cached . loader | 从文件系统或应用程序目录加载程序加载模板后，从内存缓存中搜索模板。 |
| django . template . Loader . location mem . loader .模板. loader | 从 Python 字典加载模板后，从内存缓存中搜索模板。 |

正如你所看到的，表 [3-2](#Tab2) 中的两个 Django 模板加载器是由`DIRS`或`APP_DIRS`变量自动设置的。然而，表 [3-2](#Tab2) 中的任何模板加载器都可以使用`TEMPLATES`内`OPTIONS`中的`loaders`字段进行明确设置。

## 创建可重复使用的模板

模板倾向于具有在多个实例中同等使用的公共部分。例如，无论一个项目有 5 个还是 100 个模板，所有模板的页眉和页脚部分很少改变。其他模板部分，如菜单和广告，也属于这种在多个模板中保持不变的内容类别。所有这些都会导致多个模板的重复，这可以通过创建可重用的模板来避免。

使用可重用的 Django 模板，您可以在单独的模板上定义公共部分，并在其他模板中重用它们。此过程使创建和管理项目模板变得容易，因为单个模板更新会影响所有模板。

可重用的 Django 模板还允许您定义页面块来逐页覆盖内容。此过程使项目的模板更加模块化，因为您定义了顶级块来建立整体布局并逐页定义内容。

让我们朝着构建可重用的 Django 模板迈出第一步，探索 Django 内置的`{% block %}`标签。清单 [3-10](#Par83) 展示了一个名为`base.html`的模板的第一行，带有几个`{% block %}`标签。

```py
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>{% block title%}Default title{% endblock title %}</title>
    <meta name="description" content="{% block metadescription%}{% endblock metadescription %}">
    <meta name="keywords" content="{% block metakeywords%}{% endblock metakeywords %}">
Listing 3-10.Django template with {% block %} tags

```

注意清单 [3-10](#Par83) 中的语法`{% block <name>%}{% endblock <name> %}`。每个`{% block %}`标签都有一个引用名。其他 Django 模板使用引用名来覆盖每个块的内容。

例如，HTML `<title>`标签中的`{% block title %}`标签定义了一个网页标题。如果另一个模板重用清单 [3-10](#Par83) 中的模板，它可以通过覆盖标题块来定义自己的网页标题。如果未在模板上覆盖块，则块将接收块中的默认内容。对于`title`块，默认内容是`Default title`，对于`metadescription`和`metakeywords`块，默认内容是一个空字符串。

清单 [3-10](#Par83) 中所示的相同机制可用于定义任意数量的块(例如，内容、菜单、页眉、页脚)。值得一提的是`{% endblock <name> %}`的`<name>`参数是可选的，仅使用`{% endblock %}`来结束一个 block 语句是有效的；但是，前一种技术使得 block 语句的结束位置更加清晰，这在一个模板有多个块时尤其有用。

尽管可以通过 Django 视图方法或 url 请求直接调用清单 [3-10](#Par83) 中的模板，但这种模板的目的是将其用作其他模板的基础模板。要重用 Django 模板，可以使用 Django 内置的`{% extends %}`标签。

`{% extends %}`标签使用语法`{% extends <name> %}`来重用另一个模板的布局。这意味着为了重用在文件`base.html`中定义的清单 [3-10](#Par83) 中的布局，您使用语法`{% extends "base.html" %}`。此外，如果使用`{% extends %}`标签，它必须是 Django 模板中的第一个定义，如清单 [3-11](#Par89) 所示。

```py
{% extends "base.html" %}
{% block title %}Coffeehouse home page{% endblock title %}
Listing 3-11.Django template with {% extends %} and {% block %} tag

```

Tip

在{% extend <name>%}标记语句中，<name>值也可以使用相对路径(例如，“../base.html”)，以及由视图传递的变量，该变量可以是字符串(例如，“master.html”)或视图中加载的模板对象。</name>T3】</name>

注意清单 [3-11](#Par89) 中第一个模板语句是如何`{% extends "base.html" %}`的。此外，注意清单 [3-11](#Par89) 是如何用内容`Coffeehouse home page`定义`{% block title %}`标签的。清单 [3-11](#Par89) 中的块覆盖了`base.html`模板中的标题栏。那么清单 [3-11](#Par89) 中的 HTML `<title>`标签在哪里呢？没有，你也不需要。Django 自动重用来自`base.html`模板的布局，并在必要的地方替换块内容。

重用其他模板的 Django 模板倾向于使用有限的布局元素(例如 HTML 标签)和更多的 Django `block`语句来覆盖内容。这是有益的，因为正如我前面所概述的，它允许您一次建立整体布局，并在逐页的基础上定义内容。

Django 模板的可重用性可以多次出现。例如，您可以拥有模板 A、B 和 C，其中 B 要求重用 A，但是 C 要求重用 B 的一部分，唯一的区别是模板 C 需要使用`{% extends "B" %}`标签而不是`{% extends "A"%}`标签。但是由于模板 B 重用了 A，模板 C 也可以访问模板 A 中的相同元素。

当重用 Django 模板时，也可以从父模板访问块内容。Django 通过引用`block.super`公开父模板中的块内容。清单 [3-12](#Par95) 展示了三个模板，展示了包含网页路径或“面包屑”的块的这种机制

```py
# base.html template
<p>{% block breadcrumb %}Home{% endblock breadcrumb %}</p>

# index.html template
{% extends "base.html" %}
{% block breadcrumb %}Main{% endblock breadcrumb %}

# detail.html template
{% extends "index.html" %}
{% block breadcrumb %} {{block.super}} : Detail {% endblock breadcrumb %}

Listing 3-12.Django templates use of {{block.super}} with three reusable templates

```

清单 [3-12](#Par95) 中的`base.html`模板用默认值`Home`定义了`breadcrumb`块。接下来，`index.html`模板重用`base.html`模板并用值`Main`覆盖`breadcrumb`块。最后，`detail.html`模板重用`index.html`模板并覆盖`breadcrumb`块值。但是，请注意最后一个块覆盖中的`{{block.super}}`语句。因为`{{block.super}}`在`breadcrumb`块中，`{{block.super}}`告诉 Django 从父模板块中获取内容。

Django 模板中的另一个可重用功能是将一个 Django 模板包含在另一个 Django 模板中。Django 通过`{% include %}`标签支持这个功能。

`{% include %}`标签需要一个模板参数——类似于`{% extend %}`标签——它可以是硬编码的字符串引用(如`{% include "footer.html" %}`)、模板的相对路径(如`{% include "../header.html" %}`)，或者是视图传递的变量，可以是视图中加载的字符串或模板对象。

声明为`{% include %}`标签一部分的模板知道声明它们的模板中的上下文变量。这意味着如果模板 A 使用了`{% include "footer.html" %}`标签，模板 A 的变量就会自动地为`footer.html`模板所用。

包含性地，可以使用`with`关键字显式地为`{% include %}`语句提供上下文变量。例如，`{% include "footer.html" with year="2013" %}`语句使得`year`变量可以在`footer.html`模板中访问。`{% include %}`标签还支持使用`with`符号传递多个变量的能力(例如`{% include "footer.html" with year="2013" copyright="Creative Commons" %}`)。

最后，如果您希望声明为`{% include %}`标签一部分的模板能够限制声明它们的模板对上下文变量的访问，那么您可以使用`only`关键字。例如，如果模板 B 使用`{% include "footer.html" with year="2013" only %}`语句，那么`footer.html`模板只能访问`year`变量，而不考虑模板 B 中可用的变量。类似地，`{% include "footer.html" only %}`语句将`footer.html`模板限制为没有变量，而不考虑使用该语句的模板中可用的变量。

## 内置上下文处理器

默认情况下，Django 模板可以访问各种变量。这消除了在每个 Django 视图方法中不断声明广泛使用的变量或作为 url 额外选项的需要。这些变量通过模板上下文处理器变得可用。

Django 模板上下文处理器在项目的`settings.py`文件中明确定义，在`OPTIONS`键内的`TEMPLATES`变量中。默认情况下，如清单 [3-1](#Par27) 所示，Django 项目通过内置于 Django 的四个上下文处理器来启用。接下来，我将描述每个上下文处理器提供的数据变量。

### Django 调试上下文处理器(django . template . context _ processors . debug)

Django 调试上下文处理器公开了有助于调试的变量。这个上下文处理器使得以下变量在所有 Django 模板上都可用:

*   `debug`。-基于`settings.py`文件中的`DEBUG`变量，包含真或假。
*   `sql_queries`。-包含由支持方法视图运行的数据库连接详细信息(例如，SQL 语句)。

Note

只有在 settings.py 中的 INTERNAL_IPS 变量中定义了请求 IP 地址时，Django 调试上下文处理器才会显示变量值。即使变量是在模板中声明的(例如{{debug}}或{{sql_queries}})，这种限制也只允许某些用户查看模板中的调试消息，而其他用户不会查看任何内容。

例如，要查看本地工作站上的 debug 和 sql_queries 值，请将 INTERNAL_IPS = ['127.0.0.1']添加到 settings.py 文件中。这告诉 Django 为来自 IP 地址 127.0.0.1 的请求显示这些变量值。

### Django 请求上下文处理器(django . template . context _ processors . request)

Django 请求上下文处理器公开与请求(即 HTTP 请求)相关的变量。这个上下文处理器通过一个名为`request`的大型字典提供数据，该字典包括以下一些键值:

*   `request.GET`。-包含请求的 HTTP GET 参数。
*   `request.POST`。-包含请求的 HTTP POST 参数。
*   `request.COOKIES`。-包含请求的 HTTP COOKIES。
*   `request.CONTENT_TYPE`。-包含请求的 HTTP 内容类型标头。
*   `request.META`。-包含请求的 HTTP 元数据。
*   `request.REMOTE_ADDR`。-包含请求的 HTTP 远程地址。

### Django 授权上下文处理器(django . contrib . auth . context _ processors . auth)

Django 身份验证上下文处理器公开了与身份验证逻辑相关的变量。这个上下文处理器使得 Django 模板中的以下变量可以访问:

*   `user`。-包含用户数据(例如，id、姓名、电子邮件、匿名用户)。
*   `perms`。-包含用户应用权限(例如，用户在`django.contrib.auth.context_processors.PermWrapper`对象中可以访问的真、假或显式应用权限)。

### Django 消息上下文处理器(django . contrib . messages . context _ processors . messages)

Django 消息上下文处理器公开与 Django 消息框架相关的变量，在第 [2](02.html) 章中介绍。消息在 Django 视图方法中添加到消息框架中，然后在 Django 模板中公开。这个上下文处理器使得 Django 模板中的以下变量可以访问:

*   `messages`。-包含通过 Django 视图方法中的 Django 消息框架添加的消息。
*   `DEFAULT_MESSAGE_LEVELS`。-包含消息级别名称到其数值的映射(如`{'DEBUG': 10, 'INFO': 20, 'WARNING': 30, 'SUCCESS': 25, 'ERROR': 40}`)。

### 其他内置的 Django 上下文处理器:i18n、媒体、静态、tz 和 CSRF 上下文处理器

之前的上下文处理器提供了所有 Django 项目模板所需的一些最常见的数据，这也是它们默认启用的原因。然而，这并不意味着它们是唯一内置的 Django 上下文处理器。事实上，还有五个内置的上下文处理器可以用来访问所有 Django 模板中的某些数据。

#### Django i18n 上下文处理器(django . template . context _ processors . i18n)

Django i18n 上下文处理器公开了与国际化逻辑相关的变量。这个上下文处理器使得 Django 模板中的以下变量可以访问:

*   `LANGUAGES`。-包含 Django 项目的可用语言。
*   `LANGUAGE_CODE`。-包含项目语言代码，基于`settings.py`文件中的`LANGUAGE_CODE`变量。
*   `LANGUAGE_BIDI`。-包含当前项目语言方向。对于从左到右的语言(例如，英语、法语、德语)，它被设置为`False`;对于从右到左的语言(例如，希伯来语、阿拉伯语)，它被设置为`True`。

#### Django 媒体上下文处理器(django . template . context _ processors . media)

Django 媒体上下文处理器公开了一个与媒体资源相关的变量。这个上下文处理器使得 Django 模板中的以下变量是可访问的:

*   `MEDIA_URL`。-包含媒体 url，基于`settings.py`文件中的`MEDIA_URL`变量。

#### Django 静态上下文处理器(django . template . context _ processors . static)

Django 静态上下文处理器公开了一个与静态资源相关的变量。这个上下文处理器使得 Django 模板中的以下变量是可访问的:

*   `STATIC_URL`。-包含静态 url，基于`settings.py`文件中的`STATIC_URL`变量。

Tip

尽管静态上下文处理器是可访问的(也就是说，它没有被弃用)，但它的功能已经过时，应该避免使用。您应该改用 staticfiles 应用程序。更多细节在第 [5](05.html) 章设置静态网页资源(图片、CSS、JavaScript)一节中提供。

#### Django tz 上下文处理器(django . template . context _ processors . tz)

Django tz 上下文处理器公开了一个与项目时区相关的变量。这个上下文处理器使得 Django 模板中的以下变量是可访问的:

*   `TIME_ZONE`。-包含项目的时区，基于`settings.py`文件中的`TIME_ZONE`变量。

#### Django CSRF 上下文处理器(django . template . context _ processors . csrf)

跨站点请求伪造(CSRF)上下文处理器将`csrf_token`变量添加到所有请求中。这个变量被`{% csrf_token %}`模板标签用来防止跨站点请求伪造。

尽管您可以访问任何 Django 模板中的`csrf_token`变量值，但是您几乎不需要(如果有的话)直接公开它，因为它被用作检测伪造请求的安全机制。第 6 章，涵盖了 Django 表单的主题，描述了它是什么以及 CSRF 如何与 Django 一起工作。

由于让`csrf_token`变量在所有请求上可用的安全重要性，CSRF 上下文处理器总是被启用——不管`OPTIONS`中的`context_processors`列表如何——并且不能被禁用。

## 自定义上下文处理器

当您在 view methods 或 url extra 选项中设置数据时，您这样做是为了访问各个 Django 模板上的数据。定制的 Django 上下文处理器允许您在所有 Django 模板上设置访问数据。

Django 自定义上下文处理器的结构就像一个常规的 Python 方法，带有一个返回字典的`HttpRequest`对象参数。上下文处理器的返回字典关键字表示模板引用和可在模板中访问的字典值数据对象(例如，字符串、列表、字典)。清单 3-13 展示了一个定制的 Django 上下文处理器方法。

```py
def onsale(request):
    # Create fixed data structures to pass to template
    # data could equally come from database queries
    # web services or social APIs
    sale_items = {'Monday':'Mocha 2x1','Tuesday':'Latte 2x1'}
    return {'SALE_ITEMS': sale_items}
Listing 3-13.Custom Django context processor method

```

正如您在清单 [3-13](#Par139) 中看到的，`onsale`方法有一个`request`参数——代表一个`HttpRequest`对象——并返回一个字典。本例中的字典有一个名为`SALE_ITEMS`的键和一个硬编码字典值。

然而，正如您可以在 Django 视图方法或 url 选项中设置任何类型的数据以传递给模板一样，自定义 Django 上下文处理器方法也可以从请求参数(例如，cookie、远程 IP 地址)中访问数据，甚至查询数据库并使这些数据对所有模板可用。

自定义上下文处理器方法可以放在任何项目文件或目录中。位置和命名约定并不重要，因为 Django 通过项目的`settings.py`文件中的`TEMPLATES`变量的`OPTIONS`中的`context_processors`变量来检测上下文处理器。我将把清单 [3-13](#Par139) 中的上下文处理器方法放在`stores` app 子目录中一个名为`processors.py`的文件中。

一旦保存了自定义上下文处理器方法，就必须配置 Django 来定位它。清单 [3-14](#Par144) 显示了`context_processors`变量的更新，包括了来自清单 [3-13](#Par139) 的自定义上下文处理器方法。

```py
'OPTIONS': {
    'context_processors': [
        'coffeehouse.stores.processors.onsale',
        'django.template.context_processors.debug',
        'django.template.context_processors.request',
        'django.contrib.auth.context_processors.auth',
        'django.contrib.messages.context_processors.messages',
    ],
}
Listing 3-14.Django template context processor definitions in context_processors in OPTIONS of TEMPLATES

```

在清单 [3-14](#Par144) 中，您可以看到`coffeehouse.stores.processors.onsale`声明，其中`coffeehouse.stores`表示 package.app 名称，`processors`是包含自定义上下文处理器的文件(即，stores 应用程序中的`processors.py`)，而`onsale`是包含自定义上下文处理器逻辑的实际方法。

一旦在项目的`settings.py`文件中声明了上下文处理器，带有清单 [3-13](#Par139) 中的`SALE_ITEMS`键的定制字典就可以用于所有的 Django 模板。

## 内置 Django 过滤器

Django 过滤器设计用于格式化模板变量。应用 Django 过滤器的语法是竖线字符`|`，在 Unix 环境中也称为“管道”(例如`{{variable|filter}}`)。值得一提的是，可以在同一个变量上使用多个过滤器(例如，`{{variable|filter|filter}}`)。

我将把每个内置的 Django 过滤器分成不同的功能部分，这样更容易识别它们。我将使用的功能类是日期、字符串、列表、数字、字典、空格和特殊字符、开发、测试和 URL。

Tip

您可以使用{% filter %}标签将 Django 过滤器应用于整个部分。如果在同一个部分中有一组变量，并且希望对所有变量应用相同的过滤器，那么使用{% filter %}标记比在每个变量上单独声明过滤器更容易。本章关于 Django 内置标签的下一节提供了关于{% filter %}标签的更多细节

### 日期

*   `date`。-`date`过滤器格式化 Python `datetime`对象，并且仅当变量是这种类型的 Python 对象时才起作用。`date`过滤器使用一个字符串来指定格式。例如，如果一个变量包含一个日期为 01/01/2018 的`datetime`对象，过滤器语句`{{variable|date:"F jS o"}}`输出 2018 年 1 月 1 日。日期过滤器的字符串语法基于表 [3-3](#Tab3) 中描述的字符。

Tip

如果没有为日期筛选器提供字符串参数(例如{{variable|date}})，则默认为“N j，Y”字符串，该字符串来自 DATE_FORMAT 的默认值。

Note

日期筛选器还可以接受预定义的日期变量{ { variable | DATE:" DATE _ FORMAT " } } 、{ { variable | DATE:" DATETIME _ FORMAT " }、{ { variable | DATE:" SHORT _ DATE _ FORMAT " % }或{ { variable | DATE:" SHORT _ DATETIME _ FORMAT " }。

预定义的日期变量本身也由基于表 [3-3](#Tab3) 中语法的日期字符串组成。例如，DATE_FORMAT 默认为“N j，Y”(例如，2018 年 1 月 1 日)，DATETIME_FORMAT 默认为“N j，Y，P”(例如，2018 年 1 月 1 日上午 12 点)，SHORT_DATE_FORMAT 默认为“m/d/Y”(例如，2018 年 1 月 1 日上午 12 点)，SHORT_DATETIME_FORMAT 默认为“m/d/Y P”(例如，2018 年 1 月 1 日上午 12 点)。在项目的 settings.py 文件中，可以用不同的日期字符串重写每个日期变量。

表 3-3。

Django date and time format characters

<colgroup><col> <col></colgroup> 
| 基于标准的字符 | 描述 |
| --- | --- |
| c | 输出 ISO 8601 格式(例如，2015-01-02T10:30:00.000123+02:00 或 2015-01-02t 10:30:00.000123，如果日期时间没有时区[即，简单日期时间]) |
| r | 输出 RFC 2822 格式的日期(例如，“星期四，2000 年 12 月 21 日 16:01:07 +0200”) |
| U | 输出自 Unix 纪元日期-1970 年 1 月 1 日 00:00:00 UTC 以来的秒数 |
| I(大写的 I) | 输出夏令时是否有效(例如，“1”或“0”) |
| 基于小时的字符 | 描述 |
| a | 输出'上午'或'下午' |
| A | 输出' AM '或' PM ' |
| f | 输出时间，12 小时制的小时和分钟，如果分钟为零，则不输出分钟(例如，“1”，“1:30”) |
| g | 输出不带前导零的小时、12 小时格式(例如“1”到“12”) |
| G | 输出不带前导零的 24 小时制小时格式(例如，0 到 23) |
| h | 输出小时，12 小时格式(例如，“01”到“12”) |
| H | 输出小时，24 小时格式(例如，“00”到“23”) |
| 我 | 输出分钟数(例如“00”到“59”) |
| P | 输出时间，12 小时制的小时、分钟和' a.m.'/'p.m . '，如果分钟为零，则不输出分钟，如果合适，则输出特殊情况字符串' midnight '和' noon '(例如，' a . m . 1 '，' 1:30 p.m . '，' midnight '，' noon '，' 12:30 p.m . ') |
| s | 输出秒，带前导零的两位数(例如，“00”到“59”) |
| u | 输出微秒数(例如，000000 到 999999) |
| 时区字符 | 描述 |
| e | 输出时区名称。可以是任何格式，或者可能返回空字符串，具体取决于日期时间的定义(例如，“”、“GMT”、“-500”、“美国/东部”) |
| O | 以小时为单位输出时区与格林威治时间的差异(例如，“+0200”) |
| T | 输出日期时间时区(例如' EST '，' MDT ') |
| Z | 以秒为单位输出时区偏移量。UTC 以西的时区偏移量始终为负，而 UTC 以东的时区偏移量始终为正(例如-43200 到 43200) |
| 日和周字符 | 描述 |
| D | 输出星期几，文本，3 个字母(例如，“Thu”，“Fri”) |
| L(小写 L) | 输出星期几，文本，长型(例如，“星期四”，“星期五”) |
| S | 输出一个月中某一天的英文序号后缀，2 个字符(例如，“st”、“nd”、“rd”或“th”) |
| w | 输出星期几，不带前导零的数字(例如，“0”代表星期日，“6”代表星期六) |
| z | 输出一年中的某一天(例如，0 到 365) |
| W | 输出一年中的周数，基于 ISO-8601 从星期一开始(例如，1，53) |
| o | 输出周编号年份，对应于 ISO-8601 周编号(W)(例如，“1999”) |
| 月份字符 | 描述 |
| b | 输出文本月份，3 个字母，小写(例如'一月'，'二月') |
| d | 输出一个月中的某一天，2 位数，带前导零(例如，“01”到“31”) |
| j | 输出不带前导零的一个月中的某一天(例如，“1”到“31”) |
| E | 输出月份，区域特定的替代表示，通常用于长日期表示(例如，波兰语区域的“listopada”，与“Listopad”相对) |
| F | 输出月份，文本，长型(例如，“一月”，“二月”) |
| m | 输出月份，带前导零的两位数(例如，“01”到“12”) |
| M | 输出月份，文本，3 个字母(例如'一月'，'二月') |
| n | 输出不带前导零的月份(例如“1”到“12”) |
| 普通 | 以美联社风格输出月份缩写(例如，“一月”、“二月”、“三月”、“五月”) |
| t | 输出给定月份的天数(例如，28 到 31) |
| 年份字符 | 描述 |
| L | 输出布尔值来判断是否是闰年(例如，真或假) |
| y | 输出年份，两位数(例如“99”) |
| Y | 输出年份，4 位数字(例如，“1999”) |

To literally output a date character in a string statement you can use the backslash character (e.g., {{variable|date:"jS \o\f F o"}} outputs 1st of January 2018, note the escaped \o\f)

*   `time`。-`time`过滤器格式化 Python `datetime`对象的时间部分。`time`过滤器类似于`date`过滤器，它使用一个字符串来指定时间格式。例如，如果一个变量包含一个时间为中午的`datetime`对象，那么过滤器语句`{{variable|time:"g:i"}}`输出 12:00。时间过滤器使用与时间相关的表 [3-3](#Tab3) 中所示的相同格式字符。

Tip

如果没有为日期筛选器提供字符串参数(例如{{variable|time}} ),则默认为“P”字符串，该字符串来自 TIME_FORMAT 的默认值。

Note

时间过滤器还可以接受预定义的时间变量{{variable|date:"TIME FORMAT"}。预定义时间也由基于表 [3-3](#Tab3) 中语法的时间字符串组成。例如，TIME_FORMAT 默认为“P”(例如，凌晨 4 点)，这可以通过在项目的 settings.py 文件中定义 TIME_FORMAT 来覆盖。

*   `timesince`。-`timesince`过滤器输出一个`datetime`物体和当前时间之间经过的时间。`timesince`过滤器输出以秒、分、小时、天或周表示。例如，如果变量包含`datetime`对象 01/01/2018 12:00pm，当前时间为 01/01/2018 3:30pm，则语句`{{variable|timesince}}`输出 3 小时 30 分钟。`timesince`过滤器还可以通过附加第二个 datetime 对象参数(例如，`{{variable|timesince:othervariable}}`)来计算两个`datetime`对象变量之间经过的时间，而不是默认的当前时间。
*   `timeuntil`。-`timeuntil`过滤器输出从当前时间到`datetime`对象所需的时间。`timeuntil`过滤器输出以秒、分、小时、天或周表示。例如，如果变量包含`datetime`对象 01/01/2018 10:00pm，并且当前时间是 01/01/2018 9:00pm，则语句`{{variable|timeuntil}}`输出 1 小时。`timeuntil`过滤器还可以通过附加第二个`datetime`对象参数(例如`{{variable|timeuntil:othervariable}}`)来计算两个`datetime`对象变量之间需要经过的时间，而不是默认的当前时间。

### 字符串、列表和数字

*   `add`。-`add`过滤器增加数值。`add`过滤器可以添加两个变量或一个硬编码值和一个变量。例如，如果一个变量包含 5，那么过滤语句`{{variable|add:"3"}}`输出 8。如果值可以被强制转换成整数——就像上一个例子一样——`add`过滤器执行一次求和，如果不能，加法过滤器进行连接。对于包含“Hello”的字符串变量，过滤器语句`{{variable|add:" World"}}`输出 Hello World。对于包含['a '，' e '，' i']的列表变量和包含['o '，' u']的列表变量，过滤器语句`{{variable|add:othervariable}}`输出['a '，' e '，' I '，' o '，' u']。
*   `default`。-`default`过滤器用于在变量为假、不存在或为空时指定默认值。例如，如果一个变量在模板中不存在，包含 False 或者是一个空字符串(')，过滤语句`{{variable|default:"no value"}}`输出`no value`。
*   `default_if_none`。-默认过滤器用于指定变量为`None`时的默认值。例如，如果一个变量包含`None`，过滤语句`{{variable|default_if_none:"No value"}}`输出`No value`。注意如果一个变量包含一个空字符串(`''`)，这不被认为是`None`，`default_if_none`过滤器不输出它的参数值。
*   `length`。-`length`过滤器用于获取值的长度。例如，如果一个变量包含字符串`latte`，过滤语句`{{variable|length}}`输出 5。对于包含`['a','e','i']`的列表变量，过滤语句`{{variable|length}}`输出 3。
*   `length_is`。-`length_is`过滤器用于评估值的长度是否是给定参数的大小。例如，如果一个变量包含`latte`，那么标签和过滤器语句`{% if variable|length_is:"7" %}`的计算结果为假。对于包含`['a','e','i']`的列表变量，标签和过滤器语句`{% if variable|length_is:"3" %}`评估为真。
*   `make_list`。-`make_list`过滤器从一个字符串或数字创建一个列表。例如，对于过滤器和标签语句`{% with mycharlist="mocha"|make_list %}`，mycharlist 变量被赋予列表['m '，' o '，' c '，' h '，' a']。对于包含 724 个过滤器和标签语句`{% with myintlist=variable|make_list %}`的整数变量，myintlist 被分配列表['7 '，' 2 '，' 4']。
*   `yesno`。-`yesno`过滤器将来自`True`、`False`和`None`的变量值映射到字符串 yes、no、maybe。例如，如果一个变量评估为`True`，过滤器语句`{{variable|yesno}}`输出 yes，如果该变量评估为`False`，相同的语句输出 no，如果该变量评估为`None`，相同的语句输出 maybe。`yesno`过滤器也接受自定义消息作为参数。例如，如果一个变量的值为`True`，过滤语句`{{variable|yesno:"yea,nay,novote"}}`输出 yea，如果该变量的值为`False`，相同的语句输出 nay，如果该变量的值为`None`，相同的语句输出 novote。

### 民数记

*   `divisibleby`。-`divisibleby`过滤器返回一个布尔值，如果一个变量可以被一个给定值整除。例如，如果一个变量包含 20，过滤语句`{{variable|divisibleby:"5"}}`返回`True`。
*   `filesizeformat`。-`filesizeformat`过滤器将多个字节转换成友好的文件大小字符串。例如，如果一个变量包含 250，过滤语句`{{variable|filesizeformat}}`输出 250 字节，如果它包含 2048，输出是 2 KB，如果它包含 2000000000，输出是 1.9 GB。
*   `floatformat`。-`floatformat`过滤器对浮点数变量进行舍入。`floatformat`过滤器可以接受正整数或负整数参数，将变量四舍五入到特定的小数位数。如果没有使用参数，`floatformat`过滤器会舍入到一个小数位，就像参数 where -1 一样。例如，如果变量包含 9.33253，过滤语句`{{variable|floatformat}}`输出 9.3，对于同一变量`{{variable|floatformat:3}}`输出 9.333，对于`{{variable|floatformat:-3}}`输出 9.333；如果变量包含 9.00000，过滤语句`{{variable|floatformat}}`输出 9，`{{variable|floatformat:3}}`输出 9.000，`{{variable|floatformat:-3}}`输出 9；如果变量包含 9.37000，过滤语句`{{variable|floatformat}}`输出 9.4，`{{variable|floatformat:3}}`输出 9.370，`{{variable|floatformat:-3}}`输出 9.370。
*   `get_digit`。-`get_digit`过滤器输出一个数字变量的数字，其中 1 是最后一个数字，2 是倒数第二个数字，依此类推。例如，如果变量包含 10257，过滤语句`{{variable|get_digit:"1"}}`输出 7，过滤语句`{{variable|get_digit:"3"}}`输出 2。如果变量或自变量不是整数，或者自变量小于 1，则`get_digit`过滤器输出原始变量值。
*   `phone2numeric`。-`phone2numeric`过滤器将电话号码中的助记字母转换成数字。例如，如果变量包含 1-800-DJANGO，过滤器语句`{{variable|phone2numeric}}`输出 1-800-352646。`phone2numeric`过滤器值不一定需要处理有效的电话号码，过滤器只是将字母转换成它们对应的电话键盘号码。

### 用线串

`capfirst`。-`capfirst`过滤器将字符串变量的第一个字符大写。例如，如果变量包含`hello world`，过滤语句`{{variable|capfirst}}`输出`Hello world`。

*   `cut`。-`cut`过滤器从字符串变量中删除给定参数的所有值。例如，如果变量包含`mocha latte`，过滤语句`{{variable|filter:"mocha"}}`输出`latte`。对于同一个变量，过滤语句是`{{variable|filter:" "}}`输出`mochalatte`。
*   `linenumbers`。-`linenumbers`过滤器将行号添加到由新行分隔的每个字符串值中。清单 [3-15](#Par179) 展示了一个`linenumbers`过滤器的例子。

    ```py
    # Variable definition
    Downtown
    Uptown
    Midtown

    # Template definition with linenumbers filter
    {{variable|linenumbers}}

    # Output
    1.Downtown
    2.Uptown
    3.Midtown

    Listing 3-15.Django linenumbers filter

    ```

*   `lower`。-`lower`过滤器将字符串变量的所有值转换成小写。例如，如果一个变量包含`Hello World`，过滤语句`{{variable|lower}}`输出`hello world`。
*   `stringformat`。-`stringformat`过滤器使用 Python 字符串格式语法格式化一个值。 [<sup>4</sup>](#Fn4) 例如，如果一个变量包含`7`，则过滤语句`{{variable|stringformat:"03d"}}`输出`007`。注意`stringformat`过滤器不需要 Python 字符串格式语法中使用的前导`%`。
*   `pluralize`。-`pluralize`过滤器根据参数值返回复数后缀。例如，如果变量`drink_count`包含 1，过滤语句`"You have {{drink_count}} drink{{pluralize|drink_count}}"`输出`"You have 1 drink"`，如果变量包含 2，相同的过滤语句输出`"You have 2 drinks"`。默认情况下，复数过滤器使用字母 s，这是最常见的复数后缀。但是，您可以使用附加参数指定不同的单数和复数后缀。例如，如果`store_count`为 1，则过滤语句`"We have {{store_count}} business{{store_count|pluralize:"es"}}"`输出`"We have 1 business"`，如果`store_count`为 5，则输出`"We have 5 businesses"`。另一个例子是过滤语句`"We have {{resp_number}} responsibilit{{resp_number|pluralize:"y","ies"}}"`，如果`resp_number`为 1，则输出`"We have 1 responsibility"`，如果`resp_number`为 3，则输出`"We have 3 responsibilities"`。
*   `slugify`。-`slugify`过滤器将字符串转换成 ASCII 类型的字符串。这意味着字符串被转换为小写，删除非单词字符(字母数字和下划线)，去除前导和尾随空格，以及将空格转换为连字符。例如，如果一个变量包含`Welcome to the #1 Coffeehouse!`，过滤语句`{{variable|slugify}}`输出`welcome-to-the-1-coffeehouse`。`slugify`过滤器通常用于规范 URL 和文件路径的字符串。
*   `title`。-`title`过滤器将字符串变量的所有第一个字符值转换为大写。例如，如果一个变量包含`hello world`，过滤语句`{{variable|title}}`输出`Hello World`。
*   `truncatechars`。-`truncatechars`过滤器将字符串截断成给定数量的字符，并附加一个省略号序列。例如，如果变量包含`Coffeehouse started as a small store`，过滤语句`{{variable|truncatechars:20}}`输出`Coffeehouse started...`。
*   `truncatechars_html`。-`truncatechars_html`过滤器类似于`truncatechars`过滤器，但是能够识别 HTML 标签。这个过滤器是为 HTML 内容设计的，所以内容不会留下打开的 HTML 标签。例如，如果变量包含`<b>Coffeehouse started as a small store</b>`，过滤语句`{{variable|truncachars_html:20}}`输出`<b>Coffeehouse start...</b>`。
*   `truncatewords`。-`truncatewords`过滤器将字符串截断成给定数量的单词，并附加一个省略号序列。例如，如果一个变量包含`Coffeehouse started as a small store`，过滤语句`{{variable|truncatwords:3}}`输出`Coffeehouse started as...`。
*   `truncatewords_html`。-`truncatewords_html`过滤器类似于`truncatewords`过滤器，但是能够识别 HTML 标签。这个过滤器是为 HTML 内容设计的，所以内容不会留下打开的 HTML 标签。例如，如果变量包含`<b>Coffeehouse started as a small store</b>`，过滤语句`{{variable|truncatwords_html:3}}`输出`<b>Coffeehouse started as...</b>`。
*   `upper`。-`upper`过滤器将字符串变量的所有值转换为大写。例如，如果一个变量包含`Hello World`，过滤语句`{{variable|lower}}`输出`HELLO WORLD`。
*   `wordcount`。-`wordcount`过滤器对字符串中的单词进行计数。例如，如果变量包含`Coffeehouse started as a small store`，过滤语句`{{variable|wordcount}}`输出 6。

### 列表和词典

*   `dictsort`。-`dictsort`过滤器对字典列表进行排序，并返回一个按给定的关键参数排序的新列表。例如，如果一个变量包含`[{'name':'Downtown','city':'San Diego'}, {'name':'Uptown','city':'San Diego'},{'name':'Midtown','city':'San Diego'}]`过滤器和标签语句`{% with newdict=variable|dictsort:"name" %}`，那么`newdict`变量被分配到列表`[{'name':'Downtown','city':'San Diego'},{'name':'Midtown','city':'San Diego'},{'name':'Uptown','city':'San Diego'}]`。`dictsort`过滤器还可以通过指定索引号(例如，{ `% with otherlist=listoftuples|dictsort:0 %}`)对元组列表或列表进行操作，以通过列表中每个元组的第一个元素进行排序。
*   `dictsortreversed`。-`dictsortreversed`过滤器对字典列表进行排序，并返回一个按给定关键参数反向排序的新列表。`dictsortreversed`过滤器的工作方式类似于`dictsort`，只是它以相反的顺序返回列表。
*   `join`。-`join`过滤器用一个字符串连接一个列表。连接过滤器就像 Python 的`str.join(list)`一样工作。例如，对于包含['a '，' e '，' I '，' o '，' u']的列表变量，过滤语句`{{variable|join:"--"}}`输出 a - e - i - o - u。
*   `first`。-`first`过滤器返回列表中的第一项。例如，对于包含['a '，' e '，' I '，' o '，' u']的列表变量，过滤语句`{{variable|first}}`输出一个
*   `last`。-`last`过滤器返回列表中的最后一项。例如，对于包含['a '，' e '，' I '，' o '，' u']的列表变量，过滤语句`{{variable|last}}`输出 u
*   `random`。-`random`过滤器返回一个列表中的随机项目。例如，对于包含['a '，' e '，' I '，' o '，' u']的列表变量，过滤语句`{{variable|random}}`可以输出 a，e，I，o 或 u
*   `slice`。-`slice`过滤器返回列表的片段。例如，对于包含['a '，' e '，' I '，' o '，' u']的列表变量，过滤语句`{{variable|slice:":3"}}`输出['a '，' e '，' i']。
*   `unordered_list`。-`unordered_list`从一个列表变量中输出一个 HTML 无序列表。清单 [3-16](#Par201) 展示了一个无序列表过滤器的例子。

```py
# Variable definition
["Stores",["San Diego",["Downtown","Uptown","Midtown"]]]

# Template definition with linenumbers filter
{{variable|unordered_list}}

# Output
<li>Stores
   <ul>
       <li>San Diego
          <ul>
   <li>Downtown</li>
   <li>Uptown</li>
   <li>Midtown</li>
  </ul>
       </li>
   </ul>
</li>

Listing 3-16.Django unordered_list filter

```

Caution

unordered_list 过滤器的第一级不包括开始或结束 HTML

### 间距和特殊字符

*   `addslashes`。-`addslashes`过滤器向所有引号添加斜线(即，它对引号进行转义)。当 Django 模板用于将数据导出到其他需要转义引号的系统(例如 CSV 文件)时,`addslashes`过滤器非常有用。例如，如果变量包含`Today's news`，过滤语句`{{variable|addslashes}}`输出`Today\'s`新闻。
*   `center`。-`center`过滤器中心对齐一个值并用额外的空白字符填充它，直到它到达给定的字符参数。例如，如果一个变量包含`mocha`，过滤语句`{{variable|center:"15"}}`输出。
*   `"mocha"`。(即，摩卡左边 5 个空格，摩卡 5 个空格，摩卡右边 5 个空格。
*   `ljust`。-`ljust`过滤器左对齐一个值并用额外的空白字符填充它，直到它到达给定的字符参数。例如，如果一个变量包含`mocha`，过滤语句`{{variable|ljust:"15"}}`输出。
*   `"mocha"`。(即 5 个空格用于摩卡，10 个空格填充)。
*   `rjust`。-`rjust`过滤器右对齐一个值并用额外的空白字符填充它，直到它到达给定的字符参数。例如，如果一个变量包含`latte`，过滤语句`{{variable|rjust:"10"}}`输出。
*   `"latte"."`(即 5 个空格填充，5 个空格给拿铁)。
*   `escape`。-`escape`过滤器从一个值中转义 HTML 字符。具体用`escape`滤镜:`<`转换为`&lt;`，`>`转换为`&gt;`，`'`(单引号)转换为`'`，`"`(双引号)转换为`&quot;`，`&`转换为`&amp`。

Tip

如果在连续的变量上使用转义过滤器，用{% autoescape %}标记包装变量会更容易达到相同的结果。

*   `escapejs`。-`escapejs`过滤器将字符转义成通常用于 JavaScript 字符串的 Unicode 字符串。虽然`escapejs`过滤器不能保证字符串 HTML 的安全，但是它可以防止在使用模板生成 JavaScript/JSON 时出现语法错误。例如，如果一个变量包含`mocha\r\n \'price:2.25`，过滤语句`{{variable|escapejs}}`输出`\u0022mocha\u000D\u000A \u0027price:2.25\u0022`。
*   `force_escape`。-`force_escape`过滤器从一个值中转义 HTML 字符，就像`escape`过滤器一样。不同的是`force_escape`被立即应用并返回一个新的转义字符串。当您需要多次转义或想要对转义结果应用其他过滤器时，这很有用。通常，你会使用`escape`滤镜。
*   `linebreaks`。-`linebreaks`过滤器用 HTML 标签替换纯文本换行符，单个换行符变成 HTML 换行符(`<br/>`)，新的一行后面跟一个空行变成段落换行符(`</p>`)。例如，如果变量包含`385 Main\nSan Diego, CA`，过滤语句`{{variable|linebreaks}}`输出`<p>385 Main<br/>San Diego, CA</p>`。
*   `linebreaksbr`。-`linebreaksbr`过滤器将所有文本变量换行符转换成 HTML 换行符(`<br/>`)。例如，如果变量包含`385 Main\nSan Diego, CA`，过滤语句`{{variable|linebreaksbr}}`输出`385 Main<br/>San Diego, CA`。
*   `striptags`。-`striptags`过滤器从一个值中删除所有 HTML 标签。例如，如果一个变量包含`<b>Coffee</b>house, the <i>best</i> <span>drinks</span>`，过滤语句`{{variable|striptags}}`输出`Coffeehouse, the best drinks`。

Caution

striptags 过滤器使用非常基本的逻辑来剥离 HTML 标签。这意味着一段复杂的 HTML 有可能没有完全去掉标签。这就是为什么通过 striptags 过滤器传递的变量中的内容会被自动转义，并且永远不应该被标记为安全的。

*   `safe`。-安全过滤器将字符串标记为不需要 HTML 转义。
*   `safeseq`。-`safeseq`将`safe`过滤器应用于列表的每个元素。它和其他操作列表的过滤器一起使用很有用，比如`join`过滤器(例如`{{stores|safeseq|join:", "}})`)。您不会直接在列表变量上使用`safe`过滤器，因为它会首先将变量转换成字符串，而不是处理列表的单个元素。
*   `wordwrap`。-`wordwrap`过滤器在给定的字符行长度参数处换行。清单 [3-17](#Par224) 展示了一个`wordwrap`过滤器的例子。

```py
# Variable definition

Coffeehouse started as a small store

# Template definition with wordwrap filter for every 12 characters
{{variable|wordwrap:12}}

# Output
Coffeehouse
started as a
small store

Listing 3-17.Django wordwrap filter

```

### 开发和测试

*   `pprint`。-`pprint`过滤器是 Python 的`pprint.pprint()`的包装器。`pprint`过滤器在开发和测试期间很有用，因为它输出对象的格式化表示。

### 资源定位符

*   `iriencode`。-`iriencode`过滤器将国际化资源标识符(IRI)转换成适合包含在 URL 中的字符串。如果您试图在 URL 中使用包含非 ASCII 字符的字符串，这是必要的。例如，如果一个变量包含`?type=cold&size=large`，过滤语句`{{variable|iriencode}}`输出`?type=cold&amp;size=large`。
*   `urlencode`。-`urlencode`过滤器对 URL 中使用的值进行转义。例如，如果一个变量包含`http://localhost/drinks?type=cold&size=large`，过滤语句`{{variable|urlencode}}`输出`http%3A//localhost/drinks%3Ftype%3Dcold%26size%3Dlarge`。`urlenconde`过滤器假设`/`角色是安全的。`urlencode`过滤器可以接受带有不应该转义字符的可选参数。当所有字符都应该转义时，可以提供空字符串(例如，`{{variable|urlencode:""}}`输出`http%3A%2F%2Flocalhost%2Fdrinks%3Ftype%3Dcold%26size%3Dlarge`)。
*   `urlize`。-`urlize`过滤器将文本 URL 或电子邮件地址转换成可点击的 HTML 链接。这个`urlize`过滤器作用于以 http://、https://或 www 为前缀的链接..urlize 过滤器生成的链接添加了一个`rel="nofollow"`属性。例如，如果一个变量包含`Visit http://localhost/drinks`，过滤语句`{{variable|urlize}}`输出`Visit <a href="http://localhost/drinks" rel="nofollow">http://localhost/drinks</a>`；如果变量包含`Contact support@coffeehouse.com`，过滤语句`{{variable|urlize}}`输出`Contact <a href="mailto:support@coffeehouse.com">support@coffeehouse.com</a>`。
*   `urlizetrunc`。—`urlizetrunc`过滤器将文本 url 和电子邮件转换为可点击的 HTML 链接——就像`urlize`过滤器一样——除了它将 URL 截断为给定数量的包含省略号序列的字符。例如，如果变量包含`Visit http://localhost/drinks`，过滤语句`{{variable|urlizetrunc:20}}`输出`Visit <a href="http://localhost/drinks" rel="nofollow">http://localhost/...</a>`。

Caution

urlize 和 urlizetrunc 筛选器应该只应用于纯文本变量。如果应用于带有 HTML 链接的变量，过滤逻辑将不会像预期的那样工作。

## 内置 Django 标签

Django 提供了几个内置标签，可以直接访问 Django 模板上的复杂操作。与对单个变量进行操作的 Django 过滤器不同，标记被设计成在没有变量的情况下产生结果，或者跨模板部分进行操作。

我将把这些内置标签分为不同的功能部分，这样更容易识别它们。我将使用的函数类是日期、表单、比较操作、循环、Python 和过滤器操作、空格和特殊字符、模板结构、开发和测试以及 URL。

### 日期

*   `{% now %}`。-`{% now %}`标签提供对当前系统时间的访问。`{% now %}`标签接受第二个参数来格式化系统日期。例如，如果语句`{% now "F jS o" %}`的系统日期为 2015 年 1 月 1 日，则标签输出为 2015 年 1 月 1 日。`{% now %}`标签的字符串语法基于表 [3-3](#Tab3) 中描述的 Django 日期字符。也可以使用`as`关键字通过变量重用该值(例如`{% now "Y" as current_year %}`和模板声明`Copyright {{current_year}}`)。

Tip

{% now %}标记可以接受 Django 日期变量:{% now "DATE_FORMAT" %} 、{% now "DATETIME_FORMAT" %} 、{% now "SHORT_DATE_FORMAT" %}或{% now "SHORT_DATETIME_FORMAT"}。

日期变量本身也由日期字符串组成。例如，DATE_FORMAT 默认为“N j，Y”(例如，2015 年 1 月 1 日)，DATETIME_FORMAT 默认为“N j，Y，P”(例如，2015 年 1 月 1 日，上午 12 点)，SHORT_DATE_FORMAT 默认为“m/d/Y”(例如，2015 年 1 月 1 日)，SHORT_DATETIME_FORMAT 默认为“m/d/Y P”(例如，2015 年 1 月 1 日，上午 12 点)。在项目的 settings.py 文件中，可以用不同的日期字符串重写每个日期变量。

### 形式

*   `{% csrf_token %}`。-`{% csrf_token %}`标签提供了一个字符串来防止跨站脚本。`{% csrf_token %}`标签仅用于 HTML `<form>`标签中。`{% csrf_token %}`标签的数据输出允许 Django 防止表单数据提交中的伪造请求(例如 HTTP POST 请求)。Django 表单一章中提供了关于`{% csrf_token %}`标签的更多细节。

### 比较操作

*   `{% if %}`同`{% elif %} {% else %}`。-`{% if %}`标签通常与`{% elif %}`和`{% else %}`标签结合使用，以评估多个条件。如果变量存在且不为空，或者如果变量持有一个`True`布尔值，则带有自变量变量的`{% if %}`标签评估为真。清单 [3-18](#Par243) 展示了一系列`{% if %}`标签示例。

    ```py
    {% if drinks %}             {% if drinks %}              {% if drinks %}
      We have drinks!                We have drinks              We have drinks
    {% endif %}                 {% else %}                   {% elif drinks_on_sale %}
                                    No drinks,sorry              We have drinks on sale!
                                {% endif %}                  {% else %}
                                                               No drinks, sorry
                                                             {% endif %}
    Listing 3-18.Django {% if %} tag with {% elif %} and {% else %}

    ```

Note

变量必须既存在又不为空才能计算为 true。仅存在且为空的变量的计算结果为 false。

*   `{% if %}`带`and`、`or`和`not`操作符。-`{% if %}`标签还支持`and`、`or`和`not`操作符来创建更复杂的条件。这些运算符允许您比较是否有多个变量不为空(如`{% if drinks and drinks_on_sale %}`)，是否有一个或另一个变量不为空(如`{% if drinks or drinks_on_sale %}`)，或者是否有一个变量为空(如`{% if not drinks %}`)。
*   `{% if %}`带`==`、`!=`、`<`、`>`、`<=`和`>=`操作符。-`{% if %}`标签还支持等于、不等于、大于和小于运算符，以创建将变量与固定字符串或数字进行比较的条件。这些运算符允许您比较变量是否等于字符串或数字(如`{% if drink == "mocha" %}`)、变量是否不等于变量或数字(如`{% if store.id != 2 %}`)或变量是否大于或小于数字(如`{% if store.id > 5 %}`)。
*   `{% firstof %}`。-`{% firstof %}`标记是一个简写标记，用于输出一组非空变量中的第一个变量。通过嵌套`{% if %}`标签可以实现`{% firstof %}`标签的相同功能。清单 [3-19](#Par249) 展示了{ `% firstof %}`标签的一个示例，以及一组等价的嵌套`{% if %}`标签。

    ```py
    # Firstof example
    {% firstof var1 var2 var3 %}

    # Equivalent of firstof example
    {% if var1 %}
        {{var1|safe}}
    {% elif var2 %}
        {{var2|safe}}
    {% elif var3 %}
        {{var3|safe}}
    {% endif %}

    # Firstof example with a default value in case of no match (i.e, all variables are empty)
    {% firstof var1 var2 var3 "All vars are empty" %}

    # Assign the firstof result to another variable
    {% firstof var1 var2 var3 as resultof %}
    # resultof now contains result of firstof statement

    Listing 3-19.Django {% firstof %} tag and equivalent {% if %}{% elif %}{% else %} tags

    ```

*   `{% if <value> in %}`和`{% if <value> not in %}`。-`{% if %}`标签还支持`in`和`not in`操作符来验证常量或变量的存在。例如，`{% if "mocha" in drinks %}`测试值`"mocha"`是否在`drinks`列表变量中，或者`{% if 2 not in stores %}`测试值`2`是否不在`stores`列表变量中。虽然`in`和`not in`操作符通常用于测试列表变量，但是也可以测试字符串中是否存在字符(例如`{% if "m" in drink %}`)。此外，还可以比较一个变量的值是否出现在另一个变量中(如`{% if order_drink in drinks %}`)。
*   `{% if <value> is <value> %}`和`{% if <value> is not %}`。-`{% if %}`标签还支持`is`和`is not`操作符进行对象级比较。例如，`{% if target_drink is None %}`测试值`target_drink`是否是一个`None`对象，或者`{% if daily_special is not True %}`测试值`daily_special`是否不是`True`。
*   `{% if value|<filter> <condition> <value> %}`。-`{% if %}`标签还支持直接对一个值应用过滤器，然后执行评估。例如，`{% if target_drink_list|random == user_drink %}Congratulations your drink just got selected!{% endif %}`在一个条件中直接使用`random`过滤器。

Parentheses are Not Allowed in If Tags: Operator Precedence Governs, Use Nested If Tags to Alter Precedence

比较运算符通常被聚合到单个语句中(例如，if...<...or...>...和...==...)并遵循一定的执行优先级。Django 遵循与 Python 相同的操作符优先级。 [<sup>5</sup>](#Fn5) 例如，语句{ % if drink in specials or drink == drink _ of _ the _ day % }的计算结果为((drink in specials)or(drink = = drink _ of _ the _ day))，其中首先运行内部括号运算，因为 in 和= =的优先级高于 or。

在 Python 中，可以通过在比较语句中使用显式括号来改变这种优先级。但是，Django 不支持在{% if %}标记中使用括号，您必须依赖操作符优先级或者使用嵌套的{% if %}语句来声明由显式括号产生的相同逻辑。

### 环

*   `{% for %}`和`{% for %}`同`{% empty %}`。-`{% for %}`标签遍历字典、列表、元组或字符串变量上的项目。`{% for %}`标签语法是`{% for <reference> in <variable> %}`，其中`reference`在每次迭代中被赋予一个来自变量的新值。

根据变量的性质，可以有一个或多个引用(例如，对于列表一个引用`{% for item in list %}`，对于字典两个引用`{% for key,value in dict.items %}`)。此外，也可以用`reversed`关键字(例如{ `% for item in list reversed %}`)反转循环顺序。`{% for %}`标签还支持`{% empty %}`标签，在循环中没有迭代的情况下(即主变量为空)会处理该标签。清单 [3-20](#Par259) 展示了一个`{% for %}`和一个`{% for %}`和`{% empty %}`循环示例。

```py
<ul>                                 <ul>
{% for drink in drinks %}             {% for storeid,store in stores %}
 <li>{{ drink.name }}</li>            <li><a href="/stores{{storeid}}/">{{store.name}}</a></li>
{% empty %}                           {% endfor %}
 <li>No drinks, sorry</li>           </ul>
{% endfor %}
</ul>
Listing 3-20.Django {% for %} tag and {% for %} with {% empty %}

```

`{% for %}`标签还生成一系列变量来管理迭代过程，例如迭代计数器、第一次迭代标志和最后一次迭代标志。当您想要在给定的迭代中创建行为(例如，格式化、附加处理)时，这些变量会很有用。表 [3-4](#Tab4) 说明了`{% for %}`标签变量。

*   `{% ifchanged %}`。-`{% ifchanged %}`标签是在`{% for %}`标签中使用的特殊逻辑标签。有时，了解循环引用是否从一个迭代更改到另一个迭代(例如，插入新标题)会很有帮助。`{% ifchanged %}`标签的参数是循环引用本身(如`{% ifchanged drink %}{{drink}} section{% endifchanged %}`)或引用的一部分(如`{% ifchanged store.name %}Available in {{store.name}}{% endifchanged %}`)。`{% ifchanged %}`标签也支持使用`{% else %}`标签(例如`{% ifchanged drink %}{{drink.name}}{% else %}Same old {{drink.name}} as before{% endifchanged %}`)。
*   `{% cycle %}`。-`{% cycle %}`标签被用在`{% for %}`标签中来迭代一组给定的字符串或变量。标签的主要用途之一是定义 CSS 类，这样每次迭代都会收到不同的 CSS 类。例如，如果你想给一个列表分配不同的 CSS 类，这样每一行以不同的颜色出现(例如，白色，灰色，白色，灰色)，你可以使用`<li class="{% cycle 'white' 'grey' %}">`，这样在每次循环迭代中类值在白色和灰色之间交替。`{% cycle %}`标签可以顺序迭代任意数量的字符串或变量(例如`{% cycle var1 var2 'red' %}`)。

表 3-4。

Django {% for %} tag variables

<colgroup><col> <col></colgroup> 
| 可变的 | 描述 |
| --- | --- |
| forloop .柜台 | 循环的当前迭代(1 索引) |
| forloop.counter0 | 循环的当前迭代(索引为 0) |
| forloop.revcounter | 从循环结束开始的迭代次数(1-索引) |
| forloop.revcounter0 | 从循环结束开始的迭代次数(索引为 0) |
| forloop.first | 如果是第一次通过循环，则为 True |
| forloop.last | 如果是最后一次循环，则为真 |
| 渐变.括号 | 对于嵌套循环，这是当前循环的父循环 |

默认情况下，`{% cycle %}`标签根据其封闭循环遍历其值(即，一个接一个)。但是在某些情况下，你可能需要在循环之外使用一个`{% cycle %}`标签或者明确声明一个`{% cycle %`标签如何前进。您可以通过用`as`关键字命名`{% cycle %}`标签来实现这种行为，如清单 [3-21](#Par264) 所示。

```py
<li class="{% cycle 'disc' 'circle' 'square' as bullettype %}">...</li>
<li class="{{bullettype}}">...</li>
<li class="{{bullettype}}">...</li>
<li class="{% cycle bullettype %}">...</li>
<li class="{{bullettype}}">...</li>
<li class="{% cycle bullettype %}">...</li>
# Outputs
<li class="disc">...</li>
<li class="disc">...</li>
<li class="disc">...</li>
<li class="circle">...</li>
<li class="circle">...</li>
<li class="square">...</li>
Listing 3-21.Django {% cycle %} with explicit control of progression

```

正如您在清单 [3-21](#Par264) 中看到的，`{% cycle %}`标记语句最初产生第一个值，然后您可以继续使用循环引用名来输出相同的值。为了前进到循环中的下一个值，您用循环引用名再次调用`{% cycle %}`。`{% cycle %}`标签的一个小副作用是它在声明的地方输出初始值，如果你打算把循环作为占位符或者在嵌套循环中使用，这可能会有问题。为了避免这种副作用，您可以在循环引用名称后使用`silent`关键字(例如，{ `% cycle 'disc' 'circle' 'square' as bullettype silent %}`)。

*   `{% resetcycle %}`。—`{% resetcycle %}`标签用于将`{% cycle %}`标签重新初始化到其第一个元素。在返回到第一个值之前，`{% cycle %}`标签总是在它的整个值集上循环，这在嵌套循环的上下文中是有问题的。例如，如果您想要为嵌套组分配三个颜色代码(如`{% cycle 'red' 'orange' 'yellow' %}`)，第一个组可以由两个元素组成，这两个元素用完了前两个循环值(如“红色”和“橙色”)，这意味着第二个组从第三个颜色代码(如“黄色”)开始。为了让第二个组再次从第一个`{% cycle %}`元素开始，您可以在嵌套循环迭代完成后使用`{% resetcycle %}`标签，这样`{% cycle %}`标签就会返回到它的第一个元素。
*   `{% regroup %}`。-`{% regroup %}`标签用于将字典变量的内容重新排列到不同的组中。`{% regroup %}`标签避免了在`{% for %}`标签内创建复杂条件来实现所需显示的需要。`{% regroup %}`标签预先安排了字典的内容，使得`{% for %}`标签的逻辑更加简单。清单 [3-22](#Par268) 展示了一个使用`{% regroup %}`标签及其输出的字典。

```py
# Dictionary definition
stores = [
    {'name': 'Downtown', 'street': '385 Main Street', 'city': 'San Diego'},
    {'name': 'Uptown', 'street': '231 Highland Avenue', 'city': 'San Diego'},
    {'name': 'Midtown', 'street': '85 Balboa Street', 'city': 'San Diego'},
    {'name': 'Downtown', 'street': '639 Spring Street', 'city': 'Los Angeles'},
    {'name': 'Midtown', 'street': '1407 Broadway Street', 'city': 'Los Angeles'},
    {'name': 'Downton', 'street': '50 1st Street', 'city': 'San Francisco'},
]

# Template definition with regroup and for tags
{% regroup stores by city as city_list %}

<ul>
{% for city in city_list %}
    <li>{{ city.grouper }}
    <ul>
        {% for item in city.list %}
          <li>{{ item.name }}: {{ item.street }}</li>
        {% endfor %}
    </ul>
    </li>
{% endfor %}
</ul>

# Output
San Diego
    Downtown : 385 Main Street
    Uptown : 231 Highland Avenue
    Midtown : 85 Balboa Street
Los Angeles
    Downtown: 639 Spring Street
    Midtown: 1407 Broadway Street
San Francisco
    Downtown: 50 1st Street

Listing 3-22.Django {% for %} tag and {% regroup %}

```

Tip

{% regroup %}标记也可以使用筛选器或属性来获得分组结果。例如， [3-22](#Par268) 中的商店列表可以方便地按城市预先排序，从而自动按城市进行分组，但是如果商店列表没有预先排序，您需要先按城市对列表进行排序，以避免分组不完整，您可以直接使用 dictsort 过滤器(例如，{ % regroup stores | dict sort:' city ' by city as city _ list % })。{% regroup %}标记的另一种可能性是使用嵌套属性，如果分组对象有嵌套属性(例如，如果 city 有一个 state 属性{ % regroup stores by city . state as state _ list % })。

### Python 和过滤器操作

*   `{% filter %}`。-`{% filter %}`标签用于将 Django 过滤器应用于模板部分。如果你声明了`{% filter lower %}`，那么`lower`过滤器将应用于这个标签和`{% endfilter %}`标签之间的所有变量——注意过滤器`lower`将所有内容转换成小写。也可以使用相同的管道技术将多个过滤器应用到同一个部分，以将过滤器链接到变量(例如`{% filter lower|center:"50" %}...variables to convert to lower case and center...{% endfilter %}`)。
*   `{% with %}`。-`{% with %}`标签允许您在 Django 模板的上下文中定义变量。当您需要为 Django view 方法没有公开的值创建变量时，或者当一个变量与一个重量级操作相关联时，这很有用。也可以在同一个`{% with %}`标签中定义多个变量(例如`{% with drinkwithtax=drink.cost*1.07 drinkpromo=drink.cost*0.85 %}`)。在到达`{% endwith %}`标签之前，`{% with %}`标签中定义的每个变量都可供模板使用。

Python Logic Only Allowed Behind the Scenes in Custom Django Tags or Filters

Django 模板不允许包含内联 Python 逻辑。事实上，Django 模板允许内联 Python 逻辑的最接近的方式是通过{% with %}标记，这并不复杂。

让自定义 Python 逻辑在 Django 模板中工作的唯一方法是将代码嵌入到自定义 Django 标签或过滤器中。这样，您可以在模板上放置一个定制的 Django 标签或过滤器，Python 逻辑在后台运行。下一节将描述如何创建定制的 Django 过滤器。

### 间距和特殊字符

*   `{% autoescape %}`。-`{% autoescape %}`标签用于对模板部分的 HTML 字符进行转义。`{% autoescape %}`接受两个参数`on`或`off`中的一个。使用`{% autoescape on %}`时，该标签和`{% endautoescape %}`标签之间的所有模板内容都被 HTML 转义，而使用`{% autoescape off %}`时，该标签和`{% endautoescape %}`标签之间的所有模板内容都不被转义。

Tip

如果您想要全局启用或禁用自动转义(即，在所有模板上)，更容易的方法是使用项目 settings.py 文件中模板配置的 OPTIONS 变量中的 autoescape 字段在项目级别禁用它，如本章第一节所述。

如果您想要启用或禁用单个变量的自动转义，您可以使用 safe 过滤器禁用单个 Django 模板变量的自动转义，或者使用 escape 过滤器对单个 Django 模板变量进行转义。

*   `{% spaceless %}`。-`{% spaceless %}`标签删除 HTML 标签之间的空白，包括制表符和换行符。因此，`{% spaceless %}`和`{% endspaceless %}`中包含的所有 HTML 内容变得更加紧凑。注意`{% spaceless %}`标签只移除 HTML 标签之间的空间，它不移除文本和 HTML 标签之间的空间(例如`<p> <span> my span </span> </p>`，只移除`<p> <span>`和`</span> </p>`标签之间的空间，填充`myspan`字符串的`<span>`标签之间的空间保留)。
*   `{% templatetag %}`。-`{% templatetag %}`标签用于输出保留的 Django 模板字符。因此，如果您想在模板上逐字显示任何字符`{%`、`%}`、`{{`、`}}`、`{`、`}`、`{#`或`#}`，您可以这样做。`{% templatetag %}`与八个参数中的一个结合使用来表示 Django 模板字符。`{% templatetag openblock %}`输出`{%`，`{% templatetag closeblock %}`输出`%}`，`{% templatetag openvariable %}`输出`{{`，`{% templatetag closevariable %}`输出`}}`，`{% templatetag openbrace %}`输出`{`，`{% templatetag closebrace %}`输出`}`，`{% templatetag opencomment %}`输出`{#`，`{% templatetag closecomment %}`输出`#}`。一种更简单的方法是用`{% verabtim %}`标签包装保留的 Django 字符。
*   `{% verbatim %}`。-`{% verbatim %}`标签用于隔离正在处理的模板内容。Django 会绕过`{% verbatim %}`标签和`{% endverbatim %}`标签中的任何内容。这意味着像`{{`这样的特殊字符，像`{{drink}}`这样的变量语句，或者使用特殊 Django 字符的 JavaScript 逻辑将被忽略并逐字呈现。如果需要输出单个特殊字符，使用`{% templatetag %}`标签。
*   `{% widthratio %}`。-`{% widthratio %}`标签用于计算一个值与最大值的比值。`{% widthratio %}`标签有助于显示宽度固定但需要根据可用空间大小进行缩放的内容，例如图像和图表。例如，给定语句`<img src="logo.gif" style="width:{% widthratio available_width image_width 100 %}%"/>`，如果`available_width`是 75，而`image_width`是 150，则 0.50 乘以 100 得到 50。该图像的宽度比是根据可用空间和图像大小计算的，在这种情况下，该语句被呈现为:`<img src="logo.gif" style="width:50%"/>`。
*   `{% lorem %}`。-`{% lorem %}`标签用于显示随机的拉丁文本，这对模板上的填充符很有用。`{% lorem %}`标签支持多达三个参数`{% lorem [count] [method] [random] %}`。其中`[count]`是要生成的段落数或字数的数字或变量，如果未提供，默认`[count]`为 1。其中`[method]`是单词的`w`、HTML 段落的`p`或纯文本段落块的`b`，如果没有提供，默认`[method]`是`b`。并且其中单词`random`(如果给定的话)输出随机的拉丁单词，而不是公共模式(例如，Lorem ipsum dolor sit amet...).

### 模板结构

*   `{% block %}`。-`{% block %}`标签用于定义可以在不同 Django 模板上覆盖的页面部分。请参阅本章上一节如何创建可重用模板，以获取该标签的示例。
*   `{% comment "Optional explanation" %}`。-`{% comment %}`标签用于定义 Django 模板上的注释部分。Django 会绕过放置在`{% comment %}`和`{% endcomment %}`标签之间的任何内容，这些内容不会出现在最终呈现的网页中。注意开始的`{% comment %}`标签中的字符串参数是可选的，但是有助于澄清注释的目的。
*   `{# #}`。-`{# #}`语法可以用于 Django 模板上的单行注释。Django 会绕过单行中位于`{#`和`#}`之间的任何内容，这些内容不会出现在最终呈现的网页中。注意，如果注释跨越多行，你应该使用`{% comment %}`标签。
*   `{% extends %}`。-`{% extends %}`标签用于重用另一个 Django 模板的布局。参见本章上一节关于创建可重用模板的例子。
*   `{% include %}`。-`{% include %}`标签用于将一个 Django 模板嵌入到另一个 Django 模板中。参见本章上一节关于创建可重用模板的例子。
*   `{% load %}`。-`{% load %}`标签用于加载自定义 Django 标签和过滤器。`{% load %}`标签需要一个或多个参数作为自定义 Django 标签或过滤器的名称。本章的下一节将描述如何创建自定义过滤器以及如何使用`{% load %}`标签。

Tip

如果您发现自己在许多模板上使用{% load %}标记，您可能会发现用模板中的 builtins 选项注册 Django 标记和过滤器更容易，这样它们就可以在所有模板上访问，就像它们是内置的一样。有关详细信息，请参见本章中关于模板配置的第一节。

### 开发和测试

*   `{% debug %}`。-`{% debug %}`标签输出包括模板变量和导入模块的调试信息。`{% debug %}`标签在开发和测试期间很有用，因为它输出 Django 模板使用的“幕后”信息。

### 资源定位符

*   `{% url %}`。-`{% url %}`标签用于从项目的`urls.py`文件中的预定义值构建 URL。`{% url %}`标签很有用，因为它避免了在模板上硬编码 URL 的需要，而是基于名称插入 URL。`{% url %}`标签接受一个 url 名称作为第一个参数，url 参数作为后续参数。

比如一个 url 指向`/drinks/index/`，命名为`drinks_main`，可以用`{% url %}`引用这个 url(如`<a href="{% url drinks_main %}"> Go to drinks home page </a>`)；如果一个 url 指向`/stores/1/`并且被命名为`stores_detail`，你可以使用`{% url %}`和一个参数来引用这个 url(例如`<a href="{% url stores_detail store.id %}"> Go to {{store.name}} page </a>`)。

`{% url %}`标签还支持`as`关键字，将结果定义为一个变量。这允许结果被多次使用，或者在声明了`{% url %}`标签以外的地方使用(例如`{% url drink_detail drink.name as drink_on_the_day%}`...后来在模板`<a href="{{drink_of_the_day}}> Drink of the day </a>`。第 2 章[详细描述了命名 Django url 的过程，以便于管理和反向匹配。](02.html)

## 自定义过滤器

有时候，Django 内置的过滤器在逻辑或输出方面有所欠缺。在这些情况下，解决方案是编写一个自定义筛选器来实现您需要的结果。

Django 过滤器背后的逻辑完全是用 Python 编写的，因此使用 Python & Django 可以实现的任何功能(例如，执行数据库查询、使用第三方 REST 服务)都可以集成为定制过滤器生成的逻辑或输出的一部分。

### 结构

最简单的定制 Django 过滤器只需要你创建一个标准的 Python 方法并用`@register.filter()`修饰它，如清单 [3-23](#Par302) 所示。

```py
from django import template
register = template.Library()

@register.filter()
def boldcoffee(value):
    '''Returns input wrapped in HTML  tags'''
    return '<b>%s</b>' % value

Listing 3-23.Django custom filter with no arguments

```

清单 [3-23](#Par302) 首先导入`template`包，创建一个`register`引用来修饰`boldcoffee`方法，并告诉 Django 从中创建一个自定义过滤器。

默认情况下，筛选器接收与修饰方法相同的名称。所以在这种情况下，`boldcoffee`方法创建了一个名为`boldcoffee`的过滤器。方法输入`value`代表过滤器调用者的输入。在这种情况下，该方法只是返回包装在 HTML `<b>`标记中的输入值，其中 return 语句中使用的语法是标准的 Python 字符串格式操作。

要在 Django 模板中应用这个定制过滤器，可以使用语法`{{byline|boldcoffee}}`。`byline`变量作为`value`参数传递给过滤器方法，所以如果`byline`变量包含文本`Open since 1965!`，过滤器输出就是`<b>Open since 1965!</b>`。

Django 定制过滤器也支持包含参数，如清单 [3-24](#Par307) 所示。

```py
@register.filter()
def coffee(value,arg="muted"):
    '''Returns input wrapped in HTML  tags with a CSS class'''
    '''Defaults to CSS class 'muted' from Bootstrap'''
    return '<span class="%s">%s</span>' % (arg,value)
Listing 3-24.Django custom filter with arguments

```

清单 [3-24](#Par307) 中的过滤方法有两个输入参数。代表应用过滤器的变量的参数`value`和第二个参数`arg="muted"`，其中`"muted"`代表默认值。如果您查看 return 语句，您会注意到它使用了`arg`变量来定义一个`class`属性，而`value`变量用于定义一个`<span>`标签内的内容。

如果使用与第一个定制过滤器相同的语法调用清单 [3-24](#Par307) 中的定制过滤器(例如`{{byline|coffee}}`)，输出默认使用`"muted"`作为`arg`变量，最终输出为`<span class="muted">Open since 1965!</span>`。

然而，您也可以调用清单 [3-24](#Par307) 中的过滤器，使用一个参数覆盖`arg`变量。过滤参数附加有`:`。例如，过滤器语句{ `{byline|coffee:"lead muted"}}`将`"lead muted"`指定为`arg`变量的值，并产生输出`<span class="lead muted">Open since 1965!</span>`。

参数为自定义过滤器提供了更大的灵活性，因为它们可以用不同于主输入的数据进一步影响最终输出。

Tip

如果筛选器需要两个或更多参数，您可以在筛选器定义中使用空格分隔或 CSV 类型的字符串参数(例如，byline|mymultifilter:"18，success，green，2em ")，然后在 filter 方法中解析该字符串以访问每个参数。

### 选项:命名、HTML 和进出的内容

尽管前面的两个例子说明了定制过滤器的核心结构，但是它们缺少一系列使定制过滤器更加灵活和强大的选项。表 [3-5](#Tab5) 展示了一系列自定义过滤器选项，以及它们的语法和功能描述。

表 3-5。

Custom filter options.

<colgroup><col> <col> <col></colgroup> 
| 选项语法 | 价值观念 | 描述 |
| --- | --- | --- |
| @register.filter(name= <method_name>)</method_name> | 命名过滤器的一个刺 | 指定不同于筛选方法名称的筛选名称。 |
| @register.filter(is_safe=False) | 对/错 | 定义如何处理过滤器的返回值(安全或带自动转义)。 |
| @ register . filter(needs _ auto escape = False) | 对/错 | 定义访问调用者的自动转义状态的需要(即，是否在带有或不带有自动转义的模板中调用过滤器)。 |
| @ register . filter(expects _ local time = False) | 对/错 | 如果筛选器应用于日期时间值，则在运行筛选器逻辑之前，它会将该值转换为项目时区。 |
| @ register . filter()@ string filter | 不适用的 | 将输入转换为字符串的独立装饰器。 |

正如你在表 [3-5](#Tab5) 中看到的，除了一个选项，所有的自定义过滤器选项都由`@register.filter()`装饰器的参数提供，并且包括默认值。因此，即使您声明了一个空的`@register.filter()`装饰器，表 [3-5](#Tab5) 中五个选项中的四个都使用默认值。注意可以给`@register.filter()`装饰器添加多个选项，用逗号分隔(例如`@register.filter(name='myfilter',is_safe=True)`)。

下面说说表 [3-5](#Tab5) 中的`name`选项。默认情况下，正如您在前面的例子中所了解到的，自定义过滤器的名称与它们修饰的方法相同(也就是说，如果自定义过滤器的后台方法被命名为`coffee`，那么该过滤器也被称为`coffee`)。`name`选项允许您给过滤器一个不同于支持方法名称的名称。注意，如果使用`name`选项并试图用方法名调用过滤器，你会得到一个错误，因为过滤器不再以方法名存在。

所有自定义过滤器都在由变量提供的输入上操作，这些变量可能是任何 Python 类型(字符串、整数、日期时间、列表、字典等)。).这产生了必须在定制过滤器的逻辑中处理的多种可能性；否则，错误必然是常见的(例如，使用整数变量调用过滤器，但内部过滤器逻辑是为字符串变量设计的)。为了缓解这些潜在的输入类型问题，自定义过滤器可以使用表 [3-5](#Tab5) 中给出的最后两个选项。

表 [3-5](#Tab5) 中的`expects_localtime`选项是为操作`datetime`变量的过滤器设计的。如果你期待一个`datetime`输入，你可以将`expects_localtime`设置为`True`，这使得`datetime`输入时区基于你的项目设置而被感知。

表 [3-5](#Tab5) 中的`@stringfilter`选项——是一个独立的装饰器，位于`@register.filter`装饰器的下方——设计用于将过滤器输入变量转换为字符串。这是有帮助的，因为它消除了执行输入类型检查的需要，并且不管过滤器被调用的变量类型是什么(例如，字符串、整数、列表或字典变量)，过滤器逻辑都可以确保它将总是获得字符串。

由于表 [3-5](#Tab5) 中的`is_safe`选项默认为`False`，自定义过滤器的一个微妙但默认的行为是输出被认为是不安全的。

这个默认设置使得来自包含 HTML `<b>`或`<span>`标签的清单 [3-23](#Par302) 和 [3-24](#Par307) 的定制过滤器创建逐字输出(也就是说，您不会看到以粗体显示的文本，而是逐字显示的`<b>Open since 1965!</b>`)。有时这是想要的行为，但有时不是。

Tip

要使 Django 模板在使用默认设置应用自定义过滤器后呈现 HTML 字符，您可以使用内置的`safe`过滤器(例如`{{byline|coffee|safe}}`)或使用内置的`{% autoescape %}`标签(例如`{% autoescape off %} {{byline|coffee}} {% endautoescape %}`标签)包围过滤器声明。然而，Django filters 也可以将 filter is_safe 选项设置为 True，以使该过程自动化，并避免使用额外的过滤器或标记。

您可以将自定义过滤器中的`is_safe`选项设置为`True`，以确保自定义过滤器输出“按原样”呈现(例如，`<b>`标签以粗体显示)，并且 HTML 元素不会被转义。

这种过滤器设计方法做了一个很大的假设:自定义过滤器总是用包含安全内容的变量来调用。如果`byline`变量包含文本`Open since 1965 & serving > 1000 coffees day!`会发生什么？变量现在包含了不安全的字符`&`和`>`，为什么它们是不安全的？因为它们在 HTML 中有特殊的含义，如果不转义，就有可能破坏页面布局(例如，>在这个上下文中可能意味着“不止”，但在 HTML 中它也意味着标签打开，浏览器可以将其解释为标记，从而破坏页面，因为它从未关闭)。

为了避免标记不安全的输入字符并在输出时将其标记为安全的潜在问题，您需要依靠调用模板来告诉过滤器输入是安全的还是不安全的，这将我们带到表 [3-5](#Tab5) : `needs_autoescape.`中的最后一个自定义过滤器选项

`needs_autoescape`选项——默认为 False——用于通知过滤器调用模板中的底层自动转义设置。清单 [3-25](#Par326) 显示了一个使用这个选项的过滤器。

```py
from django import template
from django.utils.html import escape
from django.utils.safestring import mark_safe

register = template.Library()

@register.filter(needs_autoescape=True)
def smartcoffee(value, autoescape=True):
    '''Returns input wrapped in HTML tags'''
    '''and also detects surrounding autoescape on filter (if any) and escapes '''
    if autoescape:
        value = escape(value)
    result = '<b>%s</b>' % value
    return mark_safe(result)

Listing 3-25.Django custom filter that detects autoescape setting

```

filter 方法的`needs_autoescape`参数和`autoescape`关键字参数允许过滤器知道在调用过滤器时转义是否有效。如果自动转义开启，那么`value`通过`escape`方法来转义所有字符。无论 value 的内容是否转义，过滤器都通过`mark_safe`方法传递最终结果，因此 HTML `<b>`标签在模板中被解释为粗体。

这个过滤器比使用`is_safe=True`选项的过滤器更健壮——并且将所有东西都标记为“安全”——因为它可以处理不安全的输入，只要模板用户正确使用自动转义。

### 安装和进入

Django 自定义过滤器可以存储在以下两个位置之一:

*   内部应用程序。-储存在。py 文件位于 Django apps 中一个名为`templatetags`的文件夹中。
*   任何项目位置。-储存在。通过`settings.py.`中`TEMPLATES`变量的`OPTIONS`中的`libraries`域配置 Django 项目中任意文件夹下的 py 文件

清单 [3-26](#Par333) 展示了一个项目目录结构，举例说明了存储定制过滤器的这两个位置。

```py
+-<PROJECT_DIR_project_name>
|
+-__init__.py
+-settings.py
+-urls.py
+-wsgi.py
|
+----common----+
|              |
|              +--coffeehouse_filters.py
|
+----<app_one>---+
|                |
|                +-__init__.py
|                +-models.py
|                +-tests.py
|                +-views.py
|                +-----------<templatetags>---+
|                                              |
|                                              +-__init__.py
|                                              +-store_format_tf.py
+----<app_two>---+
|                |
                 +-__init__.py
                 +-models.py
                 +-tests.py
                 +-views.py
                 +-----------<templatetags>---+
                                               |
                                              +-__init__.py
                                               +-tax_operations.py
Listing 3-26.Django custom filter directory structure

```

清单 [3-26](#Par333) 显示了两个应用程序，它们在两个不同的文件中包含 Django 定制过滤器- `store_formay.tf.py`和`tax_operations.py`。请记住，您需要在 Django app 文件夹中手动创建`templatetags`文件夹，还需要创建一个`__init__.py`文件，以便 Python 能够从这个文件夹中导入模块。此外，记住需要在 Django 的`settings.py`内的`INSTALLED_APPS`变量中定义应用程序，以便加载自定义过滤器。

在清单 [3-26](#Par333) 中还有一个。py 文件- `coffeehouse_filters.py` -也包含 Django 自定义过滤器。最后一个定制过滤器文件是不同的，因为它位于一个名为`common`的通用文件夹中。为了让 Django 在一个通用位置找到一个定制的过滤器文件，您必须将它声明为`settings.py`中`TEMPLATES`变量的`OPTIONS`中`libraries`字段的一部分。有关使用“库”字段的详细说明，请参阅本章的第一节。

尽管自定义滤镜通常根据其功能放入文件和应用程序中，但这并不限制自定义滤镜在特定模板中的使用。您可以在任何 Django 模板上使用定制过滤器，而不管定制过滤器存储在哪里。

要在 Django 模板中使用 Django 定制过滤器，你需要在 Django 模板中使用`{% load %}`标签，如清单 [3-27](#Par338) 所示。

```py
{% load store_format_tf %}
{% load store_format_t tax_operations %}
{% load undercoffee from store_format_tf %}
Listing 3-27.Configure Django template to load custom filters

```

如清单 [3-27](#Par338) 所示，有多种方式可以使用`{% load %}`标签。您可以使自定义文件中的所有过滤器对模板可用。py 在`{% load %}`标记语法中——或者一次包含多个定制文件。此外，您还可以使用类似 Python 的语法`load filter from custom_file`有选择地加载某些过滤器。记住`{% load %}`标签应该在模板的顶部声明。

Tip

如果您发现自己经常使用{% load %}标记，那么您可以使用 builtins 字段使定制过滤器对所有模板都可用。builtins 字段是 settings.py 中 TEMPLATES 变量选项的一部分。有关使用 builtins 字段的详细说明，请参见本章第一节 Django 模板配置。

Footnotes [1](#Fn1_source)

[T2`https://en.wikipedia.org/wiki/Escape_character`](https://en.wikipedia.org/wiki/Escape_character)

  [2](#Fn2_source)

[T2`https://www.python.org/dev/peps/pep-0263/`](https://www.python.org/dev/peps/pep-0263/)

  [3](#Fn3_source)

[T2`https://docs.python.org/3/library/codecs.html#standard-encodings`](https://docs.python.org/3/library/codecs.html#standard-encodings)

  [4](#Fn4_source)

[T2`https://docs.python.org/3/library/stdtypes.html#old-string-formatting`](https://docs.python.org/3/library/stdtypes.html#old-string-formatting)

  [5](#Fn5_source)

[T2`https://docs.python.org/3/reference/expressions.html#evaluation-order`](https://docs.python.org/3/reference/expressions.html#evaluation-order)