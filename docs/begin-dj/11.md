# 11.Django 行政管理

Django admin 是一个用户友好的应用程序，用于管理链接到 Django 项目的关系数据库的内容。尽管 Django admin 在设置方面几乎毫不费力——如第 [1](01.html) 章所述——但在这一章中你将学到多种配置选项来创建更强大的 Django admin 显示和功能。

在本章中，您将首先学习如何在 Django 管理中注册 Django 模型。接下来，您将学习如何在 Django admin 中显示记录，并使用排序、行内编辑、分页、搜索和操作按钮等技术。此外，您将学习如何定制 Django 管理表单和关系，以便使用 Django 管理轻松地创建、更新和删除模型记录。

接下来，您将学习如何通过配置字段和定制模板定制 Django 管理页面，以及如何添加定制数据和覆盖 Django 管理类方法和字段来创建最灵活的 Django 管理页面。最后，您将学习如何配置和实施 Django 管理权限，以及如何创建多个 Django 管理站点实例。

## 在 Django 管理中设置 Django 模型

尽管 Django admin 为 Django 项目的数据库提供了一个优秀的管理工具，但是仅仅创建和安装 Django 模型还不足以在 Django admin 中访问它们的数据。

为了访问 Django 管理中的 Django 模型记录，您必须在`admin.py`文件中注册和配置 Django 模型。当你创建一个应用程序时，一个`admin.py`文件会自动放在 Django 应用程序中，与`models.py`和`views.py`文件放在一起。

虽然从技术上讲，你可以使用一个`admin.py`来注册和配置所有的 Django 模型——就像你可以使用一个`models.py`来定义所有的 Django 模型——但是推荐的做法是每个 Django 应用程序使用自己的`admin.py`文件来管理在`models.py`中定义的相应模型。

在 admin.py 文件中为 Django admin 注册 Django 模型有三种方法，所有这些都在清单 [11-1](#Par8) 中进行了说明。

```py
from django.contrib import admin
from coffeehouse.stores.models import Store

# Option 1 - Basic
admin.site.register(Store)

# Option 2 - Allows customizing Django admin behavior
class StoreAdmin(admin.ModelAdmin):
      pass

admin.site.register(Store, StoreAdmin)

# Option 3 – Decorator
@admin.register(Store)
class StoreAdmin(admin.ModelAdmin):
      pass

Listing 11-1.Register Django models in admin.py file

```

清单 [11-1](#Par8) 中的第一个选项提供了基本的 Django 模型注册，包括声明一个 Django 模型类作为`admin.site.register`方法的输入。如果您不需要为模型定制默认的 Django 管理行为，这个选项就足够了。

清单 [11-1](#Par8) 中的第二个选项利用了一个 Django 管理类，该类从`admin.ModelAdmin`类继承了它的行为。在这种情况下，你可以看到类是空的，但是可以定制 Django 管理行为，我将在本章中描述。一旦 Django admin 类被声明，它必须使用选项一中的相同的`admin.site.register`方法注册并与 Django 模型关联，其中第一个参数是 Django 模型，第二个参数是 Django admin 类。

清单 [11-1](#Par8) 中的第三个选项利用了 Django admin `@admin.register`装饰器。选项三和选项二之间的语法差异在于，注册和关联发生在用`@admin.register`修饰 Django admin 类时，其中修饰者将 Django 模型作为其参数。

值得一提的是，虽然选项二和选项三在功能上是相同的，但是使用`@admin.register`装饰器——选项三——有一个限制，即您不能在它的`__init__()`方法中引用 Django admin 类(例如，`super(StoreAdmin, self).__init__(*args, **kwargs)`),这在 Python 2 和某些设计中是一个问题；如果您处于这种情况，那么您必须使用选项二用`admin.site.register`方法注册一个模型。

现在您已经知道如何在 Django 管理中注册 Django 模型，我将描述通过 Django 管理类定制 Django 管理行为的各种选项。为了更容易地查找定制选项，我将选项分为两个主要部分:“读取记录选项”和“创建、更新、删除记录选项”，以涵盖 Django admin 中可用的 CRUD 操作选项的整个范围，此外还包括在每个主要部分下分组功能的子部分。

## Django 管理读取记录选项

当你在 Django admin 的主页上点击一个 Django 模型时，你会被带到一个页面，显示这个特定模型的记录列表。图 [11-1](#Fig1) 和 [11-2](#Fig2) 展示了`Store`型号的记录列表页面。

![A441241_1_En_11_Fig2_HTML.jpg](A441241_1_En_11_Fig2_HTML.jpg)

图 11-2。

Django admin record list page with model __str__ definition

![A441241_1_En_11_Fig1_HTML.jpg](A441241_1_En_11_Fig1_HTML.jpg)

图 11-1。

Django admin record list page with no model __str__ definition

如图 [11-1](#Fig1) 和 [11-2](#Fig2) 所示，每个 Django 模型记录都用一个字符串显示。默认情况下，这个字符串由 Django 模型的`__str__()`方法定义生成，如第 [7](07.html) 章所述。如果 Django 模型中缺少`__str__`方法，那么 Django 管理员会将类似图 [11-1](#Fig1) 的记录显示为‘Store object’；否则，它将返回由`__str__`方法为每条记录生成的结果——在图 [11-2](#Fig2) 中，这是每条`Store`记录的名称、城市和州属性。

### 记录显示:列表显示，格式 html，空值显示

虽然图 [11-1](#Fig1) 和 [11-2](#Fig2) 中呈现的基本显示行为是有帮助的，但是对于具有不表达的或复杂的`__str__()`方法的模型来说可能是非常有限的。Django admin 类可以用`list_display`选项进行配置，将记录列表与模型的各种字段分开，从而更容易查看和排序记录。清单 [11-2](#Par17) 展示了一个带有 list_display 选项的 Django 管理类。

```py
from django.contrib import admin
from coffeehouse.stores.models import Store

class StoreAdmin(admin.ModelAdmin):
      list_display = ['name','address','city','state']

admin.site.register(Store, StoreAdmin)

Listing 11-2.Django admin list_display option

```

正如您在清单 [11-2](#Par17) 中看到的，Django admin `StoreAdmin`类用一个值列表定义了`list_display`选项。该列表对应于 Django 模型字段，在本例中，这些字段来自`Store`模型。图 [11-3](#Fig3) 和 [11-4](#Fig4) 显示了通过添加`list_display`选项修改后的记录列表布局。

![A441241_1_En_11_Fig4_HTML.jpg](A441241_1_En_11_Fig4_HTML.jpg)

图 11-4。

Django admin record list page with model list_display sorted

![A441241_1_En_11_Fig3_HTML.jpg](A441241_1_En_11_Fig3_HTML.jpg)

图 11-3。

Django admin record list page with list_display Tip

如果你想在 Django 管理中继续显示 Django 模型通过其`__str__`方法生成的值，可以将其添加到`list_display`选项中(例如`list_display = ['name','__str__']`)。

在图 [11-3](#Fig3) 中，你可以看到一个更加清晰的记录列表布局，其中 list_display 中声明的每个字段都有自己的列。此外，如果你点击任何代表模型字段的列标题，记录会自动按照该属性排序，这个过程如图 [11-4](#Fig4) 所示，它极大地提高了记录的可发现性。

除了支持包含 Django 模型字段之外，`list_display`选项还支持其他变体来生成更复杂的列表布局。例如，如果数据库记录是不同的(例如，混合的大写和小写文本)，您可以生成一个可调用的方法来操作记录，并以统一的方式(例如，全部大写)在 Django admin 中显示它们。此外，您还可以创建一个 callable，从数据库中没有明确显示的记录字段(例如，属于电子邮件记录的域名)生成一个复合值，这使得 Django admin 中记录列表的可视化更加强大。清单 [11-3](#Par22) 使用几种方法变体展示了这些可调用的例子。

```py
from django.contrib import admin
from coffeehouse.stores.models import Store

# Option 1
# admin.py
def upper_case_city_state(obj):
    return ("%s %s" % (obj.city, obj.state)).upper()
upper_case_city_state.short_description = 'City/State'

class StoreAdmin(admin.ModelAdmin):
      list_display = ['name','address',upper_case_city_state]

# Option 2
# admin.py
class StoreAdmin(admin.ModelAdmin):
    list_display = ['name','address','upper_case_city_state']
    def upper_case_city_state(self, obj):
        return ("%s %s" % (obj.city, obj.state)).upper()
    upper_case_city_state.short_description = 'City/State'

# Option 3
# models.py
from django.db import models

class Store(models.Model):
    name = models.CharField(max_length=30)
    email = models.EmailField()
    def email_domain(self):
        return self.email.split("@")[-1]
    email_domain.short_description = 'Email domain'

# admin.py
class StoreAdmin(admin.ModelAdmin):
      list_display = ['name','email_domain']

Listing 11-3.Django admin list_display option with callables

```

在清单 [11-3](#Par22) 中，你可以看到三个可赎回的变体，它们都可以作为`list_display`期权。清单 [11-3](#Par22) 中的选项一是一个在类外声明的可调用函数，然后被用作`list_display`选项的一部分。选项二将 callable 声明为 Django admin 类的一部分，然后将其用作`list_display`选项的一部分。最后，选项三将 callable 声明为 Django 模型类的一部分，然后将其用作 Django 管理类中`list_display`选项的一部分。清单 [11-3](#Par22) 中的两种方法都不是“优于”或“劣于”另一种；这些选项只是在用于实现相同结果的语法和参数上有所不同，您可以使用您喜欢的任何方法。

在某些情况下，你可能想在 Django admin 中将 HTML 作为记录列表的一部分(例如，添加粗体**标签或彩色标签)。要在这些情况下包含 HTML，您必须使用`format_html`方法，因为 Django admin 默认情况下会对所有 HTML 输出进行转义——因为它使用 Django 模板。清单 [11-4](#Par25) 展示了`format_html`方法的使用。**

```py
# models.py
from django.db import models
from django.utils.html import format_html

class Store(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=30,unique=True)
    city = models.CharField(max_length=30)
    state = models.CharField(max_length=2)
    def full_address(self):
        return format_html('%s - <b>%s,%s</b>' % (self.address,self.city,self.state))

# admin.py
from django.contrib import admin
from coffeehouse.stores.models import Store

class StoreAdmin(admin.ModelAdmin):
      list_display = ['name','full_address']

Listing 11-4.Django admin list_display option with callable and format_html

```

当模型字段使用`BooleanField`或`NullBooleanField`数据类型时，Django admin 显示“开”或“关”图标，而不是`True`或`False`值。此外，当`list_display`中某个字段的值为`None`时，为空字符串，对于`list_display`中某个字段为空可迭代的情况(如 list)，Django 显示破折号`-`，如图 [11-5](#Fig5) 所示。

![A441241_1_En_11_Fig5_HTML.jpg](A441241_1_En_11_Fig5_HTML.jpg)

图 11-5。

Django admin default display for empty values

可以用图 [11-6](#Fig6) 所示的`empty_value_display`选项覆盖最后一个行为。您可以配置`empty_value_display`选项，使其在所有 Django 管理模型、特定的 Django 管理类或单个 Django 管理字段上生效，如清单 [11-5](#Par28) 所示。

![A441241_1_En_11_Fig6_HTML.jpg](A441241_1_En_11_Fig6_HTML.jpg)

图 11-6。

Django admin override display for empty values with empty_value_display

```py
# Option 1 - Globally set empty values to ???
# settings.py
from django.contrib import admin
admin.site.empty_value_display = '???'

# Option 2 - Set all fields in a class to 'Unknown Item field'
# admin.py to show "Unknown Item field" instead of '-' for NULL values in all Item fields
# NOTE: Item model in items app

class ItemAdmin(admin.ModelAdmin):
    list_display = ['menu','name','price']
    empty_value_display = 'Unknown Item field'

admin.site.register(Item, ItemAdmin)

# Option 3 - Set individual field in a class to 'No known price'
class ItemAdmin(admin.ModelAdmin):
    list_display = ['menu','name','price_view']
    def price_view(self, obj):
         return obj.price
    price_view.empty_value_display = 'No known price'

Listing 11-5.Django admin empty_value_display option global, class, or field-level configuration

```

### 记录顺序:admin_order_field 和排序

当您在`list_display`中使用定制字段(即，实际上不在数据库中的字段，而是在 Django 中计算的复合字段或帮助字段)时，这样的字段不能用于排序操作，因为排序发生在数据库级别。然而，如果`list_display`中的一个元素与一个数据库字段相关联，那么可以用`admin_order_field`选项创建一个关联用于排序目的。清单 [11-6](#Par30) 说明了这一过程。

```py
# models.py
from django.db import models
from django.utils.html import format_html

class Store(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=30,unique=True)
    city = models.CharField(max_length=30)
    state = models.CharField(max_length=2)
    def full_address(self):
        return format_html('%s - <b>%s,%s</b>' % (self.address,self.city,self.state))
    full_address.admin_order_field = 'city'

# admin.py
from django.contrib import admin
from coffeehouse.stores.models import Store

class StoreAdmin(admin.ModelAdmin):
      list_display = ['name','full_address']

Listing 11-6.Django admin with admin_order_field option

```

正如您在清单 [11-6](#Par30) 中看到的，当试图通过复合`full_address`字段在 Django admin 中执行排序操作时，`admin_order_field`声明告诉 Django 按照`city`对模型记录进行排序。注意，也可以给`admin_order_field`值添加一个前缀来指定降序(例如`full_address.admin_order_field = '-city'`)，就像在标准模型排序操作中一样。

默认情况下，记录列表值按其数据库`pk`(主键)字段(通常是 id 字段)排序，如图 [11-3](#Fig3) 所示(即记录`pk 1`在底部，记录`pk 4`在顶部)。如果您单击任何标题列，排序顺序就会改变，如图 [11-4](#Fig4) 所示。

要设置默认的排序行为——不需要点击标题列——您可以使用 Django admin class `ordering`选项或 Django model meta `ordering`选项，您将在第 [7](07.html) 章中了解到。如果在任一类中没有指定排序选项，则进行`pk`排序。如果在 Django 模型元选项中指定了`ordering`选项，那么这种排序行为是通用的，如果 Django 模型和 Django 管理类都有`ordering`选项，那么 Django 管理类定义优先。

`ordering`选项接受一个字段值列表来指定记录列表的默认顺序。默认情况下，`ordering`行为是升序(例如，Z 值第一个@bottom，A 值 top@last)，但是可以通过在字段值前添加一个`-`(减号)将此行为改为降序(例如，A 值第一个@bottom，Z 值 top@last)。例如，默认情况下，要生成如图 [11-4](#Fig4) 所示的记录列表，您可以使用`ordering = ['name']`，而要生成如图 [11-4](#Fig4) 所示的反向记录列表(即住宅区在顶部，公司在底部)，您可以使用`ordering = ['-name']`。

### 记录链接和内联编辑:list_display_links 和 list_editable

如果您查看一些过去的数字，您会注意到记录列表中的每一项都有一个生成的链接。例如，在图 [11-2](#Fig2) 中，您可以看到每条`'`商店`'`记录都是一个链接，将您带到一个可以编辑`'`商店`'`值的页面，同样，在图 [11-4](#Fig4) 中，您可以看到`'`商店`'`名称字段是一个链接，将您带到一个可以编辑`'`商店`'`值的页面，在图 [11-6](#Fig6) 中，您可以看到每条`'`

这是一个默认行为，允许您在每个记录上向下钻取，但是您可以通过`list_display_links`选项定制这个行为，以不生成链接或者包含更多的链接。清单 [11-7](#Par37) 说明了`list_display_links`选项的两种变型，并显示了 [11-7](#Fig7) 和 [11-8](#Fig8) 各自的接口。

![A441241_1_En_11_Fig8_HTML.jpg](A441241_1_En_11_Fig8_HTML.jpg)

图 11-8。

Django admin multiple links in records list due to list_display_links

![A441241_1_En_11_Fig7_HTML.jpg](A441241_1_En_11_Fig7_HTML.jpg)

图 11-7。

Django admin no links in records list due to list_display_links

```py
# Sample 1)
# admin.py
from django.contrib import admin
from coffeehouse.stores.models import Store

class StoreAdmin(admin.ModelAdmin):
      list_display = ['name','address','city','state']
      list_display_links = None

admin.site.register(Store, StoreAdmin)

# Sample 2)
# admin.py
from django.contrib import admin
from coffeehouse.items.models import Item

class ItemAdmin(admin.ModelAdmin):
    list_display = ['menu','name','price_view']
    list_display_links = ['menu','name']

admin.site.register(Item, ItemAdmin)

Listing 11-7.Django admin with list_display_links option

```

清单 [11-7](#Par37) 中的第一个示例演示了如何用`list_display_links = None`设置`StoreAdmin`类，从而得到图 [11-7](#Fig7) 中所示的缺少链接的页面。清单 [11-7](#Par37) 中的第二个示例显示了带有`list_display_links = ['menu','name']`的`ItemAdmin`类，该类告诉 Django 在`menu`和`name`字段值上生成链接，并产生图 [11-8](#Fig8) 中所示的包含多个链接的页面。

如果您需要编辑多个记录，那么单击记录列表上的单个链接来编辑记录的需要会变得令人厌烦。为了简化记录的编辑，`list_editable`选项允许 Django 在每个记录值上生成内联表单，有效地允许批量编辑记录，而无需离开记录列表屏幕。清单 [11-8](#Par41) 说明了 list_editable 选项的使用和图 [11-9](#Fig9) 各自的界面。

Note

从技术上讲，list_editable 是 Django admin 的更新选项，但是由于更新是在设计用来读取记录的页面上内联完成的，所以包含在这里。

![A441241_1_En_11_Fig9_HTML.jpg](A441241_1_En_11_Fig9_HTML.jpg)

图 11-9。

Django admin editable fields due to list_editable

```py
# admin.py
from django.contrib import admin
from coffeehouse.stores.models import Store

class StoreAdmin(admin.ModelAdmin):
      list_display = ['name','address','city','state']
      list_editable = ['address','city','state']

admin.site.register(Store, StoreAdmin)

Listing 11-8.Django admin with list_editable option

```

在清单 [11-8](#Par41) 中，您可以看到`list_editable = ['address','city','state']`选项，它告诉 Django 管理员允许编辑记录列表中的`address`、`city.`和`state`值。在图 [11-9](#Fig9) 中，你可以看到记录列表中的每一个字段值是如何被转换成可编辑的形式，并且在页面的底部，Django 管理员生成一个`'`保存`'`按钮来保存编辑时所做的更改。

值得一提的是，`list_editable`选项中声明的任何字段值也必须声明为`list_display`选项的一部分，因为不可能编辑未显示的字段。此外，`list_editable`选项中声明的任何字段值都不能是`list_display_option`的一部分，因为字段不可能既是表单又是链接。

### 记录分页:list_per_page，list_max_show_all，分页器

当 Django admin 中的记录列表变得太大时，它们会被自动分割成不同的页面。默认情况下，Django admin 会为每 100 条记录生成额外的页面。您可以使用 Django 管理类`list_per_page`选项来控制这个设置。清单 [11-9](#Par45) 说明了 list_per_page 选项的使用，图 [11-10](#Fig10) 显示了由清单 [11-9](#Par45) 中的配置生成的相应记录列表。

![A441241_1_En_11_Fig10_HTML.jpg](A441241_1_En_11_Fig10_HTML.jpg)

图 11-10。

Django admin list_per_page option limit to 5

```py
# admin.py
from django.contrib import admin
from coffeehouse.items.models import Item

class ItemAdmin(admin.ModelAdmin):
    list_display = ['menu','name','price']
    list_per_page = 5

admin.site.register(Item, ItemAdmin)

Listing 11-9.Django admin with list_per_page option

```

正如您在图 [11-10](#Fig10) 中看到的，由于清单 [11-9](#Par45) 中所示的`list_per_page = 5`选项，九条记录的显示被分成两页。除了图 [11-10](#Fig10) 左下方的页面图标，请注意这些图标的右侧是一个“显示全部”链接。“显示全部”链接用于生成一个记录列表，在一个页面上显示所有记录。但是请注意，因为这个额外的数据库操作成本很高，所以默认情况下，只有当记录列表不超过 200 项时，才会显示“显示全部”链接。

您可以使用`list_max_show_all`选项控制“显示全部”链接的显示。如果记录列表总数小于或等于`list_max_show_all`值，则显示“显示全部”链接，如果记录列表总数大于此数，则不生成“显示全部”链接。例如，如果您对列表 [11-9](#Par45) 声明`list_max_show_all = 8`选项，那么在图 [11-10](#Fig10) 中不会出现“显示全部”链接，因为记录列表总数是 9。

Django admin 使用`django.core.paginator.Paginator`类来生成分页序列，但是也可以通过 paginator 选项提供一个定制的分页器类。注意，如果自定义分页器类没有从`django.core.paginator.Paginator`继承它的行为，那么你也必须为`ModelAdmin.get_paginator()`方法提供一个实现。

### 记录搜索:搜索字段、列表过滤器、显示完整结果计数、保留过滤器

Django admin 也支持搜索功能。Django 管理类`search_fields`选项通过搜索框增加了文本模型字段的搜索功能——关于 Django 模型文本数据类型的列表，参见表 [7-1](07.html#Tab1) 。清单 [11-10](#Par50) 展示了一个带有 search_fields 选项的 Django 管理类，图 [11-11](#Fig11) 展示了一个搜索框是如何被添加到记录列表的顶部的。

![A441241_1_En_11_Fig11_HTML.jpg](A441241_1_En_11_Fig11_HTML.jpg)

图 11-11。

Django admin search box due to search_fields option

```py
from django.contrib import admin
from coffeehouse.stores.models import Store

class StoreAdmin(admin.ModelAdmin):
      search_fields = ['city','state']

admin.site.register(Store, StoreAdmin)

Listing 11-10.Django admin search_fields option

```

在清单 [11-10](#Par50) 中，城市和州字段被添加到`search_fields`选项中，它告诉 Django 管理员在这两个字段中执行搜索。请注意，由于 Django 执行这种类型的搜索查询的方式，向`search_fields`选项添加太多字段会导致搜索结果变慢。表 [11-1](#Tab1) 显示了不同的`search_fields`选项和为给定搜索项生成的 SQL。

表 11-1。

Django search_fields options and generated SQL for search term

<colgroup><col> <col> <col></colgroup> 
| 搜索字段选项 | 搜索术语 | 生成的 SQL 条件 |
| --- | --- | --- |
| search_fields = ['city '，' state'] | 圣迭戈 | 其中(城市我喜欢“%San%”或州我喜欢“%San%”)和(城市我喜欢“%Diego%”或州我喜欢“%Diego%”) |
| search _ fields =['^city','^state'] | 圣迭戈 | 其中(城市 ILIKE 'San% '或州 ILIKE 'San% ')和(城市 ILIKE 'Diego% '或州 ILIKE 'Diego% ') |
| search _ fields =[' =城市'，' =州'] | 圣迭戈 | 其中(市 ILIKE 'San '或州 ILIKE 'San ')和(市 ILIKE 'Diego '或州 ILIKE 'Diego ') |
| *search_fields = ['@city '，' @state'] | 圣迭戈 | (全文搜索)其中(城市 I like“% San %”或州 I like“% San %”)和(城市 I like“% Diego %”或州 I like“% Diego %”) |

* Full-text search option only supported for MySQL database

如表 [11-1](#Tab1) 所示，`search_fields`选项通过将提供的搜索字符串拆分成单词来构建查询，并执行不区分大小写的搜索(即`SQL ILIKE`)，其中每个单词必须至少出现在一个 search _ fields 中。此外，注意在表 [11-1](#Tab1) 中，可以用不同的前缀声明`search_fields`值来改变搜索查询。

默认情况下，如果您只是向`search_fields,`提供模型字段名，Django 会生成一个查询，在每个单词的开头和结尾使用 SQL 通配符`%`，这可能是一个代价非常高的操作，因为它会搜索字段记录中的所有文本。如果您在`search_field`前面加上一个`^`——如表 [11-1](#Tab1) 所示——Django 会生成一个查询，在每个单词的末尾有一个 SQL 通配符`%`，这使得搜索操作更加有效，因为它仅限于以单词模式开头的文本。如果您给 search_field 加上前缀`=`——如表 [11-1](#Tab1) 所示——Django 会生成一个没有 SQL 通配符`%`的精确匹配查询，这使得搜索操作最有效，因为它仅限于单词模式的精确匹配。最后，如果您使用的是 MySQL 数据库，也可以给`search_fields`添加前缀`@`来实现全文搜索。

Power Searches, Non-Text Searches, and Other Back Ends For Django Admin Searches

搜索引擎提供了各种强大的搜索语法来定制搜索查询，但是 Django admin `search_fields`选项不支持这种语法。例如，在搜索引擎中，可以引用搜索词`"San Diego"`来对两个单词进行精确搜索，但是如果你尝试用 Django admin 搜索，Django 会尝试分别搜索文字引号:`"San"`和`"Diego"`。要调整默认的 search_fields 行为，您必须使用表 [11-1](#Tab1) 或`ModelAdmin.get_search_results()`中的选项。

Django admin 类的默认搜索行为可以通过接受请求的`ModelAdmin.get_search_results()`方法、应用当前过滤器的 queryset 和用户提供的搜索词定制为任何需求。通过这种方式，您可以生成非文本搜索(例如，在整数上)或依靠其他第三方工具(例如，Solr、Haystack)来生成搜索结果。

`list_filter`选项提供了对模型字段值的快速访问，并且像预建的搜索链接一样工作。与`search_fields`选项不同，`list_filter`选项在它可以处理的数据类型方面更加灵活，并且不仅仅接受文本模型字段(例如，它还支持布尔字段、日期字段等)。).清单 [11-11](#Par57) 展示了一个带有`list_filter`选项的 Django 管理类，图 [11-12](#Fig12) 展示了在记录列表右侧生成的过滤器列表。

![A441241_1_En_11_Fig12_HTML.jpg](A441241_1_En_11_Fig12_HTML.jpg)

图 11-12。

Django admin list filters due to search_fields option

```py
from django.contrib import admin
from coffeehouse.items.models import Item

class ItemAdmin(admin.ModelAdmin):
    list_display = ['menu','name','price']
    list_filter = ['menu','price']

admin.site.register(Item, ItemAdmin)

Listing 11-11.Django admin list_filter option

```

在清单 [11-11](#Par57) 中，list_filter 选项是用菜单和价格字段声明的，它告诉 Django 用这两个字段创建过滤器。正如您在图 [11-12](#Fig12) 中所看到的，记录列表的右侧是一个带有各种过滤器的列，其中包含了`menu`和`price`字段值的所有值。如果您点击任何过滤器链接，Django admin 会在记录列表中显示与过滤器匹配的记录，这个过程如图 [11-13](#Fig13) 、 [11-14](#Fig14) 和 [11-15](#Fig15) 所示。

![A441241_1_En_11_Fig15_HTML.jpg](A441241_1_En_11_Fig15_HTML.jpg)

图 11-15。

Django admin list with dual filter

![A441241_1_En_11_Fig14_HTML.jpg](A441241_1_En_11_Fig14_HTML.jpg)

图 11-14。

Django admin list with single filter

![A441241_1_En_11_Fig13_HTML.jpg](A441241_1_En_11_Fig13_HTML.jpg)

图 11-13。

Django admin list with single filter

在图 [11-15](#Fig15) 中可以看到的 Django 管理过滤器的一个有趣的方面是，您可以应用多个过滤器，这使得更容易深入到匹配非常具体的标准的记录。

此外，如果您查看图 11-13、11-14 和 11-15，您可以看到过滤器是如何反映为 URL 查询字符串的。例如，在图 [11-13](#Fig13) 中，`?menu__id__exact=2`字符串被附加到 URL 上，它告诉 Django admin 显示一个记录列表，带有一个`2`的菜单`id`；在图 [11-15](#Fig15) 中，`?menu__id__exact=3&price=3.99`字符串告诉 Django admin 显示一个菜单 id 为`3`和价格值为`3.99`的记录列表。该 URL 参数语法基于用于进行标准 Django 模型查询的相同语法——在第 [8](08.html) 章中描述——这有助于“动态”生成更复杂的过滤器，而无需修改或添加底层 Django 管理类的选项。

当您对记录列表应用一个或多个过滤器，并且过滤后的结果多于 99 条记录时，Django 会将初始显示限制为 99 条记录，并且还会添加分页，但此外还会显示与过滤器匹配的对象的完整计数(例如，99 条结果(总共 153 条))。这个额外的计数需要一个额外的查询，这对于大量的记录来说会减慢速度。要禁止生成适用于过滤器使用的额外计数，您可以将`show_full_result_count`选项设置为`False`。

应用一个或多个过滤器的另一个特点是，当您创建、编辑或删除一个记录并完成操作时，Django 会将您带回过滤列表。虽然这可能是一个期望的行为，但是可以通过`preserve_filters`选项覆盖这个行为，这样 Django 管理员就可以将您返回到原始记录列表。如果您在 Django admin 类中设置了`preserve_filters = False`选项，并创建、编辑或删除了一个记录，Django admin 会将您带回到没有过滤器的原始记录列表。

### 记录日期:日期层次结构

日期和时间在 Django admin UI 中显示为底层 Python `datetime`值的字符串表示，正如您所期望的那样。但是有一个针对`DateField`和`DateTimeField`模型数据类型的特殊选项，它像一个专门的过滤器一样工作。如果您在 Django 管理类上使用`date_hierarchy`选项，并为其分配一个为`DateField`或`DateTimeField`的字段(例如`date_hierarchy = 'created'`，其中`timestamp`是字段的名称)，Django 会在记录列表的顶部生成一个智能日期过滤器，如图 [11-16](#Fig16) 、 [11-17](#Fig17) 和 [11-18](#Fig18) 所示。

![A441241_1_En_11_Fig18_HTML.jpg](A441241_1_En_11_Fig18_HTML.jpg)

图 11-18。

Django date filter single day with date_hierarchy

![A441241_1_En_11_Fig17_HTML.jpg](A441241_1_En_11_Fig17_HTML.jpg)

图 11-17。

Django date filter by day with date_hierarchy

![A441241_1_En_11_Fig16_HTML.jpg](A441241_1_En_11_Fig16_HTML.jpg)

图 11-16。

Django date filter by month with date_hierarchy

正如您在图 [11-16](#Fig16) 、 [11-17](#Fig17) 和 [11-18](#Fig18) 中看到的，智能行为来自于这样一个事实，即在加载记录列表时，Django 会生成一个与`date_hierarchy`字段的值相对应的可用月份或日期的唯一列表。如果您单击这个过滤器列表的任何选项，Django 就会生成一个唯一的记录列表，该列表与过滤器列表中的月或日的值相匹配。

### 记录动作:顶部动作，底部动作，动作

除了可以点击 Django 管理记录列表中的项目来编辑或删除它之外，在记录列表的顶部还有一个以单词“Action”开头的下拉菜单，你可以在前面的图中看到。默认情况下,“操作”下拉菜单提供“删除选定选项”项，通过选中每条记录左侧的复选框来同时删除多条记录。

如果您希望从记录列表顶部移除“操作”菜单，您可以使用`actions_on_top`选项并将其设置为`False`。此外，如果您希望将“动作”菜单添加到记录列表的底部，您可以使用图 [11-19](#Fig19) 所示的`actions_on_bottom = True`选项——注意，记录列表页面的底部和顶部都可以有“动作”菜单。

![A441241_1_En_11_Fig19_HTML.jpg](A441241_1_En_11_Fig19_HTML.jpg)

图 11-19。

Django admin list with Action menu on bottom due to actions_on_bottom

与“动作”菜单相关的另一个选项是`actions_selection_counter`，它在“动作”菜单的右侧显示所选记录的数量，也可以在图 [11-19](#Fig19) 中看到。如果您设置了`actions_selection_counter = False`，那么 Django 管理员会忽略与“动作”菜单相关的所选记录的数量。

尽管“Action”菜单仅限于一个操作——删除记录——但是可以通过 Django admin 类中的`actions`选项定义一个操作列表。[<sup>1</sup>T4】](#Fn1)

### 记录关系

在前面的模型章节中描述的 Django 模型关系——一对一、一对多和多对多——在 Django 管理类和 Django 管理的上下文中具有某些行为，这些行为值得在下面的小节中分别描述。

#### 显示:列表显示(续)

当你有一个一对多的关系并声明相关的`ForeignKey`字段作为`list_display`选项的一部分时，Django admin 使用相关模型的`__str__`表示。图 [11-5](#Fig5) 显示了最后一个行为，其中有一列`Item`记录，其中`Item`模型用`models.ForeignKey(Menu)`定义了`menu`字段，因此该字段的输出是`Menu`模型`__str__`方法。

`list_display`选项不能直接接受`ManyToManyField`字段，因为它需要为表中的每一行执行单独的 SQL 语句；然而，通过 Django 管理类中的自定义方法将`ManyToManyField`集成到`list_display`中是可能的，这个过程在清单 [11-12](#Par73) 和图 [11-20](#Fig20) 中有所说明。

![A441241_1_En_11_Fig20_HTML.jpg](A441241_1_En_11_Fig20_HTML.jpg)

图 11-20。

Django admin list_display option with ManyToManyField field

```py
# models.py
from django.db import models

class Amenity(models.Model):
    name = models.CharField(max_length=30)
    description = models.CharField(max_length=100)

class Store(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=30)
    city = models.CharField(max_length=30)
    state = models.CharField(max_length=2)
    email = models.EmailField()
    amenities = models.ManyToManyField(Amenity,blank=True)

# admin.py
from django.contrib import admin
from coffeehouse.stores.models import Store

class StoreAdmin(admin.ModelAdmin):
    list_display = ['name','address','city','state','list_of_amenities']
    def list_of_amenities(self, obj):
        return ("%s" % ','.join([amenity.name for amenity in obj.amenities.all()]))
    list_of_amenities.short_description = 'Store amenities'

admin.site.register(Store, StoreAdmin)

Listing 11-12.Django admin list_display option with ManyToManyField field

```

在清单 [11-12](#Par73) 中，您可以看到`Store`模型有一个带有`Amenity`模型的`ManyToManyField`字段。为了通过`list_display`显示 Django admin 中的`ManyToManyField`字段的值，您可以看到有必要创建一个定制方法来对这些记录进行额外的查询。图 [11-20](#Fig20) 显示了该`ManyToManyField`字段的 Django 管理记录列表。请注意，这种设计会给数据库带来沉重的负担，因为它需要对每条记录进行额外的查询。

#### 订单:管理订单字段(续)

`admin_order_field`选项还支持对相关模型中的字段进行排序。例如，在清单 [11-13](#Par76) 中，您可以看到`admin_order_field`选项被应用于一个字段，该字段是具有`ForeignKey`字段关系的模型的一部分。

```py
# models.py
class Menu(models.Model):
    name = models.CharField(max_length=30)
    creator = models.CharField(max_length=100,default='Coffeehouse Chef')
    def __str__(self):
        return u"%s" % (self.name)

class Item(models.Model):
    menu = models.ForeignKey(Menu)
    name = models.CharField(max_length=30)

# admin.py
from django.contrib import admin
from coffeehouse.stores.models import Store

class ItemAdmin(admin.ModelAdmin):
    list_display = ['menu','name','menu_creator']
    def menu_creator(self, obj):
        return obj.menu.creator
    menu_creator.admin_order_field = 'menu__creator'

admin.site.register(Item, ItemAdmin)

Listing 11-13.Django admin admin_order_field option with ForeignKey field

```

关于清单 [11-13](#Par76) 值得注意的最重要的事情是指定字段`menu__creator`的双下划线，它告诉 Django 管理员访问相关模型中的字段——注意这个双下划线是在第 [8 章](08.html)中描述的 Django 模型关系查询中用于执行查询的相同语法。

#### 搜索:search_fields 和 list_filter(续)，管理。RelatedOnlyFieldListFilter，list_select_related

另外两个支持相同双下划线语法(也称为“跟随符号”)的 Django 管理类选项是`search_fields`和`list_filter`。这意味着您可以为相关模型(例如`search_fields = ['menu__creator']`)启用搜索并生成过滤器。

仅适用于模型关系的`list_filter`选项的变体是`admin.RelatedOnlyFieldListFilter`。当属于某个关系的模型记录可以跨越单个关系时，可能会导致创建不必要的筛选器。

举个例子，我们来看一个`Store`和`Amenity`车型的关系；您可以为`Store`记录列表上的`Amenity`值生成 Django 管理过滤器，但是如果`Amenity`型号记录是通用的并且在`Store`型号之外使用(例如，`Employees`的`Amenity`值)，您将在商店记录列表中看到不适用的过滤器值。使用`admin.RelatedOnlyFieldListFilter`可以防止这种情况，这个过程在清单 [11-14](#Par81) 和图 [11-21](#Fig21) 和 [11-22](#Fig22) 中进行了说明。

![A441241_1_En_11_Fig22_HTML.jpg](A441241_1_En_11_Fig22_HTML.jpg)

图 11-22。

Django admin list_filter option with RelatedOnlyFieldListFilter

![A441241_1_En_11_Fig21_HTML.jpg](A441241_1_En_11_Fig21_HTML.jpg)

图 11-21。

Django admin list_filter option with no RelatedOnlyFieldListFilterDjango

```py
# admin.py
class StoreAdmin(admin.ModelAdmin):
    list_display = ['name','address','city','state','list_of_amenities']
    list_filter = [['amenities',admin.RelatedOnlyFieldListFilter]]
    def list_of_amenities(self, obj):
        return ("%s" % ','.join([amenity.name for amenity in obj.amenities.all()]))
    list_of_amenities.short_description = 'Store amenities'
Listing 11-14.Django admin list_filter option with admin.RelatedOnlyFieldListFilter

```

在清单 [11-14](#Par81) 中，注意生成过滤器的字段——在本例中是`amenities`——是如何与`admin.RelatedOnlyFieldListFilter`一起被包装在它自己的列表中的。为了理解使用和不使用`admin.RelatedOnlyFieldListFilter`的区别，请看图 [11-21](#Fig21) 和 [11-22](#Fig22) 。在图 [11-21](#Fig21) 中，注意列表中的最后一个过滤器是“按摩椅”——一个`Amenity`记录——但是主列表中没有`Store`记录有这个舒适性。要从`Store`记录列表中删除这个不适用的过滤器，您可以使用`admin.RelatedOnlyFieldListFilter`并从图 [11-22](#Fig22) 中获得结果，图中仅显示与`Store`记录相关的`Amenity`过滤器。

最后，另一个适用于具有模型关系的 Django 管理类的选项是`list_select_related`。`list_select_related`选项的功能就像在涉及关系的查询中使用的`list_select_related`选项，以减少涉及关系的数据库查询的数量(例如，它创建单个复杂的查询，而不是以后需要为每个关系发出多个查询)。`list_select_related`选项可以接受布尔值或列表值。默认情况下，`list_select_related`选项接收一个`False`值(即不使用)。在底层，`list_select_related`选项使用相同的`select_related()`模型方法来检索相关记录，如第 [8](08.html) 章所述。

如果`list_select_related = True`那么`select_related()`总是被使用。为了对`list_select_related`进行更细粒度的控制，您可以指定一个列表，注意空列表会阻止 Django 调用`select_related()`，任何其他列表值都会作为参数直接传递给`select_related()`。

## Django admin 创建、更新、删除记录选项

除了 Django admin read record 选项，主要用于修改 Django admin 中每个模型的主页(即每个模型的记录列表)，还有其他 Django admin 页面用于创建、更新和删除 Django 模型记录，这些页面也支持一系列选项。

当你点击显示模型记录的每个 Django 管理页面右上方的“添加<model name="">”按钮时，你会被带到一个类似表格的页面，在这里你可以为一条新记录提供值，如图 [11-23](#Fig23) 所示；当你点击 Django 管理记录列表中的一条记录时，你也会被带到一个类似表格的页面，在这里你可以编辑或删除该记录的字段值，如图 [11-24](#Fig24) 所示。</model>

![A441241_1_En_11_Fig23_HTML.jpg](A441241_1_En_11_Fig23_HTML.jpg)

图 11-23。

Django 管理页面创建模型记录

![A441241_1_En_11_Fig24_HTML.jpg](A441241_1_En_11_Fig24_HTML.jpg)

图 11-24。

Django 管理页面编辑或删除模型记录Tip

如图 [11-23](#Fig23) 和 [11-24](#Fig24) 所示的娱乐场所界面更加友好，参见图 [11-37](#Fig37) 和 [11-38](#Fig38) 中的`filter_horizontal`和`filter_vertical`选项。

在接下来的小节中，我将描述 Django admin 中用于创建、更新和删除记录的各种选项，值得注意的是，这三个操作都在同一个页面上。

### 记录表单:字段、只读字段、排除、字段集、表单字段覆盖、表单、预填充字段

默认情况下，Django 管理员为您正在处理的 Django 模型中的所有字段生成一个表单。例如，在图 [11-23](#Fig23) 和 [11-24](#Fig24) 中，您可以看到 Django 管理表单中的六个字段，它们对应于`Store` Django 模型的六个字段定义。在幕后，由于 Django admin 使用填充了模型记录的表单，Django admin 表单的操作和选项几乎与第 [9](09.html) 章中描述的模型表单相同。

第一个可以改变 Django 管理表单字段数量的选项是`fields`选项。`fields`选项允许您改变表单字段出现的顺序，或者创建一个带有模型字段子集的表单。清单 [11-15](#Par91) 展示了`fields`在 Django 管理类中的用法，图 [11-25](#Fig25) 展示了清单 [11-15](#Par91) 生成的 UI。

![A441241_1_En_11_Fig25_HTML.jpg](A441241_1_En_11_Fig25_HTML.jpg)

图 11-25。

Django admin fields option for Django admin forms

```py
class StoreAdmin(admin.ModelAdmin):
      fields = ['address','city','state','email']

admin.site.register(Store, StoreAdmin)

Listing 11-15.Django admin fields option

for Django admin forms

```

在清单 [11-15](#Par91) 中，您可以看到`fields`选项包含四个字段，而原始支持`Store` Django 模型包含六个字段；在图 [11-25](#Fig25) 中，你可以确认 Django 管理表单仅仅由四个字段生成。

Django 管理表单的同一个`fields`选项的另一个变体是将多个表单字段组合到同一个 UI 行中。这很容易通过将字段嵌套在它们自己的元组中来实现。例如，如果定义了`fields = ['address',('city','state'),'email']`，`city`和`state`表单字段在表单的同一行生成，如图 [11-26](#Fig26) 所示。

![A441241_1_En_11_Fig26_HTML.jpg](A441241_1_En_11_Fig26_HTML.jpg)

图 11-26。

Django admin fields option with wrapped fields for Django admin forms Tip

list_editable 选项创建一个内嵌表单来编辑记录，而不需要进入如图 [11-25](#Fig25) 和 [11-26](#Fig26) 所示的专用表单页面。参见上一节“记录链接和内嵌编辑”。

虽然`fields`选项很有帮助，但在其他情况下，可能需要显示一个表单域，但不允许它被更改，因为完全忽略一个域可能会导致混乱。要禁止编辑表单域，您可以使用`readonly_fields`选项。清单 [11-16](#Par96) 展示了`readonly_fields`选项的使用，图 [11-27](#Fig27) 展示了它的 UI 布局。

![A441241_1_En_11_Fig27_HTML.jpg](A441241_1_En_11_Fig27_HTML.jpg)

图 11-27。

Django admin readonly_fields option for Django admin forms

```py
class StoreAdmin(admin.ModelAdmin):
      readonly_fields = ['name','amenities']

admin.site.register(Store, StoreAdmin)

Listing 11-16.Django admin readonly_fields option

for Django admin forms

```

在清单 [11-16](#Par96) 中，您可以看到`readonly_fields`选项使`name`和`amenities`字段变为只读。因为没有使用 fields 选项，所以所有的模型字段都用于生成表单。在图 [11-27](#Fig27) 中，你可以看到`name`和`amenities`字段是如何显示为文本而不是输入表单字段，使它们不可编辑。

仅使用`readonly_fields`选项的副作用是这些字段定义被放置在表单的底部，如图 [11-27](#Fig27) 所示。如果您想保持与原始 Django 模型相同的表单字段顺序，那么您需要使用`fields`选项明确定义表单字段，这样表单字段顺序遵循`fields`选项，并且`readonly_field`中的任何字段都显示为只读，考虑到在`fields`选项中设置的字段位置。

除了支持模型字段名称之外，`readonly_fields`选项还支持可调用的方法来进一步添加定制行为。清单 [11-17](#Par100) 展示了带有可调用的`readonly_fields`选项的使用，以及图 [11-28](#Fig28) 的 UI 布局。

![A441241_1_En_11_Fig28_HTML.jpg](A441241_1_En_11_Fig28_HTML.jpg)

图 11-28。

Django admin readonly_fields option for Django admin forms

```py
from django.utils.safestring import mark_safe

class StoreAdmin(admin.ModelAdmin):
    fields = ['name','address',('city','state'),'email','custom_amenities_display']
    readonly_fields = ['name','custom_amenities_display']
    def custom_amenities_display(self, obj):
        return mark_safe("Amenities can only be modified by special request, please contact the store manager at %s to create a request" % (obj.email,obj.email))
    custom_amenities_display.short_description = "Amenities"

admin.site.register(Store, StoreAdmin)

Listing 11-17.Django admin readonly_fields option with callable for Django admin forms

```

在清单 [11-17](#Par100) 中，您可以看到`readonly_fields`选项使用了`custom_amenities_display`可调用函数来创建一个定制字段。在底部的图 [11-28](#Fig28) 中，你可以看到这个新的定制字段——代替了原来的`amenities`字段——它显示了比图 [11-27](#Fig27) 更友好的消息，并且也是不可编辑的。

Django 管理类中表单的`exclude`选项是对`fields`选项的补充。而`fields`选项要求它显式地创建包含在 Django 管理表单中的字段列表，而`exclude`提供了相反的行为，要求它显式地列出不属于 Django 管理表单的字段。例如，对于具有字段 a、b、c 的 Django 模型，Django 管理类 fields = ('a '，' b ')选项等同于 exclude = ('c ')选项(即，两个选项生成相同的 Django 管理表单)。

Django 管理类的`fieldsets`选项提供了对用于在 Django 管理中创建和编辑记录的页面布局的更大控制。不像`fields`选项可以改变表单字段的顺序，甚至可以在同一行嵌套表单字段——如图 [11-26](#Fig26) 所示——`fieldsets`选项与字段选项一起工作，将一个页面分成多个集合。清单 [11-18](#Par104) 说明了`fieldsets`选项的使用，图 [11-29](#Fig29) 和 [11-30](#Fig30) 相应的布局。

![A441241_1_En_11_Fig30_HTML.jpg](A441241_1_En_11_Fig30_HTML.jpg)

图 11-30。

Django admin fieldsets option for Django admin forms (collapsed)

![A441241_1_En_11_Fig29_HTML.jpg](A441241_1_En_11_Fig29_HTML.jpg)

图 11-29。

Django admin fieldsets option for Django admin forms

```py
from django.utils.safestring import mark_safe

class StoreAdmin(admin.ModelAdmin):
    fieldsets = [
        ['Store general information', {
            'fields': ['name', 'email']
        }],
        ['Store location options', {
            'classes': ['collapse'],
            'fields': ['address',('city', 'state')],
        }],
    ]

admin.site.register(Store, StoreAdmin)

Listing 11-18.Django admin fieldsets option

for Django admin forms

```

在清单 [11-18](#Par104) 中，你可以看到`fieldsets`选项接受由两个列表组成的列表值，其中每个列表代表 Django 管理页面的一部分，如图 [11-29](#Fig29) 和 [11-30](#Fig30) 所示。每个内部列表都由第一个参数和第二个参数组成，第一个参数表示部分的标题或头，第二个参数是一个字典。最后一个字典本身包含分配给一个字段的键的值——其功能就像前面描述的`fields`选项——和一个`classes`键，该键通过 CSS 类为该部分提供某些行为。在这种情况下，您可以看到清单 [11-18 中的第二个部分](#Par104)表示`'classes': ['collapse']`，它告诉 Django 使该部分可折叠，在图 [11-29](#Fig29) 和 [11-30](#Fig30) 中，您可以欣赏这种折叠和未折叠的行为。

除了在`fieldsets`的`classes`键中使用的`collapse`选项，另一个有用的 CSS 类选项是`wide`，它在字段之间增加了更多的水平空间。注意，向`classes`键添加任意数量的 CSS 类都是有效的，可以是 Django admin 中包含的 CSS 类(即`collapse`和`wide`)，甚至是自定义的 CSS 类。

`formfield_overrides`选项提供了一种方法来覆盖与 Django 管理表单中的 Django 模型字段相关联的默认表单小部件。默认情况下，所有 Django 模型字段都有一个指定的小部件分配给它们，目的是生成一个表单——这个主题在第 [9](09.html) 章中讨论，具体见表 [9-1](09.html#Tab1) 。但是，如果您觉得给定模型字段的默认小部件对 Django admin 来说不够用，您可以使用清单 [11-19](#Par108) 中所示的`formfield_overrides`选项。

```py
from django.contrib import admin
from coffeehouse.items.models import Menu

class MenuAdmin(admin.ModelAdmin):
    formfield_overrides = {
        models.CharField: {'widget': forms.Textarea}
    }

admin.site.register(Menu, MenuAdmin)

Listing 11-19.Django admin formfield_overrides option

for Django admin forms

```

清单 [11-19](#Par108) 中的`formfield_overrides`选项告诉 Django 管理员为所有使用 `CharField`的模型字段使用`forms.Textarea`小部件——它生成一个标准的 HTML <textarea>标签。在图<a href="#Fig32"> 11-32 </a>中，您可以看到应用清单<a href="#Par108"> 11-19 </a>的<code>formfield_overrides</code>选项的效果，而在图<a href="#Fig31"> 11-31 </a>中，您可以看到用于<code>CharField</code>字段的默认小部件，它是一个标准的 HTML <input/>标签。</textarea>

![A441241_1_En_11_Fig32_HTML.jpg](A441241_1_En_11_Fig32_HTML.jpg)

图 11-32。

Django admin custom CharField field display in Django admin form using formfield_overrides

![A441241_1_En_11_Fig31_HTML.jpg](A441241_1_En_11_Fig31_HTML.jpg)

图 11-31。

Django admin default CharField field display in Django admin form

虽然前面所有的选项都允许您调整 Django admin 中使用的表单的一部分，但是有时有必要为 Django admin 从头创建一个表单，而不是调整 Django 模型生成的底层表单(例如，如果您需要对 Django admin 表单进行定制验证)。要为 Django 管理类指定定制表单，可以使用`form`选项。

最后，与 Django 管理表单相关的另一个选项是`prepopulated_fields`，它特定于需要 slug 字段值的模型。如果您不熟悉术语“slug ”,最简单地说，slug 字段值是字符串的机器友好表示，例如，大写字母被转换为小写字母，空格等特殊字符被转换为破折号。通过`prepopulated_fields`选项，您可以告诉 Django，当用户为 Django 管理表单中的给定字段键入值时，它会自动用第一个字段的 slug 表示填充表单中的另一个字段。

例如，对于`prepopulated_fields = {'address': ['city','state']}`选项，如果用户在城市表单字段中键入值圣地亚哥，在州中键入 CA，Django 用值`san-diego-ca`填充`address`表单字段。值得一提的是，该功能是通过集成到 Django admin 中的 JavaScript 实现的，并且`prepopulated_fields`选项不接受`DateTimeField`、`ForeignKey`或`ManyToManyField`字段作为支持模型数据类型。

### 动作、链接和位置:保存在顶部、另存为(克隆记录)、另存为继续和查看现场

在创建、更新和删除 Django 模型记录的每个表单页面的底部都有在页面上执行操作的按钮:“删除”、“保存并添加另一个”、“保存并继续编辑”和“保存”，所有这些都如图 [11-33](#Fig33) 所示。如果一个表单太大，不向下滚动就很难找到这些动作按钮，所以为了解决这个问题，Django 管理类支持`save_on_top`选项，它在页面顶部创建相同的动作按钮，如图 [11-34](#Fig34) 所示。请注意，要生成图 [11-34](#Fig34) 中的布局，您需要使用`save_on_top = True`。

![A441241_1_En_11_Fig34_HTML.jpg](A441241_1_En_11_Fig34_HTML.jpg)

图 11-34。

Django admin save_on_top option on form page

![A441241_1_En_11_Fig33_HTML.jpg](A441241_1_En_11_Fig33_HTML.jpg)

图 11-33。

Django admin standard action button on form page

有时候，需要从 Django admin 中预先存在的记录生成一个相同或几乎相同的记录。因为在 Django admin 中将值从一个表单复制粘贴到另一个表单是一个耗时且容易出错的过程，所以 Django admin 类还支持`save_as`选项来克隆预先存在的模型记录。如果在 Django 管理类上设置了`save_as = True`选项，Django 会用“另存为新的”按钮替换“保存并添加另一个”按钮，如图 [11-35](#Fig35) 所示。

![A441241_1_En_11_Fig35_HTML.jpg](A441241_1_En_11_Fig35_HTML.jpg)

图 11-35。

Django admin save_as (Clone) option on form page

如果你点击图 [11-35](#Fig35) 所示的“另存为新的”按钮，Django 会保存一个相同的记录——有效地克隆你在屏幕上看到的记录——使用不同的`id`值来区分两者。请注意，如果底层 Django 模型禁止这种操作(例如，字段必须是惟一的)，则操作不会发生，并且会抛出一个错误来指出原因。

当您使用`save_as = True`选项并执行克隆记录的动作时(即点击“另存为新的”按钮)，Django 管理员会让您保持新克隆记录的形式，以防您想进一步更改它。您可以使用`save_as_continue = False`选项，告诉 Django 管理员在克隆记录后将您重定向到主模型列表页面。

Django 模型类支持一个名为`get_absolute_url()`的实例方法，该方法使得通过 Django 模型的字段解析记录的公共 URL 成为可能(例如，URL`/store/1/`、`/store/2/`、`/store/3/`符合一个模式，其中每个数字代表一个商店`id`值，在这种情况下，`Store`模型的`get_absolute_url()`方法将返回`/store/<store_record_id>`。在 Django admin 中，`get_absolute_url()`方法被直接绑定到一个链接，该链接有助于在公共 URL 目的地查看记录，图 [11-36](#Fig36) 在右上角显示了这个链接。

![A441241_1_En_11_Fig36_HTML.jpg](A441241_1_En_11_Fig36_HTML.jpg)

图 11-36。

Django admin 'View on site' button due to get_absolute_url() Django model method

在图 [11-36](#Fig36) 中，右上角的“查看站点”按钮基于 Django 模型的`get_absolute_url()`方法以及在最后一个方法中定义的当前记录的值生成一个链接。通过这种方式，只需单击一下，您就可以在 Django admin 的公共 URL 目的地看到您正在编辑的记录。如果您想禁用这个按钮，您可以将`view_on_site = False`选项添加到 Django admin 类中。注意，如果底层 Django 模型类没有定义`get_absolute_url()`方法，那么无论`view_on_site`值是多少，都不会显示按钮。

### 关系:filter_horizontal、filter_vertical、radio_fields、raw_id_fields、inlines

与创建、更新和删除操作相关的 Django 模型关系任务在 Django 管理类的上下文中也有某些行为，值得单独描述。

当您在 Django 模型上使用一个`ManyToManyField`字段并在 Django 管理中访问它时，Django 会生成 HTML <select>/ <option>表单标签来选择</option></select> `ManyToManyField`字段的值——如图 [11-23](#Fig23) 和 [11-24](#Fig24) 底部所示。然而，因为这种类型的选择方法对于大型列表来说很麻烦，Django admin 提供了`filter_horizontal`和`filter_vertical`选项来生成单独的面板，使得值选择更容易。图 [11-37](#Fig37) 为`filter_horizontal`选项布局示意图，图 [11-38](#Fig38) 为`filter_vertical`选项布局示意图。

![A441241_1_En_11_Fig38_HTML.jpg](A441241_1_En_11_Fig38_HTML.jpg)

图 11-38。

Django admin filter_vertical option for ManyToManyField

![A441241_1_En_11_Fig37_HTML.jpg](A441241_1_En_11_Fig37_HTML.jpg)

图 11-37。

Django admin filter_horizontal option for ManyToManyField

在图 [11-37](#Fig37) 和 [11-38](#Fig38) 中，你可以看到有两个面板可以选择和取消选择给定`ManyToManyField`的值，唯一的区别是`filter_horizontal`水平堆叠面板-在图 [11-37](#Fig37) 中-而`filter_vertical`垂直堆叠面板-在图 [11-38](#Fig38) 中。

假设`ManyToManyField`字段被命名为`amenities`，为了实现图 [11-37](#Fig37) 中的布局，您将声明`filter_horizontal = ['amenities']`，为了实现图 [11-38](#Fig38) 中的布局，您将声明`filter_vertical = ['amenities']`。

当您在 Django 模型字段中使用`ForeignKey`模型数据类型或`choices`选项，并在 Django 管理中访问它时，Django 还会生成 HTML <select>/ <option>表单标签来选择</option></select> `ForeignKey`字段的值——如图 [11-39](#Fig39) 顶部所示。

![A441241_1_En_11_Fig39_HTML.jpg](A441241_1_En_11_Fig39_HTML.jpg)

图 11-39。

Django admin default select list for ForeignKey or choices option

Django admin 类可以用`radio_fields`选项改变这个默认布局，生成一个带有 HTML 单选按钮的布局。清单 [11-20](#Par125) 展示了 Django 管理类中`radio_fields`选项的两种选择，以及图 [11-40](#Fig40) 和 [11-41](#Fig41) 的 UI 布局。

![A441241_1_En_11_Fig41_HTML.jpg](A441241_1_En_11_Fig41_HTML.jpg)

图 11-41。

Django admin vertical radio_fields option for ForeignKey or choices option

![A441241_1_En_11_Fig40_HTML.jpg](A441241_1_En_11_Fig40_HTML.jpg)

图 11-40。

Django admin horizontal radio_fields option for ForeignKey or choices option

```py
from django.contrib import admin
from coffeehouse.items.models import Item

# Option 1 (Horizontal)

class ItemAdmin(admin.ModelAdmin):
    radio_fields = {"menu": admin.HORIZONTAL}

admin.site.register(Item, ItemAdmin)

# Option 2 (Vertical)

class ItemAdmin(admin.ModelAdmin):
    radio_fields = {"menu": admin.VERTICAL}

admin.site.register(Item, ItemAdmin)

Listing 11-20.Django admin radio_fields option

for ForeignKey field

```

在清单 [11-20](#Par125) 中，你可以看到选项一用`{"menu": admin.HORIZONTAL}`字典定义了`radio_fields`值，其中`menu`代表`ForeignKey`字段或带有`choices`选项的字段，而`admin.HORIZONTAL`是单选字段的方向——该选项生成了如图 [11-40](#Fig40) 所示的布局。清单 [11-20](#Par125) 中的选项二以类似的方式定义了`radio_fields`，除了它使用`admin.VERTICAL`值来告诉 Django admin 为 radio 字段生成一个垂直布局，如图 [11-41](#Fig41) 所示。

对于`ForeignKey`或`ManyToManyField`字段的另一个 Django 管理选项是`raw_id_fields`选项，顾名思义，它依赖于原始的`id`字段值来分配一个`ForeignKey`值或`ManyToManyField`值。图 [11-42](#Fig42) 展示了一个`raw_id_fields`选项在 Django 管理中的样子。

![A441241_1_En_11_Fig42_HTML.jpg](A441241_1_En_11_Fig42_HTML.jpg)

图 11-42。

Django admin raw_id_fields option for ForeignKey or ManyToManyField option

如图 [11-42](#Fig42) 所示，Django admin 生成一个基本文本框，您可以在其中分配`id`值，旁边的放大镜按钮可以帮助您搜索和选择值。假设`ForeignKey`或`ManyToManyField`字段被命名为`menu`，要实现图 [11-42](#Fig42) 中的布局，您需要声明`raw_id_fields = ["menu"]`。请注意，对于`ForeignKey`字段，可接受的值是单个`id`，对于`ManyToManyField`字段，您还可以引入一个由逗号分隔的 id 列表(即 CSV)。

最后，我们来看 Django 管理类`inlines`选项，它是为反向模型关系设计的。当您在 Django admin 中创建或编辑带有关系的模型时，如果这是在带有关系字段定义的模型(即`ForeignKey`或`ManyToManyField`)上完成的，Django admin 会显示相关的模型内联值，或者添加一个“+”按钮来添加新的模型值，如图[11-37](#Fig37)–用于`ForeignKey menu`值–和图[11-39](#Fig39)–用于`ManyToMany amenities`值所示。然而，当您试图编辑或创建逆向模型关系(即没有关系字段的模型)的值时，Django admin 仅显示模型本身，如图 [11-31](#Fig31) 所示。可以使用`inlines`选项编辑或创建反向模型关系的相关模型值。

`inlines`选项首先要求您创建一个 Django admin `TabularInline`或`StackedInline`类，这两个类都是`InlineModelAdmin`类的子类，后者是用于创建标准 Django admin 类的标准`admin.ModelAdmin`类的更专门化版本。一旦有了`TabularInline`或`StackedInline`类，就可以将它声明为`inlines`选项值的一部分。

清单 [11-21](#Par132) 展示了两个 Django 管理示例，它们在具有一对多和多对多关系的模型上使用了`TabularInline`和`StackedInline`类。

```py
# admin.py (ForeignKey)
from django.contrib import admin
from coffeehouse.items.models import Item, Menu

class ItemInline(admin.TabularInline):
    model = Item

class MenuAdmin(admin.ModelAdmin):
    list_display = ['name']
    inlines = [
        ItemInline,
    ]

admin.site.register(Menu, MenuAdmin)

# admin.py (ManyToManyField)
from django.contrib import admin
from coffeehouse.stores.models import Store, Amenity

class StoreInline(admin.StackedInline):
    model = Store.amenities.through

class AmenityAdmin(admin.ModelAdmin):
    inlines = [
        StoreInline,
    ]

admin.site.register(Amenity, AmenityAdmin)

Listing 11-21.Django admin inlines option

for ForeignKey and ManyToManyField field

```

清单 [11-21](#Par132) 中的第一个例子展示了`ItemInline`类，它继承了内置`TabularInline`类的行为。因为最后一个类被设计用来表示 Django admin 中的一个模型，所以它也用`Item`模型类声明了`model`字段。接下来，`MenuAdmin`类是为`Menu`模型类设计的标准 Django 管理类，但是请注意它使用了`inlines`选项和`ItemInline`类。由于这最后一个配置，当您在 Django admin 中编辑或创建`Menu`模型记录时，所有与给定`Menu`模型记录相关的`Item`模型记录都显示在内联中，如图 [11-43](#Fig43) 所示。

![A441241_1_En_11_Fig43_HTML.jpg](A441241_1_En_11_Fig43_HTML.jpg)

图 11-43。

Django admin inlines option with TabularInline for ForeignKey

如图 [11-43](#Fig43) 所示，除了用于编辑或创建`Menu`记录的标准 Django 管理表单，还有一个显示给定`Menu`记录的所有`Item`模型记录的表单集；在这种情况下，表单集包含属于`Drinks Menu`记录的`Item`记录。还要注意图 [11-43](#Fig43) 中表单集中每个表单的表单字段都被内联为选项卡，这是由`TabularInline`类提供的行为。

清单 [11-21](#Par132) 的第二部分展示了从内置`StackedInline`类继承其行为的`StoreInline`类。因为最后一个类被设计用来表示 Django admin 中的一个模型，它还用`Store.amenities.through`模型类声明了`model`字段，这个额外的模型语法——`amenities.through`——是必要的，因为`Store`到`Amenity`模型是多对多的关系。注意`through`关键字是多对多关系查询的标准，在前面的 Django 模型章节中有描述。

接下来，`AmenityAdmin`类是一个为`Item`模型类设计的标准 Django 管理类，但是请注意，它对`StoreInline`类使用了`inlines`选项。由于最后一个配置，当您在 Django admin 中编辑或创建一个`Amenity`模型记录时，所有与给定`Amenity`模型记录相关的`Store`模型记录都显示在内联界面上，如图 [11-44](#Fig44) 所示。

![A441241_1_En_11_Fig44_HTML.jpg](A441241_1_En_11_Fig44_HTML.jpg)

图 11-44。

Django admin inlines option with StackedInline for ManyToManyField

如图 [11-44](#Fig44) 所示，除了用于编辑或创建`Amenity`记录的标准 Django 管理表单，还有一个显示给定`Amenity`记录的所有`Store`模型记录的表单集；在这种情况下，表单集包含具有`Amenity Laptop locks`记录的`Store`记录。还要注意图 [11-43](#Fig43) 中表单集中每个表单的表单字段都是内嵌堆栈，这是由`StackedInline`类提供的行为。

Tip

`InlineModelAdmin`类(即`TabularInline`或`StackedInline`)除了`model`选项之外，还支持前面介绍的标准 Django 管理类—`admin.ModelAdmin`—选项(如`form`、`fields`、`exclude`)，以及第 [6](06.html) 章介绍的标准表单集选项和第 [9](09.html) 章介绍的模型表单集选项(如`formset`、`extra`、`max_num`、`min_num`)。 [<sup>2</sup>](#Fn2)

## Django admin 自定义页面布局、数据和行为

除了前面章节中描述的 Django 管理类选项之外，还有多种方法可以定制 Django 管理页面的布局、数据和行为。您可以定制在所有 Django 管理页面上使用的某些全局值，而无需修改任何 Django 模板。但是除此之外，还可以定制 Django 管理页面使用的任何模板——如登录、注销、密码更新、显示记录和创建/更新/删除记录页面——以改变其布局(例如，修改页面中默认的蓝色 CSS 皮肤或组件位置)。

最后，还可以定制传递给 Django 管理页面的数据，以及通过将方法和字段声明为 Django 管理类的一部分来修改 Django 管理页面运行的默认行为(例如 CRUD 操作)。

### Django admin 默认模板的自定义全局值

默认情况下，Django admin 被配置为 Django 项目的`urls.py`文件的一部分，如下面的代码片段所示:

```py
from django.conf.urls import url
from django.contrib import admin

urlpatterns = [
    url(r'^admin/', admin.site.urls),
]

```

虽然`django.contrib`包中的`admin.site.urls`允许您在`/admin/` url 上设置 Django 管理，但是同一个`django.contrib.admin.site`对象也允许您定制所有 Django 管理页面使用的某些值。

清单 [11-22](#Par146) 展示了如何通过`django.contrib.admin.site`对象定制几个 Django 管理字段。

```py
from django.conf.urls import url
from django.contrib import admin

admin.site.site_header = 'Coffeehouse admin'
admin.site.site_title = 'Coffeehouse admin'
admin.site.site_url = 'http://coffeehouse.com/'
admin.site.index_title = 'Coffeehouse administration'
admin.empty_value_display = '**Empty**'

urlpatterns = [
    url(r'^admin/', admin.site.urls),
]

Listing 11-22.Django admin django.contrib.admin.site object to customize fields

```

Tip

也可以在清单 [11-22](#Par146) 的`settings.py`文件中定义定制的管理字段值。只需导入`django.contrib.admin`并声明管理字段，将它们与`settings.py`中的其他定制配置集中在一起。

正如您在清单 [11-22](#Par146) 中看到的，在将`admin.site.urls`声明为`url`语句之前，在`admin.site`对象上有一系列声明，它们也是`django.contrib`包的一部分:

![A441241_1_En_11_Fig46_HTML.jpg](A441241_1_En_11_Fig46_HTML.jpg)

图 11-46。

Django admin login page with custom global values

![A441241_1_En_11_Fig45_HTML.jpg](A441241_1_En_11_Fig45_HTML.jpg)

图 11-45。

Django admin main index with custom global values

*   `admin.site.site_header`。-定义在所有 Django 管理页面上使用的标题(例如，在深蓝色标题和登录页面中)。参见图 [11-45](#Fig45) 和 [11-46](#Fig46) 。
*   `admin.site.site_title`。-定义所有 Django 管理页面使用的标题，作为 HTML 标题的一部分。参见图 [11-45](#Fig45) 和 [11-46](#Fig46) 。
*   `admin.site.site_url`。-定义作为 Django admin“查看站点”链接的一部分使用的域(例如，`coffeehouse.com`),以便从 Django admin 轻松访问实时站点。见图 [11-45](#Fig45) 。
*   `admin.site.index_title`。-定义 Django 管理主页的标题。见图 [11-45](#Fig45) 。
*   `admin.empty_value_display`。-定义 Django 管理模型值为空时显示的默认值。

正如您在图 [11-45](#Fig45) 和 [11-46](#Fig46) 中所看到的，通过类似清单 [11-22](#Par146) 中的一些简单语句，您可以定制 Django 管理模板内容，而无需与模板或 HTML 交互。

值得注意的是，当记录字段包含空值时，清单 [11-22](#Par146) 中描述的`admin.empty_value_display`选项适用于所有 Django 管理模型。本章前面的“记录显示”部分描述了`admin.empty_value_display`选项的示例，特别是图 [11-5](#Fig5) 和 [11-6](#Fig6) ，以及清单 [11-5](#Par28) 。

### Django admin 自定义页面布局和自定义模板

虽然清单 [11-22](#Par146) 中的`django.contrib.admin.site`对象选项提供了一种快速定制 Django 管理页面的方法，但是在面对更复杂的需求时，它们可能会有所不足，在这种情况下，您必须依赖定制模板。

Django 管理员使用的默认模板位于操作系统或虚拟 env Python 环境中 Django 安装的`/django/contrib/admin/templates/`目录下(例如`<virtual_env_directory>/lib/python3.5/site-packages/django/contrib/admin/templates/`)。

类似于前面章节中描述的 Django 模板定制技术(例如，Django 表单小部件、Django allauth)，您可以创建这些默认模板的副本，并将它们放在您的项目中。通过这种方式，项目中的模板优先于默认的 Django 管理模板，您可以定制项目模板来满足您的需求。

Django admin `/django/contrib/admin/templates/`目录包含两个模板文件夹:`admin`和`registration`。将它们复制到一个项目目录中，该目录是`settings.py`中`TEMPLATES/DIRS`变量的`DIRS`文件夹的一部分。

Tip

请参阅该书附带的源代码，其中包括所有 Django 管理模板的布局。

所有 Django 管理模板都从`admin/base_site.html`模板继承了它们的行为，而模板本身又从`admin/base.html`模板继承了它的行为。如果你不熟悉 Django 模板继承是如何工作的，请阅读第 3 章[描述这个主题。](03.html)

如果您打开`admin/base.html`模板，您可以看到每个 Django 管理页面背后的核心结构，例如 HTML `<head>`部分(例如 CSS 文件、meta 标签)、导航标题和消息通知块等等。因此，您可以修改`admin/base.html`模板来包含定制的 CSS 或 JavaScript 文件，以改变每个 Django 管理页面的“外观”。

除了`admin/base.html`模板，在`admin`和`registration`目录中还有许多其他模板，它们的功能在下面的列表中描述:

*   `admin/404.html`和`admin/500.html`。-分别为 Django admin not found 和 error 页面(即 HTTP 404 和 HTTP 500)定义布局。
*   `admin/index.html`。-定义主页面上 Django 管理索引页面的布局–如图 [11-45](#Fig45) 所示–以及显示所有型号的应用程序索引的布局。
*   `admin/change_list.html`。-定义用于读取记录的 Django 管理列表页面的布局，如图 [11-1](#Fig1) 到 [11-22](#Fig22) 所示。
*   `admin/change_form.html`。-定义 Django 管理表单页面的布局，这些页面用于创建、更新和删除记录，如图 [11-23](#Fig23) 到 [11-44](#Fig44) 所示。
*   `admin/login.html`。-定义 Django 管理员登录页面，如图 [11-46](#Fig46) 所示。
*   `registration`文件夹。-包含各种 Django 管理页面密码更改操作的模板，以及 Django 管理注销页面布局。

Note

此列表中未描述的`admin`文件夹中的其他页面(例如`filter.html`、`object_history.html`)是更细粒度的模板，包含在此列表的较大模板中，您可以根据需要进行定制。

正如您所看到的，通过创建 Django 管理模板的副本并将它们放在您的项目中，您可以通过修改其支持模板来微调每个 Django 管理页面的布局。关于 Django admin `index.html`、`change_list.html`和`change_form.html`模板，一个重要的模块化行为值得一提，那就是它们如何应用于单独的 Django 管理应用或模型。

默认情况下，如果您为`admin/index.html`、`admin/change_list.html`或`admin/change_form.html`模板提供自定义布局，这些模板将用于 Django 管理中的所有应用和模型(即全局)。然而，有时可能需要定制 Django 管理索引页面、列表页面或表格页面，仅用于某些应用程序(例如，`stores`应用程序)或包含单个模型(例如，`Item`模型)。

要为应用程序中的所有模型定义自定义 Django 管理模板，您可以创建一个 Django 管理模板，并将其放在模板路径`admin/<app_name>/`下(例如，`admin/stores/change_list.html`为所有`stores`应用程序模型定义一个`change_list.html`模板)。

要为单个模型定义一个定制的 Django 管理模板，您可以创建一个 Django 管理模板，并将其放在模板路径`admin/<app_name>/<model>/`下(例如，`admin/items/item/change_list.html`定义一个`change_list.html`模板，以便在`items`应用的`Item`模型上使用)。

Note

只有模板`admin/index.html-admin/app_index.html`、`change_form.html`、`change_list.html`、`delete_confirmation.html`、`object_history.html,`和`popup_response.html`可以按应用和型号进行定制。

### Django 管理自定义静态资源

如果您在项目中使用定制 CSS 或 JavaScript 文件定制 Django admin `admin/base.html`模板，这些静态资源将在每个 Django 管理页面上生效。虽然在某些情况下这可能是一个理想的效果，但在其他情况下，可能有必要只对某些 Django 管理页面应用自定义静态资源。

Django 管理类支持`Media`类来定义 CSS 和 JavaScript 文件，并将它们包含在与给定 Django 管理类相关的所有页面上。在 Django 管理类上使用`Media`类的优点是，您不需要处理模板或 HTML 标记，Django 管理会自动加载静态资源，作为链接到管理类的每个管理页面的一部分。清单 [11-23](#Par178) 展示了一个 Django 管理类，它使用了`Media`类。

```py
from django.contrib import admin
from coffeehouse.items.models Item

class ItemAdmin(admin.ModelAdmin):
      list_per_page = 5
      class Media:
            css = {
                "screen": ("css/items/items.css",)
            }
            js = ("js/items/items.js",)

admin.site.register(Item, ItemAdmin)

Listing 11-23.Django admin class with Media class to define custom static resources

```

如清单 [11-23](#Par178) 所示，`Media`类支持`css`和`js`字段分别声明 CSS 和 JavaScript 静态文件。在`css`的情况下，清单 [11-23](#Par178) 声明了一个字典，其中键对应于 CSS 媒体类型，值是一个带有 CSS 文件的元组。对于`js`的情况，清单 [11-23](#Par178) 声明了一个指向 JavaScript 文件的元组。所有声明为`Media`类一部分的文件都会在 Django 的静态文件目录路径中自动搜索——如第 [5](05.html) 章所述。

清单 [11-23](#Par178) 的最终结果是，所有与`ItemAdmin`管理类相关联的 Django 管理页面(例如`index.html`、`change_list.html, change_form.html`)都将包含一个额外的 CSS 导入语句(例如`<link href="/static/css/items/items.css" type="text/css" media="screen" rel="stylesheet" />`)，以及一个额外的 JavaScript 导入语句(例如`<script type="text/javascript" src="/static/js/items/items.js"></script>`)。

值得指出的是，虽然您可以在 Django 管理页面中包含任何第三方 CSS 或 JavaScript 库(例如 Bootstrap、D3)，但是 Django 管理页面已经在`django.jQuery`名称空间下包含了流行的 jQuery 2.2 库来实现某些功能。Django admin 使用一个 jQuery 名称空间，允许您在 Django admin 页面中导入任何其他 jQuery 库版本，而不用担心冲突。如果您想将包含的 Django admin jQuery 库用于您自己的定制 JavaScript，您必须将您的 JavaScript 逻辑包装在这个名称空间中，如下面的代码片段所示:

```py
(function($) {
    // Custom JavaScript logic leveraging the Django admin built-in jQuery libray
    $(document).ready(function() {
       $('.deletelink').on('click',function() {
            if( !confirm('Are you sure you want to delete this record ?')) {
              return false;
           }
       });
    });
})(django.jQuery); // <-- Note wrapping namespace

```

正如您在最后一个代码片段中看到的，通过将您的定制 JavaScript 逻辑包装在`django.jQuery`名称空间中，它获得了对 Django admin 内置 jQuery 库的访问权(即，定制 JavaScript 逻辑获得了对 jQuery `$`范围的访问权)。

Grappelli Project – an Out-Of-Box Django Admin Supplement

如果你想为 Django admin 尝试不同的“外观和感觉”,而不必编写自定义模板或支持 CSS 和 JavaScript 文件，有各种各样的 Django 应用程序为此而设计。

最受欢迎的应用程序之一是“Grappelli 项目”。Grappelli 使用“指南针”CSS 创作框架来包含额外的 Django 管理功能，如:自动完成、内嵌可排序的“拖放”和对 jQuery 插件的支持，等等。

### Django 管理自定义数据和行为，带有管理类字段和方法

虽然 Django 管理模板的修改允许您生成任何类型的 Django 管理页面布局，但对于需要在 Django 管理页面中包含自定义数据(例如，添加来自另一个模型的数据以供参考)或覆盖 Django 管理页面的默认 CRUD 行为(例如，为删除操作执行自定义审计跟踪)的情况，它仍然存在不足。

Django 管理类，就像你在本章中从清单 [11-1](#Par8) 开始编写的那些类，依赖于二十多个字段——所有这些都是你在本章前面的章节中作为 Django 管理读取选项和创建/更新/删除选项探索过的——和三十多个方法 [<sup>4</sup>](#Fn4) 来定义 Django 管理页面的默认数据和行为。

与您如何定制 Django 基于类的视图所使用的默认行为和数据非常相似——如第 [9](09.html) 章所述——Django 管理类也可以定义它们自己的定制字段和方法来覆盖它们的默认数据和行为。

这一章的大部分内容已经涵盖了所有用于定制 Django 管理页面行为的 Django 管理类字段，所以我不再赘述。然而，我将提供最常见的 Django 管理类方法的例子，以说明如何在 Django 管理页面中添加定制数据和覆盖其他默认行为。

清单 [11-24](#Par193) 展示了一个 Django admin 类，它使用了`changelist_view()`方法的自定义实现——在底层 Django admin `change_list.html`模板中添加了要访问的自定义数据——以及`delete_view()`方法的自定义实现——在对 Django admin 类执行删除操作时执行自定义逻辑。

```py
from coffeehouse.stores.models import Store

class StoreAdmin(admin.ModelAdmin):
    search_fields = ['city','state']
    def changelist_view(self, request, extra_context=None):
        # Add extra context data to pass to change list template
        extra_context = extra_context or {}
        extra_context['my_store_data'] = {'onsale':['Item 1','Item 2']}
        # Execute default logic from parent class changelist_view()
        return super(StoreAdmin, self).changelist_view(
            request, extra_context=extra_context
        )
    def delete_view(self, request, object_id, extra_context=None):
        # Add custom audit logic here
        #
        # Execute default logic from parent class delete_view()
        return super(StoreAdmin, self).delete_view(
            request, object_id, extra_context=extra_context
        )

admin.site.register(Store, StoreAdmin)

Listing 11-24.Django admin class with custom 
changelist_view() and delete_view() methods

```

正如您在清单 [11-24](#Par193) 中所看到的，`changelist_view()`和`delete_view()`方法都是用您之前学习的 Django admin `search_fields`选项内联声明的。在这种情况下，每当您在 Django 管理中访问`Store`模型的列表视图页面时，清单 [11-24](#Par193) 中的`changelist_view()`方法就会被触发(例如，如图 [11-10](#Fig10) 所示)。注意,`changelist_view()`方法向`extra_context`变量添加了一个自定义值，然后作为响应的一部分返回，在这种情况下，它是一个硬编码的值，但是您同样可以添加任何类型的数据，比如模型查询或第三方 API 调用，以传递给 Django 管理页面。由于这最后一个工作流，`Store`模型的列表视图页面(即`change_list.html`模板)可以访问定制数据以显示为部分页面。

清单 [11-24](#Par193) 中的`delete_view()`方法在您删除 Django admin 中的`Store`模型时被触发。在这种情况下，清单 [11-24](#Par193) 中的`delete_view()`方法只是通过调用父类的`delete_view()`方法来触发删除记录的默认操作，但是您可以看到，无论何时在 Django admin 中的`Store`模型上执行删除操作，都可以执行定制逻辑(例如，创建审计跟踪)。

正如我已经提到的，Django 管理类依赖三十多种方法来实现它们的默认行为，您可以定制所有这些方法来满足您的需求。考虑到这些方法可以生成大量的自定义变量，您可以使用清单 [11-24](#Par193) 中的示例作为指南，并参考上一页的脚注，了解您可以在 Django admin 类中自定义的其他方法。

## Django 管理 CRUD 权限

默认情况下，Django admin 允许拥有超级用户和职员权限的用户访问——如果您从未听说过 Django 超级用户、Django 职员或 Django 权限这些术语，请参阅前面描述 Django 用户管理的章节。

Django 超级用户，顾名思义，意味着它是一个拥有超级权限的用户。通过扩展，这意味着超级用户可以访问 Django admin 中的任何页面，以及创建、读取、更新和删除 Django admin 中任何类型的模型记录的权限。因为 Django 超级用户代表了一个“要么全有，要么全无”的命题，所以 Django admin 也被设计为允许访问 Django staff 用户。

任何标记为 staff 的 Django 用户都可以访问 Django admin，但除此之外没有其他权限，除非明确授予权限，如图 [11-47](#Fig47) 所示。

![A441241_1_En_11_Fig47_HTML.jpg](A441241_1_En_11_Fig47_HTML.jpg)

图 11-47。

Django admin main page for staff user with no permissions

正如你在图 [11-47](#Fig47) 中看到的，Django 主管理页面是空的。虽然当您在项目的`admin.py`文件中没有注册的模型时，空的 Django 管理主页的场景也会出现，但是这种情况代表了没有显式模型权限的 staff 用户的场景。

为了让员工用户能够访问 Django 管理页面，必须通过模型权限的方式给予他们明确的权限，因为 Django 管理页面是基于 CRUD 模型操作的(例如，创建模型记录的 Django 管理页面，删除模型记录的 Django 管理页面)。

默认情况下，所有 Django 模型都被赋予了`add`、`change,`和`delete`权限，您可以将这些权限分配给 staff 用户。因此，每个模型权限代表一个 Django 管理页面的访问权限。

例如，如果一个 staff 用户被授予了一个模型的`delete`权限，这意味着他还被授予了在 Django admin 中删除该模型记录的权限。类似地，如果一个 staff 用户被授予了一个模型的`add`权限，这意味着他被授予了在 Django admin 中访问该模型的 create record 页面的权限。最后，如果一个职员用户被授予了一个模型的`change`权限，这意味着他被授予了 Django admin 中该模型的编辑记录页面的访问权。

Note

在给定的模型上授予用户`delete`权限也需要授予`change`权限来完成 Django admin 中的删除操作。这是因为 Django 管理记录更改页面上提供了 Django 管理删除操作。

从这种行为可以推断，通过使用 staff 用户和模型权限，您可以允许对 Django admin 的不同部分进行非常细粒度的访问，而不是“全有或全无”的 Django admin 超级用户行为。

不过，Django admin staff 用户还有一个重要的缺失行为:允许对 Django admin 中的模型记录进行只读访问的能力。因为 Django 模型默认拥有`add`、`change`和`delete`权限(即 CUD[创建、更新、删除]行为)，所以`read`权限被认为是隐含了`change`的存在(即如果您能够更改记录，那么您就能够读取它)。因此，要在 Django admin 中获得独立的只读权限，您必须添加一个定制的模型读取权限(即 CRUD 中缺少的 R)。

前一章更详细地描述了定制模型权限，但是我将在清单 [11-25](#Par208) 中通过添加一个只读权限来描述 Django admin 上下文的这个过程。

```py
# models.py
from django.db import models

class Menu(models.Model):
    name = models.CharField(max_length=30)
    creator = models.CharField(max_length=100,default='Coffeehouse Chef')

class Item(models.Model):
    menu = models.ForeignKey(Menu, on_delete=models.CASCADE)
    name = models.CharField(max_length=30)
    description = models.CharField(max_length=100)
    class Meta:

        permissions = (

            ('read_item','Can read item'),

        )

# admin.py
from django.contrib import admin

from coffeehouse.items.models import Item

class ItemAdmin(admin.ModelAdmin):
      list_per_page = 5
      list_display = ['menu','name','menu_creator']
      def get_readonly_fields(self, request, obj=None):

        if not request.user.is_superuser and request.user.has_perm('items.read_item'):

            return [f.name for f in self.model._meta.fields]

        return super(ItemAdmin, self).get_readonly_fields(

            request, obj=obj

        )

admin.site.register(Item, ItemAdmin)

Listing 11-25.Django model with custom read permission and Django admin class enforcing read permission

```

清单 [11-25](#Par208) 中突出显示的第一步是带有自定义权限的`Item`模型，该自定义权限名为`read_item`，友好名称为`'Can read item'`。在您通过相应的迁移运行清单 [11-25](#Par208) 中的`Item`模型之后，`Item`模型将获得一个定制的`read_item`权限。接下来，创建一个 staff 用户，并为其分配`Item`模型的`read_item`和内置`change`权限。一旦 staff 用户被授予这些权限，您必须强制 Django admin 类对`Item`模型只允许具有这些权限的用户进行读访问。

当用户被授予模型的`change`权限时，Django 管理员授予用户访问 Django 管理表单页面的权限，该页面用于更新给定模型的记录，如图 [11-23](#Fig23) 至 [11-44](#Fig44) 所示。但是因为您想将更新功能限制为只读，所以您必须将这个页面的表单字段设置为只读，这就是清单 [11-25](#Par208) 的第二部分中的`get_readonly_fields()`方法的目的。

通过用自定义的`get_readonly_fields()`方法定义一个管理类，您可以告诉 Django 管理员在什么情况下您想要将 Django 管理页面的表单字段设置为只读。在这种情况下，您可以看到清单 [11-25 中的`get_readonly_fields()`方法的逻辑](#Par208)使用`is_superuser()`和`has_perm()`方法来确定调用方是否不是超级用户(即员工)以及用户是否拥有对`Item`模型的`read_item`权限。如果最后一条规则成立，那么`get_readonly_fields()`方法将所有模型表单字段设置为只读，这就是`get_readonly_fields()`方法的全部目的。如果最后一个规则为假，那么`get_readonly_fields()`方法返回其默认行为，调用父类的默认`get_readonly_fields()`方法。

正如您在这个简短的练习中看到的，通过将自定义 Django 管理类方法与标准和自定义 Django 模型权限结合使用，在 Django 管理中没有限制或允许 CRUD 操作。

## 多个 Django 管理站点

通过这一章，你已经了解到 Django 管理站点是使用`django.contrib.admin.site.urls`在`/admin/` url 下激活的。此外，Django 管理站点还要求将 Django 管理类的定义放在 Django 项目的 app `admin.py`文件中，并使用清单 [11-1](#Par8) (例如`django.contrib.admin.site.register(Store,StoreAdmin)`)中描述的技术之一进行注册

虽然这是几乎所有 Django 管理站点安装的标准做法，但是当您想要或需要设置多个 Django 管理站点时，这个过程可能会有所不同。这当然引发了一个问题`'`为什么你想要或者需要多个 Django 管理站点？`'`

多个 Django 管理站点非常有用，因为它们允许您为不同类型的用户或组划分访问位置。例如，您可以设计一个 Django 管理站点，让员工跨不同的模型执行 CRUD 操作，同时设计一个完全不同的 Django 管理站点，让提供者跨另一组模型执行更有限的 CRUD 操作。

如果您维护一个 Django 管理站点，那么为多种类型的用户和模型创建一个解决方案会非常困难，因为您只有强制 CRUD 操作访问的用户权限，如前一节所述。对于多个 Django 管理站点，您可以根据自己的需求在一个或两个管理站点中注册模型。

创建多个 Django 管理站点的第一步是创建多个`django.contrib.admin.AdminSite`类的实例，如清单 [11-26](#Par218) 所示

```py
# urls.py (Main directory)
from django.conf.urls import include, url
from django.views.generic import TemplateView

from django.contrib import admin
admin.site.site_header = 'Coffeehouse general admin'

from coffeehouse.admin import employeeadmin, provideradmin

urlpatterns = [
url(r'^$',TemplateView.as_view(template_name='homepage.html'),name="homepage"),
url(r'^admin/', admin.site.urls),

url(r'^employeeadmin/', employeeadmin.urls),

url(r'^provideradmin/', provideradmin.urls),

]

# admin.py (Main directory)

from django.contrib.admin import AdminSite

class EmployeeAdminSite(AdminSite):

    site_header = 'Coffeehouse Employee admin'

employeeadmin = EmployeeAdminSite(name='employeeadmin')

class ProviderAdminSite(AdminSite):

    site_header = 'Coffeehouse Provider admin'

provideradmin = ProviderAdminSite(name='provideradmin')

Listing 11-26.Django admin multiple sites accessible on different urls

```

首先，注意清单 [11-26](#Par218) 用`urls.py`中的`django.contrib.admin`类声明了标准 Django admin，包括一个定制的`site_header`值，用于在标准`/admin/` url 上挂载 Django admin。接下来，两个自定义 Django 管理实例被配置在它们自己的 URL 上——`/employeeadmin/`和`/provideradmin/`——使用一个对应于自定义`django.contrib.admin.AdminSite`类的`urls`引用。

定制 Django 管理站点类`EmployeeAdminSite`和`ProviderAdminSite`都是在项目顶层目录中它们自己的`admin.py`文件中定义的(即，在主`urls.py`文件旁边)。注意每个自定义 Django 管理站点类是如何从`django.contrib.admin.AdminSite`类继承其行为的。接下来，观察清单 [11-26](#Par218) 中的`AdminSite`类的每个实例如何定义`site_header`字段，以便为每个 Django 管理站点实例定义一个自定义头，就像对标准 Django 管理站点所做的那样。

此时，如果你访问自定义 Django 管理员的`/employeeadmin/`和`/provideradmin/`URL，你将访问如图 [11-47](#Fig47) 所示的 Django 管理员主页。在这两种情况下，您都会看到一个空的 Django 管理页面，因为每个定制的 Django 管理站点仍然没有注册任何模型。

要向一个定制的 Django 管理站点注册 Django 管理类，您可以使用清单 [11-1](#Par8) 中描述的任何技术。不同之处在于，您必须向特定 Django 管理站点的实例(例如`employeeadmin`、`provideradmin`)注册 Django 管理类，而不是默认的`django.contrib.admin`类，如清单 [11-27](#Par223) 所示。

```py
# admin.py (stores app)
from django.contrib import admin
from coffeehouse.stores.models import Store,Amenity

class StoreAdmin(admin.ModelAdmin):
    search_fields = ['city','state']

# Default model registration on main Django admin
admin.site.register(Store, StoreAdmin)

# Model registration on custom Django admin named provideradmin

from coffeehouse.admin import provideradmin

provideradmin.register(Store, StoreAdmin)

# admin.py (items app)
from django.contrib import admin
from coffeehouse.items.models import Menu

class MenuAdmin(admin.ModelAdmin):
    list_display = ['name','creator']

# Default model registration on main Django admin
admin.site.register(Menu, MenuAdmin)

# Model registration on custom Django admin named provideradmin

from coffeehouse.admin import employeeadmin

employeeadmin.register(Menu, MenuAdmin)

Listing 11-27.Django admin class registration on multiple Django admin sites

```

注意在清单 [11-27](#Par223) 中，除了通过`admin.site.register`完成的默认 Django 管理类注册之外，`Store`类注册到自定义`provideradmin` Django 管理类，`Menu`类注册到自定义`employeeeadmin` Django 管理类，这两个都是清单 [11-26](#Par218) 中声明的自定义 Django 管理类。

正如您在清单 [11-27](#Par223) 中看到的，在多个 Django 管理站点上注册同一个 Django 管理类是完全有效的，这个过程允许您有选择地访问不同 Django 管理站点下的某些模型。

Caution

多个 Django 管理站点不排除用户权限、认证或 url 可见性。默认情况下，所有 Django 用户都可以使用相同的凭证，并在多个 Django 管理站点上被分配相同的权限。这意味着由您决定在所有 Django 管理站点上实施有效的模型权限，限制每个 Django 管理站点的模型注册，以及避免容易猜测的 Django 管理 URL 以避免意外访问。

Footnotes [1](#Fn1_source)

[T2`https://docs.djangoproject.com/en/1.11/ref/contrib/admin/actions/`](https://docs.djangoproject.com/en/1.11/ref/contrib/admin/actions/)

  [2](#Fn2_source)

[T2`https://docs.djangoproject.com/en/1.11/ref/contrib/admin/#inlinemodeladmin-options`](https://docs.djangoproject.com/en/1.11/ref/contrib/admin/#inlinemodeladmin-options)

  [3](#Fn3_source)

[T2`http://grappelliproject.com/`](http://grappelliproject.com/)

  [4](#Fn4_source)

[T2`https://docs.djangoproject.com/en/1.11/ref/contrib/admin/#adminsite-methods`](https://docs.djangoproject.com/en/1.11/ref/contrib/admin/#adminsite-methods)