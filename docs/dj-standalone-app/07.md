# 七、应用中的命名空间

> *名称空间是一个非常棒的想法——让我们做更多这样的事情吧！*
> 
> —蟒蛇之禅

在前几章中，我们介绍了如何向您的应用添加一些功能，包括 HTML 模板和静态文件，它们是通过使用应用命名空间来组织和访问的。

在这一章中，我们将了解命名空间的决定是如何渗透到你的独立应用的其余部分，以及如何利用命名空间来使你的应用的集成和使用更加容易。

## 名称空间一览

名称空间是一种组织*命名的*对象的方式——在 Python 和其他语言中——这样它们既有一个父标识符，更重要的是，它们的名称不会冲突。我们已经讨论过几次名称空间，主要是在模板和静态文件目录的上下文中，但是它们的使用远远超出了配置目录以收集文件的范围。

带命名空间

*   两个不同的模块可以各自定义一个名称相同的函数，这样 my_module.does_a_thing 和 your_module.does_a_thing 就不会冲突。

*   两个不同的类可以各自定义一个名称相同的方法，这样 MyClass.does_a_thing 就不会与 YourClass.does_a_thing 冲突。

*   两个不同的字典可以各自包含映射到不同值的相同键，例如 my_dict["key"] = 4，而 your_dict["key"] = 1。

在您自己的项目中，使用不同的名称空间很容易被认为是理所当然的，但是在将代码引入不同的 Django 项目时，您应该花时间确保它有合理的名称空间。

## 应用本身

我们命名一个独立的 Django 应用的切入点是应用本身，更确切地说，是它的模块名和它在 AppConfig 中的命名方式。这是最简单也是最重要的一步。为了避免 Django 项目代码库中的名称冲突，更重要的是，为了使区别更明显，应用名称应该是描述性的，并且不能明显地与已知的现有应用名称重叠，无论是 Django 附带的名称还是为共享而发布的名称。

例如，如果您构建了一个独立的应用来与 stripe 计费服务进行交互，您可能会忍不住将其命名为 Stripe。但是如果这样做，就会与权威的 Stripe Python SDK 发生冲突。相反，你可能会决定把它命名为与 Django 相关的东西，比如 django_stripe 或 djstripe，只是现在后者至少与现有的已发布的独立应用有冲突！如果你的应用是 djstripe 功能的替代品，那么它们不太可能在同一个项目中使用，因此会发生冲突；然而，除非你的应用是 djstripe 的一个分支，否则它很可能会给使用该应用的开发人员带来困惑。在这种情况下，请选择不同的名称。

当一个应用的描述性名称因为冲突而不可用或不明智时，选择一个具有额外上下文的适应名称，如 stripe_billing，或使用同义词或典故，也可以，如 zebra。斑马应用现在是一个无人维护的应用，用于在 Django 项目中集成条纹支付，这样命名是因为斑马有条纹。

## 资源定位符

有多种方法可以将名称空间添加到 URL 中，以使它们在项目中易于识别，并避免命名冲突。在命名冲突的情况下，将使用第一个匹配的*命名的 URL* 。这可能会令人困惑，尤其是在没有引发异常的情况下。

完全可以使用基本 URL 名称本身来建立名称空间。myapp_list 和 myapp:list 之间基本上没有什么差别。后者更清楚名称空间在哪里“中断”，但两者都确保了与列表相关的视图对于 myapp 名称是唯一的。

## 设置

如果你的独立应用允许通过 django.conf.settings 进行配置，那么这些也需要一致的命名空间。在您自己的 Django 项目中可能适用的东西并不能保证在所有其他项目中都适用。

例如，对于一个名为 organizations 的应用，它管理多个用户的帐户，您可能有几个设置来控制要使用的用户模型、每个群组允许的成员数量以及管理员用户是否可以邀请新成员:

```py
GROUP_USER_MODEL = AUTH_USER_MODEL
GROUPS_LIMIT = 8
ADMINS_CAN_INVITE = True

```

虽然在最初的 Django 项目中已经足够混乱，但是影响的范围非常有限。然而，在一个可重用的应用中跨项目传递这些混杂的名字解决了这个问题。因此，请确保项目设置中命名的每个设置*都有一个一致的前言，例如:*

```py
ORGANIZATIONS_USER_MODEL = AUTH_USER_MODEL
ORGANIZATIONS_USER_LIMIT = 8
ORGANIZATIONS_ADMINS_CAN_INVITE = True

```

有关在应用中构建设置和处理默认值的更多信息，请参见第七章。

## 管理命令

Django 的管理命令作为 Django 项目的基于命令行的接口。考虑它们的一个好方法是*视图*，但是用于终端处理而不是 HTTP 请求。独立应用包含管理命令有很多原因:同步数据、导入和导出数据，或者提供创建默认数据的方法。

快速回顾一下，管理命令名来自模块(文件)名。Django 会将定义 BaseCommand 子类的管理/命令中的模块视为命名管理命令。

```py
myapp/
        __init__.py
        management/
                __init__.py
                commands/
                        __init__.py
                        migrate_user_data.py

```

然而，与 URL 名称不同，管理命令名称是全局的。如果您想包含一个管理命令，该命令将跨系统迁移用户数据，使用名称 migrate 将与 Django ORM 的 migrate 命令冲突，覆盖基本的 migrate 命令会引起很大的麻烦。

为了避免名称冲突和明确命令的目的，有两种解决方案:

1.  在命令名(模块名)前加上应用标识符

2.  使每个命令名尽可能具有描述性和唯一性

使用应用名作为管理命令的名称空间并不是一种常见的做法，但这并不意味着这不是一种好的做法。如果你的应用有几个管理命令或者你的应用有一个简单的名字，这是一个好的策略。django-jet 和 dj-stripe 都遵循这种做法，分别在管理命令前面加上 jet_ 和 dj_stripe。在 dj-stripe 的情况下，这意味着 sync_models 的命令被明确定义为与 dj-stripe 相关，而不是全局模糊的命令。

在管理命令的情况下，即使没有名称前缀，使命令名称显式通常也就足够了。这可能包括在其他地方包含应用名称，或者引用应用特有的内容，如一类数据或服务。django-cachalot 提供了 invalidate_cachalot 管理命令，这显然是一个特定于应用的名称，而且它的功能也很清楚。django-reversions 提供 createinitialrevisions 和 deleterevisions。

如果没有类似 URL 的管理命令命名空间方案，您选择哪种策略将取决于上下文。

## 模板标签

> *在 templatetags 包中放置多少模块没有限制。请记住,{% load %}语句将加载给定 Python 模块名称的标签/过滤器，而不是应用的名称。*
> 
> —Django docs

模板标签和过滤器在渲染时向模板添加逻辑和格式功能。添加新的模板标签非常简单，只需在应用中包含一个 template tags 模块，然后将一个或多个标签库作为子模块。

```py
myapp/
        templatetags/
                __init__.py
                myapp_tags.py

```

模板标签和过滤器提出了两个命名空间挑战:

1.  标记库名称是全局的，也就是说，不是与应用相关的名称空间。

2.  单个标签和过滤器被类似地加载到单个 namesapce 中，尽管只是在加载库的模板的上下文中。

这意味着您应该使用名称前缀来保持您的模板标签模块的唯一命名，并命名各个标签和过滤器，以便它们隐式地应用命名空间，至少在它们提供某种特定于应用的功能时。如果标签或过滤器的用途或用途超出了应用中数据的上下文，那么更通用地命名它们可能更有意义。

## 模型和数据库表

由于应用名称本身的原因，应用模型及其各自的数据库表名称都有默认的名称空间。一个项目可能有 15 个不同的应用，每个应用都有自己的模型类 User，这不会造成任何特殊的冲突，只要它们是用别名导入的，它们可能会发生冲突。

```py
from app1.models import User as UserApp1
from app2.models import User as UserApp2
from app3.models import User as UserApp3

```

尽管如此，导入冲突并不是我们在命名和描述性方面寻求避免的唯一问题。如果一个模型既以特定于应用的方式提供服务(即，很难解释如何在应用之外使用它)，又希望在应用之外与其他模型一起使用，则应使用特定于*应用的*命名。

```py
class MyAppUser(models.User):
        """A user model specific to the myapp app"""

```

数据库表命名在开发 Django 项目时基本上是事后才想到的，因为 ORM 会生成默认的表名。虽然关于创建描述性的和人类友好的表名还有一些要说的，但是对于一个可重用的应用来说，主要关心的只是表名中的应用前言应该是唯一的。

假设你有一个应用，它提供了一种面向用户的日志记录，你把这个应用命名为 logs 对于一个独立的应用来说，这不是一个很好的名字，但让我们把它当作一个既定的。数据库表名将以 logs_ 开头，例如，对于名为 LogEntry 的模型，表名将是 logs_logentry。

如果您在 Django 应用之外编写任何 SQL，那么表名缺少源代码范围内模型类所具有的上下文。因此，在本例中，如果您必须维护应用名称日志，那么在您的模型元类中指定 db_table 值是明智的:

```py
class LogEntry(models.Model):
        ...

        class Meta:
                db_table = "activitylogs_logentry"

```

现在，任何编写 SQL 查询或检查数据库的人都会更清楚地了解这个表代表什么以及它包含什么类型的数据。