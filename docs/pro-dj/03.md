# 3.模型

Abstract

数据是大多数现代 Web 应用程序的中心，Django 旨在为各种数据结构和持久性选项提供支持。模型是 Django 使用的传统 MVC 模型的主要方面。对于任何需要跨多个请求、会话甚至服务器实例持久化数据的应用程序来说，模型都是必不可少的一部分。

数据是大多数现代 Web 应用程序的中心，Django 旨在为各种数据结构和持久性选项提供支持。模型是 Django 使用的传统 MVC 模型的主要方面。对于任何需要跨多个请求、会话甚至服务器实例持久化数据的应用程序来说，模型都是必不可少的一部分。

Django 模型被定义为标准的 Python 类，并自动添加了大量的附加特性。在幕后，对象关系映射器(ORM)允许这些类及其实例访问数据库。如果没有这个 ORM，开发人员将需要使用结构化查询语言(SQL)直接处理数据库，这是访问数据库内容的标准方式。

SQL 的主要目标是描述和访问存储在关系数据库中的关系。SQL 一般不为应用程序提供高层关系，因此大多数应用程序都包含用于数据活动的手写 SQL。这肯定是可能的，但是它倾向于导致大量的重复，这本身就违反了第一章概述的 DRY 原则。

散布在应用程序代码中的这些 SQL 很快变得难以管理，尤其是因为必须管理代码的程序员通常不是关系数据库方面的专家。这也意味着这些数据库很容易出现错误，通常很难追踪和修复。

这仍然没有考虑到最大的问题:安全性。SQL 注入 [<sup>1</sup>](#Fn1) 攻击是恶意攻击者访问甚至修改他们不应该访问的数据的常见方式。当手写的 SQL 没有对传递到数据库中的值采取适当的预防措施时，就会发生这种情况。手工编写的 SQL 语句越多，就越容易受到这种类型的攻击。

不管使用何种语言，所有这些问题在 Web 开发中都非常普遍，ORM 是框架减轻这些问题的一种常见方式。有其他方法可以避免这些问题，比如 SQL 注入，但是 Django 的 ORM 是在考虑到这些问题的情况下编写的，并且在幕后处理了大部分问题。通过使用标准 Python 对象访问数据，SQL 的数量被最小化，从而减少了出现问题的机会。

## Django 如何处理模型类

在第 2 章中描述过，Django 最著名的特性之一是其模型定义的声明性语法。这样，模型定义可以简单明了，同时仍然提供大量的功能。在[第 2 章](02.html)中详细描述了将元类用于声明性语法的基本过程，但是在处理模型时还有更多具体的步骤，值得特别注意。

负责处理模型定义的元类是`ModelBase`，住在`django.db.models.base`。这提供了一些关键功能，这里按照执行操作的顺序列出。

A new class is generated to be used for the actual model, preserving the module location where the original model was defined.   If a custom `app_label` wasn’t provided for the model, it’s determined based on the module where it was declared.   `Meta` options are pulled out of the model and placed in a special `Options` object, which is described in more detail later in this chapter.   Two special exception classes, `DoesNotExist` and `MultipleObjectsReturned`, are created and customized for the new model.   A default manager is assigned to the model if one wasn’t already provided.   If the model was already defined—which can happen because of differences in how the module was imported at different stages—the existing model is retrieved from the application cache and returned, making sure that the same class object is always used.   Attributes and methods defined on the original model are added to the newly-created model class.   Settings from inherited parent models are set on the new model.   The new model is registered with the application cache for future reference.   The newly-created model is returned to be used in place of the class that was defined in the source file.  

抽象模型和继承模型是特例，在这种情况下，并非所有这些行为都会发生。这些情况的具体区别将在本章后面介绍。

### 在模型上设置属性

Python 提供了有用的工具来获取和设置对象的属性，而不需要事先知道名称，但是虽然`getattr()`和`setattr()`代表了访问对象属性的标准方式，但是 Django 的一个模型字段钩子需要一些额外的处理。Django 在其所有模型上提供了一个类方法`add_to_class()`，它应该被用作`setattr()`的替代品。

`add_to_class()`的语法和语义与传统函数略有不同。它实际上是一个类方法，而不是内置的甚至是模块级的函数，这意味着类是隐式提供的，而不是显式的第一个参数。这个方法检查提供的值是否存在一个`contribute_to_class()`方法，如果存在就调用它。否则，将使用标准的`setattr()`函数向模型添加值。这些行为是相互排斥的；在给定的`add_to_class()`调用中只会发生一次。认识到这不仅仅是 Django 自己的内部代码，这一点很重要。如果应用程序需要添加任意对象作为模型的属性，它们必须调用`add_to_class()`。这样，使用该应用程序的开发人员可以传入任何对象，并确保它会像直接应用于模型的类定义一样被处理。

当使用[第 2 章](02.html)中描述的自省技术时，整个过程改变了类的外观。为了确定声明的字段、使用的数据库表或模型的显示名称，需要一些额外的知识。

## 获取关于模型的信息

一旦模型和 Django 的`ModelBase`元类一起被 Python 处理，它的原始结构仍然可以通过使用存在于每个 Django 模型及其实例上的属性`_meta`来确定。

在`_meta`上有许多可用的属性，它们组合在一起描述模型，它是如何被定义的，以及提供了什么值来定制它的行为。这些也可以分为两个独立的组:通过查看原始类的实际结构来确定的属性，以及那些被直接指定为模型中定义的`Meta`类的一部分的属性。

REGARDING THE STABILITY OF _META

以下划线开头的名字通常是指不应该直接使用的私有属性。它们通常由本质上更加公开的函数和方法在内部使用，并且通常伴随着关于可能的更改和未记录的行为的警告。在大多数情况下，这些警告是有效的；程序员通常编写供他们自己使用的工具，发现没有必要记录他们的行为或保证他们的寿命。

然而，`_meta`是这个规则的一个例外。虽然它确实是私有 API 的一部分，但在大多数情况下并不是必需的，它与本书中描述的许多工具有一些共同之处；如果理解和正确使用，它可以证明是非常有用的。事实上，`_meta`做得更好，因为它非常稳定，如果不花大力气保持向后兼容，就很难改变。它是 Django 许多内部代码的基础，并且已经被许多第三方应用程序直接访问。

因此，虽然以下划线开头的名字通常意味着危险、潜在的不兼容性和缺乏支持，但你可以非常安全地依赖`_meta`。只要确保跟上 Django 的向后不兼容变更列表就行了。任何会打破`_meta`的新东西都会列在那里。

### 班级信息

虽然第二章中涉及的大多数基本内省技术都适用于 Django 模型，但是还有一些细节也可以在`_meta`属性中找到。其中大部分是 Django 本身需要的信息，以便正确地处理模型，但是和许多其他特性一样，它对其他应用程序也非常有用。

模型的一个重要区别是它们是否被“安装”。这意味着检查包含它们的应用程序是否在站点的`INSTALLED_APPS`设置中列出。Django 的许多特性，比如`syncdb`和内置的管理界面，需要在`INSTALLED_APPS`中列出一个应用程序才能被定位和使用。

如果一个应用程序被设计成直接接受任何 Django 模型，而不是通过`INSTALLED_APPS`迭代，它通常需要某种方法来确定模型是否被正确安装。如果应用程序需要不同地处理模型，这是必要的，例如，取决于数据库操作是否应该在表上执行。为此，Django 提供了`installed`属性，只有当模型属于`INSTALLED_APPS`中列出的应用程序时，该属性才是`True`，否则就是`False`。

模型级信息的另外两个属性通常对应用程序开发人员很有用。正如在《T2》第 2 章中所描述的，所有的 Python 类都提供了一种简单的方法来获得类名和定义它的模块名，分别使用`__name__`和`__module__`属性。但是，在某些情况下，这些信息可能会产生误导。

考虑这样一种情况，一个模型可能被子类化而没有继承所有特定于 Django 的模型继承处理。这需要对元类进行一些调整，但是对于解决某些类型的问题来说是有用的。当这样做时，`__name__`和`__module__`属性将引用子类，而不是位于其下的实际模型。

通常，这是所期望的行为，因为这就是标准 Python 的工作方式，但是当试图与 Django 模型或者可能需要使用它的 Django 的其他领域进行交互时，可能有必要了解模型本身的细节，而不是子类。实现这一点的一种方法是使用类自省来获取正在使用的各种父类，检查每个父类，看它是否是 Django 模型。

这是一个相当难看的过程，需要时间编码，时间执行，使维护和可读性更加困难，如果需要经常做，还会增加样板文件。幸运的是，Django 在`_meta`上提供了两个额外的属性来大大简化这个过程。`module_name`属性包含来自底层模型的`__module__`属性，而`object_name`属于模型的`__name__`属性。

### 字段定义

使用和操作 Django 模型的一个主要挑战是定位和使用为它们定义的字段的过程。Django 使用在第 2 章的[中描述的`creation_counter`技术来跟踪字段的顺序，因此它们可以被放在一个列表中以备将来参考。这个列表存储在模型的`_meta`属性的`fields`属性中。](02.html)

作为一个列表，它可以被迭代以按顺序检索所有的字段对象，这在处理一般模型时非常有用。如本章后面所述，字段对象的属性包含为其指定的所有选项，因此列表中的每一项都可以提供丰富的信息。

这样，我们就可以创建一个定制的表单或模板输出，或者任何其他需要在任意模型上处理字段的特性。考虑下面的例子，它打印出给定对象中每个字段的显示名称和当前值，而不必事先知道使用的是什么模型。

`from django.utils.text import capfirst`

`def get_values(instance):`

`for field in instance._meta.fields:`

`name = capfirst(field.verbose_name)`

`value = getattr(instance, field.name)`

`print('%s: %s' % (name, value))`

这样做允许函数忽略对象背后的模型细节。只要它是一个适当的 Django 模型的实例，`_meta`属性就可用，所有的字段都可以通过这种方式访问。由于 Django 会自动为任何没有声明主键的模型添加一个`AutoField`，所以创建的`AutoField`也会包含在`fields`列表中。

虽然能够遍历列表对于那些需要考虑所有字段的情况来说是很好的，但是有时只需要一个字段，并且该字段的名称是预先知道的。由于`fields`是一个列表而不是一个字典，通过名称获取字段的唯一方法是循环遍历字段，检查每个字段看其名称是否匹配。

为了迎合这种需求，Django 提供了一个实用方法，`_meta.get_field()`。通过向`_meta.get_field()`提供字段名，很容易只检索指定的字段。如果不存在具有该名称的字段，它将引发一个`FieldDoesNotExist`异常，该异常位于`django.db.models.fields`。

为了更好地理解这些方法如何协同工作来标识模型上声明的字段，请考虑下面的模型声明。

`class Product(models.Model):`

`sku = models.CharField(max_length=8, verbose_name='SKU')`

`name = models.CharField(max_length=255)`

`price = models.DecimalField(max_digits=5, decimal_places=2)`

`def __unicode__(self):`

`return self.name`

然后，可以检查模型以获得关于该声明的更多信息，而不必事先知道它看起来像什么。

`>>> from django.utils.text import capfirst`

`>>> for field in Product._meta.fields:`

`...     print('%s: %s' % (capfirst(field.verbose_name), field.__class__))`

`...`

`ID: <class 'django.db.models.fields.AutoField'>`

`SKU: <class 'django.db.models.fields.CharField'>`

`Name: <class 'django.db.models.fields.CharField'>`

`Price: <class 'django.db.models.fields.DecimalField'>`

`>>> Product._meta.get_field('name').__class__`

`<class 'django.db.models.fields.CharField'>`

### 主键字段

通过在字段定义中设置`primary_key=True`，可以将任何字段指定为主键。这意味着，如果代码要处理模型或模型实例，而事先不知道它的定义，那么通常有必要识别哪个字段被定义为主键。

与通过名称获取字段非常相似，可以遍历所有字段，查找属性设置为`True`的字段。毕竟，Django 只允许将一个字段指定为主键。不幸的是，这又引入了大量的样板文件，减慢了速度，并使维护变得更加困难。

为了简化这个任务，Django 提供了另一个`_meta`属性`pk`，它包含将被用作模型主键的 field 对象。这也比遍历所有的字段要快，因为在模型第一次被处理的时候,`pk`被填充了一次。毕竟，Django 需要确定是否需要提供隐式主键。`_meta.pk`属性还用于启用模型实例上的`pk`快捷方式属性，该属性返回实例的主键值，而不管哪个字段是主键。

通常，模型不需要声明显式主键，而是可以让 Django 自动创建一个。这是避免重复这种公共声明的有效方法，同时仍然允许在必要时覆盖它。然而，这样做的一个潜在问题是确定一个模型是否被赋予了一个自动字段，以及这个字段看起来像什么。

基于 Django 如何提供这个自动字段，以及它通常看起来是什么样子，可以对模型做出某些假设。然而，创建一个看起来很像隐式字段的自定义字段是很容易的，如果您的代码只看它的结构和选项，就很难区分这两者。

相反，Django 在`_meta`属性上提供了两个属性来帮助解决这种情况。如果模型让 Django 隐式地提供一个`id`字段，那么第一个字段`_meta.has_auto_field`就是`True`。如果是`False`，模型有一个明确的主键，所以 Django 不需要干预。

与自动主键字段相关的第二个属性是`_meta.auto_field`，它将是作为主键提供的实际字段对象 Django。如果`_meta.has_auto_field`是`True`，这将是一个`AutoField`，并且将总是以相同的方式配置给所有使用它的型号。重要的是查看这个属性，而不是对字段的结构做出假设，以防 Django 在未来做出任何改变。这是一种简单的方法，有助于确保您的应用程序在未来继续正常工作。如果一个模型提供了自己的主键字段，那么`_meta.has_auto_field`就是`False`，那么`_meta.auto_field`将被设置为`None`。

### 配置选项

除了提供对模型上声明的字段的访问，`_meta`还充当所有各种选项的容器，这些选项可以使用`Meta`内部类在模型上设置。这些选项允许模型控制各种事情，例如模型的名称、应该使用的数据库表、记录应该如何排序，以及其他一些事情。

这些选项都有默认值，所以即使那些没有在模型上指定的属性仍然可以通过`_meta`属性获得。以下是以这种方式可用的许多选项的列表，以及它们的默认值和该选项用途的简要描述。

*   `abstract`—一个布尔值，表示模型是否被定义为抽象，这个过程在 Django 的模型继承文档中有更详细的描述。 [<sup>2</sup>](#Fn2) 默认值为`False`。
*   `app_label`—包含 Django 用来识别定义模型的应用程序的名称的字符串。通过查看默认值，最容易理解这意味着什么，默认值是包含指定模型的`models.py`的模块的名称。对于位于`corporate.accounts.models.Account`的模型，`app_label`将是`"accounts"`。
*   `db_table`—Django 将用来存储和检索模型数据的数据库表的名称。如果没有明确定义，它将被确定为模型名称和位置的函数。也就是说，一个叫做`Account`的型号的`db_table`和一个`accounts`的`app_label`将会是`"accounts_account"`。
*   `db_tablespace`—对于 Oracle 以及将来可能出现的其他数据库后端，表可以放在磁盘的不同部分，或者完全放在不同的磁盘上。默认情况下，这只是一个空字符串，它告诉数据库将表存储在默认位置。对于不支持该选项的后端，该选项将被忽略。
*   `get_latest_by`—基于日期的字段的名称，例如`DateField`或`DateTimeField`，它应该用于确定模型的最新实例。如果未提供，这将是一个空字符串。
*   `order_with_respect_to`—与另一个模型相关的字段的实例，在对该模型的实例进行排序时使用。这默认为`None`，这意味着模型的排序完全由模型本身的字段决定，而不是由任何相关的模型决定。
*   `ordering`—包含在对模型的实例进行排序时要使用的字段名称的元组。默认情况下，这是一个空元组，它依赖于数据库来确定模型实例的排序。
*   `permissions`—要添加到模型中的附加权限的元组序列。序列中的每个元组包含两个值，第一个值是要在代码和数据库中使用的权限的名称，第二个值是为用户或组选择权限时要在管理界面中显示的文本。
*   `unique_together`—指示任何字段组的元组序列，当组合时，必须仅在数据库中的一个记录中使用。序列中的每个元组都包含对于特定索引必须是唯一的字段名称。多个元组彼此之间没有任何关系；它们各自代表数据库级别的一个单独的索引。
*   `verbose_name`-模型的单个实例的显示名称。默认情况下，这是由类本身的名称决定的，通过将每个大写部分拆分成一个单独的非大写单词；`Article`会变成`"article"`，而`AddressBook`会变成`"address book"`。
*   `verbose_name_plural`-模型的多个实例的显示名称。默认情况下，这只是结尾带有“s”的`verbose_name`。`Article`会是`"articles"`，`AddressBook`会是`"address books"`。
*   `verbose_name_raw`—`verbose_name`的原始未翻译版本。偶尔，有必要对每个人使用相同的显示名称，而不需要 Django 应用翻译。这在将它存储在缓存或数据库中以供以后访问时特别有用，尤其是如果它将在以后的某个时间点被翻译。

### 访问模型缓存

一旦模型被`ModelBase`元类处理，它们就被放入位于`django.db.models.loading`的名为`AppCache`的全局注册中心。当模块被导入时，它立即被自动实例化，并使用名称`cache`进行访问。这个特殊的缓存提供了对 Django 已知的各种模型的访问，并在必要时安装新的模型。

因为每当 Python 处理类时，`ModelBase`处理新模型的注册，所以它包含的模型不能保证是应用程序的一部分，出现在`INSTALLED_APPS`设置中。这个事实使得记住模型上的`_meta`属性包含一个`installed`属性变得更加重要，这个属性表明模型是否属于一个已安装的应用程序。

每当代码访问本节中的某个特性时，`AppCache`将自动加载`INSTALLED_APPS`中列出的应用程序，确保每当访问某些特性时，缓存中包含所有应该可用的应用程序和模型。如果没有这一点，这些方法的结果将是完全不可预测的，仅仅基于应用程序的加载顺序。

显而易见，只有当所有应用程序都被加载后，应用程序缓存才能被完全填充。因此，如果应用程序的`models.py`调用`AppCache`作为加载过程的一部分，缓存可能还没有完全填充。

为了防止这个问题，`AppCache`提供了一种方法来确定缓存本身是否已经被填充并准备好被访问。调用`cache.app_cache_ready()`将返回`True`或`False`，这取决于是否所有已安装的应用程序都已被正确处理。利用这一点，可以从拥有自己的已知模型缓存中受益的应用程序可以检查该缓存是否可用于该目的。如果是，它可以直接使用这个缓存，如果不是，它可以手动确定它需要知道什么。

#### 检索所有应用程序

当想要反思一个站点的内容时，看看应用程序本身的结构也是非常有用的。毕竟，只有在有模型可看的情况下，查看模型才是有用的，有时需要收集当前使用的所有模型。按照声明它们的应用程序来排列它们也很有用。Django 已经需要将这些信息放在手边，所以`AppCache`被设计成专门管理这些信息。

HOW DOES DJANGO SEE APPLICATIONS?

需要记住的一件重要事情是，Django 需要一个对象作为应用程序的引用。Django 应用程序本质上是一个标准的 Python 包，它只是包含在单个文件夹中的模块集合。虽然 Python 提供了一个对象作为单个模块的引用，但它没有提供任何东西来引用一个包。

因此，Django 可以拥有的最接近应用程序对象的概念是 Python 用来将其识别为包的`__init__.py`模块。在这种情况下，Django 将使用模块对象作为应用程序引用。

不幸的是，很少有项目在`__init__.py`中存储任何有用的东西，所以 Django 不太可能从中找到任何感兴趣的东西。为了获得任何真正有用的东西，它必须执行一些额外的工作来遍历包结构，以获得包含一些相关信息的模块。

相反，因为 Django 无论如何都必须使用一个模块对象，所以使用一个包含有用信息的模块更有意义。对于大多数应用程序来说，包中最有用的模块是`models.py`，在这里定义了所有的 Django 模型。因此，Django 使用这个模块来识别应用程序。下面的一些方法返回一个应用程序，在每种情况下，它都返回应用程序包中的`models`模块。

站点范围内自检的第一步是确定安装了什么应用程序。调用`cache.get_apps()`将返回这样一个列表，其中包含包含一个`models`模块的`INSTALLED_APPS`设置中每个应用程序的应用程序模块。这并不是说它只返回有模型的应用程序。它实际上检查一个`models`模块的存在，所以即使一个空的`models.py`也会导致一个应用程序被包含在这个列表中。

以下面的`INSTALLED_APPS`设置为例，展示了 Django 自己贡献的几个应用，以及一些内部应用和[第 7 章](07.html)中描述的`signedcookies`应用。

`INSTALLED_APPS = (`

`'django.contrib.admin'`，

`'django.contrib.auth'`，

`'django.contrib.contenttypes'`，

`'django.contrib.sessions'`，

`'django.contrib.sites'`，

`'news'`，

`'customers'`，

`'callcenter'`，

`'signedcookies'`，

`)`

这些应用程序中的大多数必然会包含各种模型。[第七章](07.html)的`signedcookies`，然而，只与网站的 HTTP 流量交互，所以它对数据库没有用处。因此，当查看`cache.get_apps()`的结果时，`signedcookies`应用程序不会出现。

`>>> from django.conf import settings`

`>>> from django.db.models.loading import cache`

`>>> len(settings.INSTALLED_APPS)`

`9`

`>>> len(cache.get_apps())`

`8`

`>>> for app in cache.get_apps():`

`...     print(app.__name__)`

`...`

`django.contrib.admin.models`

`django.contrib.auth.models`

`django.contrib.contenttypes.models`

`django.contrib.sessions.models`

`django.contrib.sites.models`

`news.models`

`customers.models`

`callcenter.models`

#### 检索单个应用程序

有了应用程序列表，就可以直接从每个应用程序中获取模型，这样就可以对它们进行适当的处理。下一节将更详细地描述这个过程。然而，查看所有模型并不总是最好的方法；有时，一个应用程序可能被赋予一个特定应用程序的标签，因此它可以只处理该应用程序中的模型。

虽然可以循环遍历来自`cache.get_apps()`的结果，对照应用程序模块的`__name__`属性检查模块名称，但是这种技术很快会遇到一些问题。首先，应用程序的标签和它的`__name__`属性不同，所以试图比较这两个结果需要很多额外的代码，其中大部分已经由 Django 完成了。此外，代码必须经过测试和维护，这增加了将错误引入应用程序的风险。

相反，Django 提供了一个实用程序来处理这种情况。通过将已知的标签传递给`cache.get_app()`，应用程序可以检索与该特定标签匹配的应用程序的应用程序模块。此处引用的标签被确定为应用程序导入路径的特定部分。

通常称为`app_label`，应用程序的标签通常由应用程序模块导入路径的最后一部分组成，在`models`部分之前。为了举例说明，考虑下面的应用程序标签，对应于`INSTALLED_APPS`设置中的条目。

`admin`

`auth`

`contenttypes`

`sessions`

`sites`

`news`

`customers`

`callcenter`

`signedcookies`

这里有一点需要注意。作为官方文档中描述的`Meta`选项的一部分，并且在本章前面简单地提到过，任何模型都可以覆盖它自己的`app_label`设置，就像它是在不同的应用程序中声明的一样。这个选项不会以任何方式影响`cache.get_app()`的行为。`get_app()`方法只是将`app_label`映射到一个应用程序模块，而不考虑其中的模块可能声明了什么选项。

正如前面的`cache.get_apps()`所展示的，没有模型的应用程序在 Django 内部被认为与其他应用程序略有不同。默认情况下，如果应用程序不包含`models.py`文件，`cache.get_app()`将引发一个`ImproperlyConfigured`异常。有时，在没有模型的情况下处理应用程序可能仍然有用，所以`cache.get_app()`接受一个可选的第二个参数来控制如何处理这样的应用程序。

第二个参数叫做`emptyOK`，它采用一个布尔值来表示应用程序是否允许不包含任何模型。这默认为`False`，这将引发`ImproperlyConfigured`异常，但是如果改为给出`True`，`cache.get_app()`将简单地返回`None`，允许调用代码继续管理应用程序。

`>>> from django.db.models.loading import cache`

`>>> print(cache.get_app('admin'))`

`<module 'django.contrib.admin.models' from ...>`

`>>> print(cache.get_app('signedcookies'))`

`Traceback (most recent call last):`

`...`

`django.core.exceptions.ImproperlyConfigured: App with label signedcookies could not be found`

`>>> print(cache.get_app('signedcookies', emptyOK=True))`

`None`

#### 处理单个模型

一旦知道了应用程序，下一步就是处理该应用程序中的各个模型。再一次，`AppCache`提出了一些处理这种情况的方法。从缓存中检索模型通常采用两种形式中的一种，这取决于事先对模型的了解程度。

第一种情况，考虑纯内省。记住上一节,`AppCache`通过对返回应用程序模块的`get_apps()`方法的一次调用来提供对所有已知应用程序的访问。因为这些模块实际上是每个应用程序中的`models`模块，所以使用`dir(app_module)`或迭代`app_module.__dict__`来获得已定义的模型似乎很容易。

不幸的是，像简单迭代的许多用法一样，这需要循环检查模块中的每个单独的对象，看看它实际上是一个模型，还是完全是别的什么东西。毕竟，Python 模块可以包含任何内容，并且许多模型利用元组和模块级常量来帮助完成工作，所以不能保证模块名称空间中的每一项实际上都是 Django 模型。

相反，`cache.get_models()`检索特定于给定应用程序模块的适当 Django 模型的列表。`cache.get_apps()`和`cache.get_app()`都返回应用模块，这不是巧合；`cache.get_models()`适用于这两种方法。这意味着即使没有应用程序也可以检索模型列表，但是提前知道应用程序可以减少检索到的模型数量。

下面的代码演示了如何结合使用这些技术来检索站点上使用的每个已知应用程序的模型列表。

`>>> from django.db.models.loading import cache`

`>>> for app in cache.get_apps():`

`...     app_label = app.__name__.split('.')[-2]`

`...     for model in cache.get_models(app):`

`...         print('%s.%s' % (app_label, model.__name__))`

`...`

`admin.LogEntry`

`auth.Message`

`auth.Group`

`auth.User`

`auth.Permission`

`contenttypes.ContentType`

`sessions.Session`

`sites.Site`

`news.News`

`customers.Customer`

`callcenter.Agent`

`callcenter.Call`

`callcenter.Case`

作为一个附加选项，`get_models()`也可以不带参数调用，这将导致它返回`AppCache`已知的所有模型。这是一个有用的捷径，可以避免与本例中的额外循环相关的一些开销，作为获取所有模型的快速方法。

然而，有一个问题。

直接使用`get_models()`时，不带参数，返回所有注册的模型。这听起来可能是个好主意，有时确实如此，但是请记住`AppCache`会在遇到模型时注册所有模型，不管它们是在哪里发现的。完整列表可能包括不属于已安装应用程序的型号。与之形成对比的是`get_apps()` / `get_models()`组合，它只检索在`INSTALLED_APPS`设置中找到的应用程序的模型。

实际上，如果不带参数调用，`get_models()`可能会返回与调用从`get_apps()`返回的每个应用程序不同的结果。通常，这可能意味着应用程序可以访问它不想知道的额外模型。有时候这确实是我们想要的行为，但是理解其中的区别总是很重要的。

一个模型可能在`AppCache`中，但没有被安装，如果应用程序是从一个单独的、已安装的应用程序中导入的，这将导致它的模型类被 Django 处理并注册，不管它是否在`INSTALLED_APPS`中。同样，如果任何模型在它的`Meta`类中指定了一个`app_label`，而这个应用程序标签与任何已安装的应用程序都不匹配，也会出现同样的情况。如果应用程序确实希望访问所有的模型，不管它们是否被安装，记住它可以使用`_meta.installed`属性来识别哪些模型被正确安装。

有时，会提供应用程序和模型的名称，可能作为 URL 或其他配置的一部分。在这些情况下，迭代给定应用程序的所有模型没有多大意义。对于这种情况，`AppCache`提供了另一种方法，`get_model()`，它根据应用程序标签和模型名称检索模型类。应用程序名称区分大小写，但模型名称不区分大小写。

`>>> from django.db.models.loading import cache`

`>>> cache.get_model('auth', 'user')`

`<class 'django.contrib.auth.models.User'>`

## 使用模型字段

模型最重要的方面之一是可用于保存数据的字段集。没有字段，模型就只是一个空容器，没有办法做任何有用的事情。字段提供了一种组织模型值并根据特定数据类型进行验证的方法，在数据库和原生 Python 数据类型之间架起了一座桥梁。

通常，当访问作为模型实例属性的字段时，该值将是一个标准 Python 对象，表示数据库中的值。本章的前几节描述了访问实际字段对象本身的各种方法，而不是这个转换后的值。使用字段对象可以做许多有用的事情。

### 公共字段属性

根据需要，不同的字段类型会有不同的属性，但是有几个属性是大多数内置 Django 字段共有的。这些可用于一般访问字段的各种细节，并通过关联访问它们要与之交互的值和行为。请注意，内部使用的属性比这里列出的更多，但这些是最有用和最稳定的，并将为希望使用字段的应用程序提供最大的价值。

这里列出的描述是 Django 本身如何使用这些属性，以及开发人员期望它们如何表现。其他应用程序也可能使用它们来控制某些类型的行为，因此下面的描述将有助于说明它们的预期用途。

一些应用程序可能会找到与 Django 本身预期用途略有不同的用途，但是值的一般语义应该保持不变。请记住，开发人员将根据 Django 本身的行为来构建他们对这些值的期望，第三方应用程序应该避免违反这些期望。

*   `attname`—存储数据库相关值的模型实例的属性名称。对于数据库中的值直接存储在模型中的简单情况，这通常与`name`属性相同。在其他情况下，当实际的字段名被访问时，向其他代码公开一个更复杂的对象，比如另一个模型实例，会更合适。对于这些情况，`attname`和`name`会有所不同，`name`引用的属性是复杂对象，而`attname`引用的属性包含创建它所需的原始数据。
*   `blank`—一个布尔值，指示当使用基于模型自动生成的表单时，该字段是否必须提供一个值。这纯粹是与验证相关的行为；`null`属性控制一个模型是否可以在没有给定字段值的情况下保存在数据库中。
*   `choices`—指示字段有效选项的二元组序列。每个元组中的第一项是实际值，如果被选中，它将存储在数据库中，而第二项是将为该值向用户显示的文本。
*   `column`—将用于保存字段值的数据库列的名称。如果字段明确声明了它的数据库列，那么它将匹配`db_column`，或者根据字段的名称自动生成。通常可以忽略这一点，因为 Django 直接管理数据库交互，但是有些应用程序可能需要直接与数据库通信，或者与需要这一信息的其他数据库适配器接口。
*   `db_column`—明确作为字段值的数据库列名提供的名称。这与`column`不同，因为`db_column`指的是模型本身声明的内容，而不是实际将要使用的内容。只有当模型字段明确指定了它的`db_column`参数时，它才会有值；否则就是`None`。
*   `db_index`—一个布尔值，指示字段是否被声明为在数据库中为其创建了索引。这仅表明该字段是否被配置为指示 Django 创建索引。其他索引可能已经直接添加到数据库本身中，这不一定会反映在该属性的值中。
*   `db_tablespace`—表示字段数据存储位置的表空间指令。目前仅支持 Oracle 后端，其内容的格式将取决于数据库后端。它总是有一个字符串值，如果没有明确设置，默认为`DEFAULT_INDEX_TABLESPACE`设置的值。
*   `default`—字段的默认值，如果尚未向字段本身提供值，则使用该值。在这种情况下，除了插入数据库之外，该值还将用作基于模型生成的任何表单的字段初始值。存储在该属性中的值的类型将是该字段要与之交互的任何本机 Python 数据类型，例如字符串或整数。
*   `description`—字段或其用途的简单文本描述。docstring 通常也很有用，但是这种描述可以在显示应用程序内部的字段信息时使用，比如`admindocs`。
*   `editable`—一个布尔值，指示在基于模型生成表单时，是否应向用户显示该字段以供编辑。这并没有使字段本身在 Python 中成为只读的，因此也不能保证字段不会被编辑。它只是一个控制表单默认行为的指令，尽管其他应用程序也可以——也应该——使用它来控制其他行为，如果它们提供编辑功能的话。
*   `empty_strings_allowed`—一个布尔值，指示字段是否允许空字符串作为可能的值。这不是作为特定字段实例的配置指定的选项，而是在字段的类本身中定义的。许多字段，如`CharField`和`EmailField`，将空字符串与`None`分开处理，因此该属性允许后端决定如何为数据库(如 Oracle)处理空字符串，否则这些数据库可能会失去这种区别。
*   `help_text`—在字段定义中提供的信息性文本，当字段呈现以供编辑时向用户显示。这将被传递给基于模型生成的表单，比如提供的管理界面。
*   `max_length`—字段值可以包含的最大长度。大多数基于字符串的字段，比如`CharField`和`EmailField`，都使用这个来限制字符串内容的长度，无论是在表单字段还是底层数据库列中。其他字段类型，比如`IntegerField`和`DateField`，可以忽略它，因为它在这些情况下没有任何意义。
*   `name`—字段的名称，在将字段分配给模型时定义。这被设置为`contribute_to_class()`过程的一部分，通过避免两次输入名字来保持干燥。这将是属性的名称，将在该属性中分配和检索字段的本地 Python 值。与此形成对比的是`attname`，它存储了填充`name`所需的原始数据。通常，这两个值是相同的，但是对于它们不同的情况，理解它们的区别是很重要的。
*   `null`—一个布尔值，指示字段是否可以在没有赋值的情况下提交到数据库。这主要控制如何创建底层数据库列，但是只要语义保持不变，一些应用程序可能会找到其他用途。
*   `primary_key`—一个布尔值，指示该字段是否应该用作数据库表的主键。除了指示数据库生成主键索引之外，Django 还使用这个指示器来确定在查找特定实例时使用哪个字段的值，比如通过外键关系查找相关对象。参见本章前面的“主键”一节，详细了解用于确定哪个字段的值设置为`True`的`_meta.pk`快捷键。
*   `rel`—对于将一个模型与另一个模型相关联的字段，这将是一个描述该关系的各个方面的特殊对象。对于所有非关系字段类型，这将被设置为`None`。
*   `serialize`—一个布尔值，指示当使用序列化框架序列化模型实例时是否应包含该字段。[<sup>3</sup>T4】](#Fn3)
*   `unique`-一个布尔值，表示该字段在模型的所有实例中必须是唯一的。这主要用于在数据库中创建适当的约束来强制执行该条件，但它也可以由应用程序使用。例如，提供关于用户输入的值对于模型是否有效的详细反馈的内容编辑应用程序在做出该决定时也可以考虑这一点。
*   `unique_for_date`—与日期相关的字段的名称，例如`DateField`或`DateTimeField`，其值应该是唯一的。这在本质上类似于`unique`，除了根据该属性引用的字段，约束被限制为发生在同一天的记录。这不能在数据库级别强制执行，所以 Django 手动管理约束，就像任何其他需要提供给定对象是否可以提交到数据库的详细信息的应用程序一样。
*   `unique_for_month`—与`unique_for_date`类似，不同的是只有发生在同一个月的对象才需要唯一性，根据该属性包含的名称所引用的日期相关字段。
*   `unique_for_year`—与`unique_for_date`类似，不同的是只有发生在同一年的对象才需要唯一性，根据该属性包含的名称所引用的日期相关字段。
*   `verbose_name`—用简单的英语显示给用户的字段的全名。Django 的文档建议以小写字母开头，这样应用程序就可以在必要时使用大写字母。如果一个应用程序需要将这个值资本化，一定要使用`capfirst()`实用程序方法，在[第 9 章](09.html)中有描述。

### 常见的现场方法

与上一节描述的属性一样，这些方法对于大多数字段类型来说都是通用的，并且提供了大量的功能，否则很难获得这些功能。并非所有的字段类型都会实现所有这些方法，它们的确切行为可能会根据所涉及的字段类型而变化，但是这里描述的一般语义将保持不变。

还有更多在内部使用的方法，这里没有列出，因为它们主要负责简单地填充上一节描述的属性。因此，通常最好是简单地引用生成的属性，而不是试图在事后手动重新创建它们。

*   `clean(value, instance)`—验证给定的`value`是否适合模型，以及它被分配到的`instance`。在内部，这遵从于`to_python()`和`validate()`，以及处理字段实例化时定义的验证器列表。如果一切都有效，它将返回一个正确的值，否则将引发`django.core.exceptions.ValidationError`。
*   `contribute_to_class(cls, name)`—为其附加的类配置字段。字段上最重要的方法之一，当`ModelBase`处理分配给模型的类定义的属性时，就会调用这个方法。`cls`参数是它被分配到的模型类，`name`是它被分配到那里时的名字。这使得现场人员有机会根据这些信息执行任何额外的设置或配置。通常不需要直接调用它，但是它是将字段应用到先前处理的模型的一种有用的方法。
*   `db_type(connection)`—返回该字段存储其数据所需的特定于数据库的列定义。通常，这仅在内部使用，但是与列出的一些其他属性一样，如果应用程序需要使用一些其他工具直接访问数据库，这可能是确定基础列的有用方法。
*   `formfield()`—根据字段的数据类型和详细名称返回表单字段，适合包含在任何标准表单中。它可以选择一个显式参数`form_class`，这是一个要实例化的表单字段类，默认为最合适的表单字段，由模型字段本身定义。它还接受任意数量的附加关键字参数，这些参数只是在返回实例化的表单域之前通过表单域的构造函数传递。这通常由 Django 在基于模型构造表单时自动调用，但是在其他情况下也可以手动使用。更多信息可以在[第 5 章](05.html)中找到。
*   `get_attname()`—返回应该用于`attname`属性的名称。这仅在为类配置字段时调用一次。
*   `get_attname_column()`—返回包含用于`attname`属性和`column`属性的值的两项元组。
*   `get_cache_name()`—如果需要缓存，返回适合用作字段缓存的名称。这通常只适用于生成复杂 Python 数据类型的字段，如果每次访问都必须生成这样一个复杂的对象，或者在不使用它的情况下，性能会受到严重影响。有关如何在这种情况下使用这种方法的详细信息，请参见本章末尾的应用技术。
*   `get_choices()`—返回一个二元组序列，该序列应用于向希望在该字段中输入数据的用户显示选项。与`choices`属性不同，这可能还包括一个空选项，表示没有做出选择。这种行为由两个可选参数控制:`include_blank`，一个布尔值，表示是否应该包括它；以及`blank_choice`，一个元组列表，包含应该用于空选项的值和显示文本。默认情况下，这些参数被配置为包含对`("", "---------")`的单一选择。
*   `get_db_prep_lookup(value, lookup_type, connection, prepared=False)`—返回所提供值的表示形式，适合与数据库中的现有值进行比较。
*   `get_db_prep_save(value, connection)`—返回适合存储在数据库中的所提供值的表示形式。
*   `get_db_prep_value(value, connection, prepared=False)`—返回所提供值的表示形式，可用于数据库的一般用途。这由`get_db_prep_lookup()`和`get_db_prep_save()`内部调用。
*   `get_default()`—返回将用于字段的默认值。这处理了所有必要的逻辑，检查是否提供了默认值，如果缺省情况下提供了一个 callable，则执行它，并为需要该行为的数据库后端区分空字符串和`None`。
*   `get_internal_type()`—返回一个字符串，表示字段包含的数据类型的高级概念。这主要用于与每个数据库后端提供的映射一起确定要使用的实际数据库列。
*   `get_prep_lookup(lookup_type, value)`—类似于`get_db_prep_lookup()`，除了这个方法用于简单的转换，不需要知道使用哪种类型的数据库。
*   `get_prep_value(value)`—类似于`get_db_prep_value()`，除了这个方法用于简单的转换，不需要知道使用哪种类型的数据库。
*   `has_default()`—如果字段有关联的默认值，则返回`True`，如果默认行为将留给数据库后端，则返回`False`。
*   `pre_save(model_instance, add)`—返回保存到数据库之前的字段值。默认情况下，这只是返回已经在所提供的`model_instance`上设置的值，但是它也可以返回从其他字段派生的值，或者可能与实例完全无关的值，比如当前时间。`add`参数是一个布尔值，表明所提供的实例是否是第一次被添加。
*   `save_form_data(instance, data)`—将提供的数据存储到提供的实例的适当属性中。这是表单能够基于表单数据充分填充模型实例的快捷方式。
*   `set_attributes_from_name(name)`—使用提供的`name`参数根据需要设置字段的`name`、`attname`、`column`和`verbose_name`属性。对于`attname`和`column`值，该方法遵从`get_attname_column()`,而`verbose_name`只有在实例化字段时没有显式定义时才在这里设置。
*   `to_python(value)`-将提供的值强制转换为本地 Python 数据类型，以便在访问模型实例上的字段值时使用。详见本章后面对它的描述。
*   `validate(value, instance)`-如果字段的值适合于字段的配置和模型实例上的其他数据，则无错误返回，否则引发`django.core.exceptions.ValidationError`。这是`clean()`内部的叫法。
*   `value_from_object(obj)`—返回字段在所提供对象上显示的值。

## 子类化字段

使用 Django 模型可以做的一件更有用的事情，特别是对于可重用的应用程序，是与模型以通用方式处理单个类型的字段的能力结合起来。这使得字段本身能够很好地控制它们与数据库的交互方式、使用何种原生 Python 数据类型来访问它们的内容，以及如何将它们应用到使用它们的模型类。

本节的大部分内容假设自定义字段需要保留现有字段的许多相同功能，例如与数据库和生成的表单交互。还有许多其他的应用程序，比如在第 11 章中描述的历史记录应用程序，它们使用本节中描述的钩子来提供比简单字段更多的功能。

这里的术语“字段”是用来描述任何使用这些技术向 Django 开发人员呈现类似于标准 Django 模型字段的对象。实际上，这种对象可以封装复杂的关系，比如标记应用程序，甚至可以根据它们被分配到的模型，动态地控制整个新 Django 模型的创建。可能性几乎是无限的。

要记住的关键是 Django 在字段方面使用了 duck 类型化原则。它只是在每种情况下访问它期望的任何属性和方法，而不考虑这些属性和方法在幕后实际做了什么。事实上，使用这些钩子甚至不需要对象是`django.db.models.fields.Field`的子类。从`Field`继承只是提供了一种简单的方法来重用现有的大部分功能，如果需要这种行为的话。

### 决定是发明还是扩展

当编写一个新的字段时，首先要考虑的事情之一是，是尝试创造一个全新的字段类型，也许是在完全没有`Field`帮助的情况下从零开始，还是扩展一些现有的字段类型并继承它的大部分行为。每种方法都有优点和缺点，哪种方法最合适在很大程度上取决于新领域的需求。

通过继承`Field`或它的一个子类，下面部分中的大多数行为将被继承，潜在地减少了定制字段必须包含的新代码的数量。如果它的行为类似于一个现有的字段类型，这将是一个非常有用的方法，不仅可以减少新代码，有助于减少 bug，还可以自动接收 Django 本身在未来版本中提供的任何新的或更新的功能。毕竟，通过依赖 Django 本身来实现这种行为，对代码的更新将自动反映在定制字段的行为中。

另一方面，如果新的字段与任何现有的字段类型有很大的不同，那么无论如何都需要重写标准行为以供自己使用，从而否定从父类继承的任何值。如果这些行为中的大部分——或者全部——都必须从头开始编写，那么从现有字段继承只会在 Python 用来管理类的过程中增加一个额外的步骤，即使这个额外的步骤没有带来什么好处。因此，在这些情况下，最好从零开始，只实现那些对定制字段有意义的行为，由于使用了 duck 类型，Django 仍然会正确地处理它。

当然，这两种方法之间有一些中间地带。例如，一个定制字段可能与一个完全唯一的数据类型交互，与任何现有的字段类型几乎没有相似之处，但是它可能仍然像一个标准字段一样将其数据存储在数据库中，并且可以从重用 Django 的许多更基本的字段方法中受益，例如分配名称并将其自身存储在`_meta.fields`中。在这些情况下，从`Field`本身继承，而不是从一个特定的子类继承，并且只继承这个最基本的功能是非常合理的。

### 在模型注册期间执行操作

任何字段经历的第一步都是由`ModelBase`元类处理，每当 Python 遇到利用该字段的模型类时。对于标准的 Python 对象，这意味着像平常一样简单地分配给模型类，没有额外的处理。然而，字段采取不同的路径，并且每个字段都有机会定制它如何应用于模型类。

#### contribute_to_class(self，cls，name)

这可能是一个字段可以包含的最重要的方法，因为它提供了一个基本特性:字段能够知道它被分配给了什么类，以及它被赋予了什么名称。这似乎是一个简单的要求，但是 Python 本身通常没有一种方法来实现这一点。

您可能还记得在第 2 章的[中描述的描述符，它有一种方法来识别哪个类——甚至是那个类的哪个实例——被用来访问对象，但是这只有在访问属性时才可用；仍然没有办法知道任务发生时的信息。更重要的是，即使是描述符也没有提供任何方法来识别使用了什么名称来访问它们，这在试图缓存信息或者与需要使用名称的其他特性(比如数据库列)进行交互时会是一个相当大的问题。](02.html)

相反，通过使用元类，Django 可以在 Python 处理类的地方进行调解，并使用一个`contribute_to_class()`方法来识别需要不同处理的对象。如果这个方法存在，它将代替标准的`setattr()`被调用，允许字段以最适合其用途的方式注册自己。这样做的时候，Django 还提供了类本身作为参数，以及它被赋予的名称，这是在查看分配给该类的属性时发现的。因此，除了通常的`self`之外，这个方法还收到两个参数。

*   `cls`—该字段被分配到的模型的实际类对象。这可用于根据模型本身的名称或其他属性定制字段。
*   `name`—分配给模型类的属性的名称，以字符串形式表示。字段通常会将其存储为字段本身的属性，以供将来参考。

一旦这两个参数以适合该字段的任何方式被处理，该方法就不应该返回任何东西，因为它的返回值被 Django 忽略了。

CONTRIBUTE_TO_CLASS() VS SETATTR()

和`contribute_to_class()`打交道的时候有一件很重要的事情要记住。它已经在不同的地方被提到过几次，但是它是如此的重要，以至于它值得被非常明确地带回家。如果 Django 发现一个对象有一个`contribute_to_class()`方法，那么只有那个方法会被调用。

通常，`setattr()`用于设置一个对象(比如一个类)的属性，但是由于模型字段不能在标准名称空间中设置，所以有意跳过了这一步。因此，如果一个定制字段确实需要被设置为模型类本身的一个属性，那么在执行它的`contribute_to_class()`方法期间，这样做是字段本身的唯一责任。

有时，字段需要设置一些其他对象，如描述符，作为类的属性，为其他类型的访问提供额外的自定义。这也是 field 类的责任，并且只有在执行它的`contribute_to_class()`方法时才能保持标准字段的外观。

在标准 Django 字段的情况下，也许对于许多类型的定制字段和其他表现为字段的对象，这种对`setattr()`的避免是有意的。如果需要这种行为，`contribute_to_class()`应该简单地避免在模型类上设置任何东西，Django 自己的行为将确保没有任何东西被分配给类本身。

#### contribute _ to _ related _ class(self，cls，related)

对于与其他模型相关联的字段，一旦相关模型可用，就会调用这个函数，这样属性也可以添加到该模型中。例如，当应用了`ForeignKey`时，Django 就是这样在相关类上提供一个反向属性的。

它接收的两个参数是`cls`，关系实际应用到的模型类，和`related`，关系指向的模型，其中可能还需要应用其他属性。像`contribute_to_class()`一样，它不应该返回任何东西，因为它无论如何都会被忽略。

### 改变数据行为

鉴于大多数字段类型都是为了与特定的数据类型交互而存在的，首先要考虑的事情之一就是如何告诉 Django 处理该数据类型。这包括如何将其存储在数据库中，如何确保其值的有效性，以及如何用 Python 表示该值。这些是现场行为的一些最基本的方面，适当地改变它们可以打开一个可能性的世界。

#### get_internal_type(自身)

该方法返回一个字符串，该字符串有助于确定数据库应该如何存储字段的值。字符串本身不是实际的数据库列类型，而是应用于数据库后端提供的映射，以确定使用哪种类型的列。通过这种方式，可以编写字段，而不必绑定到特定的数据库后端。

因为该函数的返回值被应用到一个已知的类型字典来检索数据库列名，所以该值必须是该字典中的一个有效条目。因此，这里列出了一组有限的可能返回值。

*   `AutoField`
*   `BigIntegerField`
*   `BooleanField`
*   `CharField`
*   `CommaSeparatedIntegerField`
*   `DateField`
*   `DateTimeField`
*   `DecimalField`
*   `FileField`
*   `FilePathField`
*   `FloatField`
*   `ImageField`
*   `IntegerField`
*   `IPAddressField`
*   `NullBooleanField`
*   `OneToOneField`
*   `PositiveIntegerField`
*   `PositiveSmallIntegerField`
*   `SlugField`
*   `SmallIntegerField`
*   `TextField`
*   `TimeField`

#### 验证(自身、值、实例)

当检查模型值的准确性时，此方法用于确定字段的内容是否正确。它接收的参数是字段本身的值，以及包含所有字段的模型。这使得它不仅可以验证字段本身的值，还可以验证它在更大模型的上下文中的意义。

为什么这在验证单个字段的值时有用应该是显而易见的，但是使用模型的其余值有什么价值就不太清楚了。毕竟，当编写一个字段时，通常无法知道它旁边还会使用哪些字段。

然而，有时一个字段可能是专门为一个特定的模型编写的，因此可以预先知道整个模型看起来是什么样子。例如，在这些情况下，该字段可以检查一个人拥有什么类型的帐户，因为该字段的最大值取决于其他字段。

#### to_python(自身，值)

字段的值可以用多种不同的方式存储，这取决于它的存储位置。在数据库中，它可以是几种基本类型中的一种，如字符串、整数和日期，而在序列化模型时，所有值都将被强制为字符串。这意味着，当实例化一个模型时，它的值通常必须被强制转换回正确的 Python 表示。这个行为是由`to_python()`方法处理的，尽管它并不像表面上看起来那么简单。

首先要考虑的是传递给`to_python()`的值可能是数据的多种表示形式之一。例如，它可以是从数据库适配器返回的任何格式，如字符串、整数或本机 Python 日期，但它也可以是从序列化程序检索的字符串，或者如果字段管理需要初始化的更复杂的自定义数据类型，则该值实际上可以是该类型的完全初始化的实例。

为了说明这一点，考虑一下`BooleanField`的情况。传递给它的值可能有多种形式，所以它的`to_python()`方法需要预料到这一点，并确保它总是返回一个布尔值或抛出一个异常，表明该值不适合该字段。

`def to_python(self, value):`

`if value in (True, False): return value`

`if value in ('t', 'True', '1'): return True`

`if value in ('f', 'False', '0'): return False`

`raise exceptions.ValidationError(_("This value must be either True or False."))`

如您所见，它必须检查几种不同类型的值，这些值都可以可靠地强制转换为布尔值。除了本机的`True`和`False`，它还检查相同的字符串表示，以及在各种情况下可能出现的两个单字符表示。如果找到了合适的值，它会简单地返回合适的本地布尔值，如果找不到合适的值，则会引发上一节中描述的`ValidationError`。

不幸的是，`to_python()`是一个额外的方法调用，并不总是必要的，所以它并不总是在看起来需要的时候被调用。特别是，它主要用于在提交到数据库之前验证数据，以及从序列化数据中检索内容，因此当从数据库中检索时，假设数据已经过验证，并且数据库后端通常足以返回正确的类型。

因此，Django 在从数据库中检索数据时不会调用`to_python()`。对于内置类型和许多潜在的附加字段，这已经足够了，但是对于其他数据类型或复杂对象，还需要做更多的工作来将数据库值转换为适合使用的值。为了支持这些类型的字段，Django 提供了一种特殊的方法来强制在填充字段值时调用`to_python()`。

#### 用子字段库支持复杂类型

有时数据库没有必要的数据类型来支持某些类型的应用程序。例如，大多数数据库无法存储时间长度，并将其作为`datetime.timedelta` [<sup>4</sup>](#Fn4) 对象呈现给 Python。为此，PostgreSQL 有一个名为`interval` [<sup>5</sup>](#Fn5) 的列类型，它确实应该直接映射到 Python `timedelta`中，但其他数据库没有，这使得它在可重用性方面不切实际。它适用于 PostgreSQL，但是为了使应用程序具有可移植性，它需要可用于多个数据库。

幸运的是，`timedelta`以天、秒和微秒来存储它的值，并且可以根据作为`float`传入的秒数来写入整个值。因此，一个新的`DurationField`可以使用一个`DecimalField`在数据库中存储一个值，在 Python 中转换成一个`float`，然后传递给`timedelta`在模型实例上使用。

`import datetime`

`import re`

`from django.core.exceptions import ValidationError`

`def to_python(value):`

`if isinstance(value, datetime.timedelta):`

`return value`

`match = re.match(r'(?:(\d+) days?, )?(\d+):(\d+):(\d+)(?:\.(\d+))?', str(value))`

`if match:`

`parts = match.groups()`

`# The parts in this list are as follows:`

`# [days, hours, minutes, seconds, microseconds]`

`# But microseconds need to be padded with zeros to work properly.`

`parts[4] = groups[4].ljust(6, '0')`

`# And they all need to be converted to integers, defaulting to 0`

`parts = [part and int(part) or 0 for part in groups]`

`return datetime.timedelta(parts[0], parts[3], parts[4]`，

`hours=parts[1], minutes=parts[2])`

`try:`

`return datetime.timedelta(seconds=float(value))`

`except (TypeError, ValueError):`

`raise ValidationError('This value must be a real number.')`

`except OverflowError:`

`raise ValidationError('The maximum allowed value is %s' % \`

`datetime.timedelta.max)`

这是一种不使用`to_python()`就无法处理的过程，并且它必须在每次模型被实例化时发生，即使是来自数据库。然而，在每次访问数据库时调用额外的方法调用会变得非常昂贵，所以能够在不影响那些不使用它的字段的情况下处理这个问题是非常重要的。

正如在本章末尾将要展示的，描述符可以用来定制当一个字段的值被访问时会发生什么，这是控制这类行为的一个很好的方法。当然，如果描述符只是达到目的的一种手段，那么描述符可能会很棘手，这里描述的`to_python()`行为是这些复杂数据类型相当常见的需求，所以 Django 提供了一种简化描述符创建的捷径。

位于`django.db.models.fields.subclassing`，`SubfieldBase`元类是 Django 简化模型字段创建的方法，其`to_python()`方法将被调用。通过简单地将它应用到一个模型类，它会处理剩下的事情，建立一个描述符，在第一次加载字段时调用`to_python()`。因此，`DurationField`示例将在字段定义中使用它，如下所示:

`from django.db import models`

`from django.db.models.fields.subclassing import SubfieldBase`

`class DurationField(models.DecimalField, metaclass=SubfieldBase):`

`pass`

`# Field logic then continues here`

### 控制数据库行为

字段的另一个重要方面是它们如何与数据库交互。这可能包括数据本身如何存储，在发送到数据库之前如何准备，以及如何准备与数据库中已有的值进行比较。Django 自己已经完成了这个过程，每个现有的字段类型都提供了一些方法来定义这个行为。

对于定制字段，通常需要覆盖这种行为，以不同于 Django 本身期望的方式与数据库交互。以下方法定义了字段如何与数据库一起工作的几乎每个方面，因此字段对如何处理数据库交互有很大的控制权。

#### db_type(自身，连接)

很少被单个字段覆盖，该方法返回特定于数据库的字符串，该字符串控制如何创建用于给定字段的列。Django 在内部使用`get_internal_type()`方法的结果和每个后端提供的映射来提供这个方法的返回值。这一功能足以满足绝大多数现场应用。

在考虑使用这个方法时，要记住的最重要的事情是，它的返回值特定于特定的数据库后端。为了在具有不同后端的项目中使用这个字段，提供了`connection`参数来帮助您决定使用什么。在一个简单的例子中，您可以使用`connection.settings_dict['ENGINE']`来确定该字段在什么类型的数据库上使用，并相应地采取行动。例如，如果`DurationField`实际上可以在 PostgreSQL 中使用`interval`，同时仍然支持其他数据库:

`class DurationField(models.Field):`

`def db_type(self, connection):`

`engine = connection.settings_dict['ENGINE']`

`if engine == 'django.db.backends.postgresql_psycopg2':`

`return 'interval'`

`else:`

`return connection.creation.data_types['DecimalField']`

这个方法的另一个特性是，如果你返回的是`None`而不是一个字符串，Django 将跳过这个特定字段的创建。如果必须以比单个字符串所能表示的更复杂的方式创建字段，这可能是必要的。但是，Django 在执行查询时仍然会尝试引用该列，所以在尝试使用该字段之前，您需要确保确实创建了该列。

大多数时候，您会希望将这个方法留给 Django，但是它确实提供了一种方法，可以在您真正需要的时候覆盖默认行为。在分布式应用程序中这样做时要小心，因为您最终将不得不支持多种类型的数据库，而不仅仅是您最熟悉的一种。

#### get_prep_value(自身，值)

有一些方法处理为数据库中不同的用户准备值，但是它们通常共享相同的代码来准备在数据库中使用的值。以下两种方法都使用`get_prep_value()`方法来执行这个基本转换。

在大多数情况下，将 Python 对象转换为某种更基本的类型就足以允许自定义字段将值传递给数据库。通过覆盖`get_prep_value()`，其他数据库准备方法通常可以毫无问题地使用它们的默认实现。例如，`DurationField`需要这种类型的转换，因为`timedelta`对象不能直接传递给大多数数据库，这导致使用`DecimalField`来控制列的行为。一个定制的`get_prep_value()`方法可以将`timedelta`对象转换成`Decimal`值，然后这些值可以正常地传递给数据库。

`from django.db import models`

`from django.db.models.fields.subclassing import SubfieldBase`

`from django.utils import _decima` `l`

`class DurationField(models.DecimalField, metaclass=SubfieldBase):`

`def get_prep_value(self, value):`

`return _decimal.Decimal('%s.%s' % (value.days * 86400 + value.seconds`，

`value.microseconds))`

`# Field logic then continues here`

#### get_db_prep_value(self，value，connection，prepared=False)

如果您需要为不同的数据库连接准备不同的值，这种方法将允许您灵活地这样做。`connection`参数再次表示正在使用的数据库连接，并可用于对如何继续进行做出必要的决定。准备好的参数表明该值是否已经通过`get_prep_value()`传递。如果是`False`，您应该在继续下一步之前调用该方法。如果继续在 PostgreSQL 和其他数据库之间分离其行为，下面是`DurationField`可能的样子:

`from django.db import models`

`from django.db.models.fields.subclassing import SubfieldBase`

`from django.utils import _decimal`

`class DurationField(models.DecimalField, metaclass=SubfieldBase):`

`def get_prep_value(self, value):`

`# Nothing to do here, because get_db_prep_value() will do the dirty work`

`return value`

`def get_db_prep_value(self, value, connection, prepared=False):`

`if not prepared:`

`value = self.get_prep_value(value)`

`engine = connection.settings_dict['ENGINE']`

`if engine == 'django.db.backends.postgresql_psycopg2':`

`# PostgreSQL can handle timedeltas directly`

`return value`

`else:`

`return _decimal.Decimal('%s.%s' % (value.days * 86400 + value.seconds`，

`value.microseconds))`

`# Field logic then continues here`

#### get_db_prep_save(自身，值，连接)

这与`get_db_prep_value()`的工作方式非常相似，但是提供了一种方式，在实际将值保存到数据库中时提供单独的行为，而不是其他操作。事实上，如果您没有为此方法提供实现，默认行为将简单地遵从`get_db_prep_value()`，这通常就足够了。

#### get_prep_lookup(自身，查找类型，值)

字段必须与数据库交互的另一个领域是在 Python 对象和已经存储在数据库中的值之间进行比较时。例如，每次使用 QuerySet 的`filter()`方法时都会发生这种情况，以便生成必要的数据库查询。由于比较可能需要与保存不同的处理，Django 使用`get_prep_lookup()`方法来管理这项任务。

调用时，此方法接收两个显式参数，详细说明预期如何进行查找。第一个是`lookup_type`，是在`filter()`方法中请求的比较类型。第二个是`value`，是用于与数据库值进行比较的 Python 对象。

虽然`value`相当简单，但是`lookup_type`有点不同，因为它是一个包含所请求的比较类型的字符串。Django 的数据库 API 中有几个这样的 API， [<sup>6</sup>](#Fn6) 每个都有自己的期望。这是完整的列表，包括每个列表的用途:

*   `exact`和`iexact`—提供的值必须与数据库中的值完全匹配，`iexact`不区分大小写。Django 假设一个没有查找类型的过滤器表示`exact`，它将被传递给`get_prep_lookup()`。
*   `contains`和`icontains`—提供的值必须至少存在于数据库中的部分值中，`icontains`不区分大小写。
*   `gt`和`gte`—数据库值必须大于提供给查找的值，而`gte`也允许值相等。
*   `lt`和`lte`—数据库值必须比提供给查找的值小，而`lte`也允许值相等。
*   `in`—数据库值必须至少与作为查找值提供的列表中的一个值完全匹配。
*   `startswith`和`istartswith`—数据库值必须以作为查找值提供的字符串开头，`istartswith`不区分大小写。
*   `endswith`和`iendswith`—数据库值必须以作为查找值提供的字符串结尾，`iendswith`不区分大小写。
*   `range`—数据库值必须具有由作为查找值提供的开始和结束限制的二元组指定的范围。
*   `year`、`month`和`day`—数据库值必须包含指定的查找值作为其年、月或日部分，具体取决于所使用的查找类型。这仅对日期有效。
*   `isnull`—数据库值必须等于`NULL`才能匹配。
*   `search`—数据库值必须通过全文索引搜索。这只对 MySQL 有效，并且只在数据库被修改为启用必要的索引时有效。
*   `regex`和`iregex`—数据库值必须与作为查找值提供的正则表达式指定的格式匹配，`iregex`不区分大小写。

从某些现有字段继承的字段通常可以避免重写此方法，因为父类通常会做正确的事情。不幸的是，在其他时候，子类需要对某些查找类型进行特殊处理，这非常有用。还有一些时候，有必要完全限制某些类型的查找。

将 Python 代码作为查找过程的一部分来执行的一个有用的副作用是，它允许对该字段无效的查找抛出异常。这就像在其他地方一样，如果您引发了一个异常，它会提前退出查询，显示一条消息指出发生了什么。

WHERE’D MY ERROR GO?

不幸的是，尽管在`get_prep_lookup()`中引发异常是可能的——而且通常非常有用——但有时您会发现它们被抑制了。如果发生这种情况，查询似乎会执行，但是您可能会收到一个空的结果列表，而不是看到您的错误。

由于一些查询集必须在内部跳转，某些类型的错误——包括似乎是显而易见的选择使用的`TypeError`——被捕获和抑制，导致 Django 继续处理，尽管没有获得该字段的有效值。

为了确保错误得到最大化并按预期工作，一定要使用`ValueError`而不是`TypeError`，因为它不会陷入相同的陷阱。

#### get_db_prep_lookup(self，lookup_type，value，connection，prepared=False)

这与`get_prep_lookup()`执行基本相同的任务，除了它的输出将被直接输入数据库查询。它接收相同的参数，但添加了`connection`和`prepared`，其工作方式与传递给`get_db_prep_value()`的参数类似。默认实现遵从`get_prep_lookup()`，这对于大多数需求来说已经足够了。

## 处理文件

许多应用程序需要管理超出传统数据库存储范围的内容。除了常见的数字和字符串，还有大量其他数据格式，从音频和视频到可打印的便携文档格式(PDF)文件等等。像这样的内容不太适合直接存储在数据库中——尽管在某些情况下至少是可能的——但是将它与数据库中的其他内容联系起来仍然是有用的。

为了处理这一点，Django 提供了一个特殊的`FileField`，它有一些额外的方法来方便对文件的访问。它还使用本章中描述的许多钩子来存储对数据库中文件的引用，以及提供一个可以以可移植方式访问文件的特殊对象。Django 还提供了一个`ImageField`，它继承了`FileField`的大部分功能，同时添加了一些自己的功能，专门用于处理图像的特殊需求。

`FileField`的子类通常不需要覆盖它的许多方法，因为它们主要与所有文件类型共有的文件特性相关。这包括诸如文件名和相对路径之类的东西，它们与特定类型文件的细节没有任何关系。然而，有些，比如`save_file()`，可以被覆盖，以提供与特定类型文件相关的属性的特殊处理。

### 获取 _ 目录 _ 名称(自身)

这个方法只是返回一个相对路径，它将与文件名一起存储在数据库中。默认情况下，它会查看字段的`upload_to`属性来确定目录应该是什么，甚至子类也应该尊重这种行为。然而，正是如何使用该属性，子类可以定制该方法以获得更好的效果。

通常，Django 使用两条信息创建目录名:`upload_to`字符串本身和当前日期。文件上传的日期应用于目录名，用部分日期替换某些字符。这允许单个字段更精确地控制它们的文件存储在哪里，这有助于保持目录更小，甚至可能更好地利用磁盘容量。

然而，在子类中，基于一些其他类型的信息生成目录名可能更有用，例如多站点设置中的当前站点的域名，或者在有多个 Web 服务器共享公共存储的较大生产环境中接收上传的机器的互联网协议(IP)地址。

本质上，在这里任何事情都是公平的，只要它只需要通过访问`FileField`实例就可以确定的信息。可以获得当前站点或 IP 地址，而完全不考虑当前模型，当前时间也是如此。但是，其他信息，如提交文件的用户、他或她的远程计算机的 IP 地址或文件将附加到的对象，都不能通过此功能访问，因此不能使用。

当然，还有另一个选项来指定这些附加信息，但是这样做完全绕过了这个方法。通过为`upload_to`指定一个 callable，如 Django 的文件文档中所述， [<sup>7</sup>](#Fn7) 目录可以根据它将附加到的对象生成，这可能包括拥有该对象的`User`。

注意，当使用一个可调用对象作为`upload_to`时，该可调用对象应该返回完整的路径，包括目录和文件名，所以在这种情况下根本不会调用`get_directory_name()`，除非该可调用对象显式地调用它。此外，传入的请求仍然不可用，甚至对那个可调用的请求也不可用，因此基于该信息做出目录命名决策将需要一个自定义视图。

### get_filename(自己，文件名)

这与`get_directory_name()`的工作方式非常相似，除了它负责指定路径的文件名部分而不是目录。它接收传入文件指定的原始文件名，并返回将在数据库和底层存储系统中使用的新文件名。

如果一个`FileField`子类需要定制一个特定文件的文件名，比如去掉某些字符或者改变文件的扩展名，那么这里就是合适的地方。这也是它接收原始文件名的原因，这样它就有办法创建一个与用户提供的文件名至少部分相关的文件名。

默认情况下，它的输出与`get_directory_name()`的输出相结合，形成要存储在数据库中并传递给存储系统的完整路径。然而，和它的对应物一样，只有当字段的`upload_to`参数不可调用时，这种情况才成立。如果指定了 callable，它负责指定整个路径，包括文件名。因此，在这种情况下，只有当`upload_to` callable 明确请求时，这个方法才会被调用。

### 生成文件名(自身，实例，文件名)

这是用于生成完整路径的默认方法。它使用相同的函数签名作为可调用的`upload_to`参数，因为它扮演完全相同的角色。事实上，在`FileField`内部，所有用于生成文件文件名的引用都会引用这个方法；如果一个可调用函数被提供给了`upload_to`，它只是被赋予了相同的名字，取代了默认的行为。

默认行为是使用`os.path.join()`来组合`get_directory_name()`和`get_filename()`方法的输出，忽略作为参数提供的模型实例。如果一个`FileField`子类需要一次指定文件的完整路径的能力，那么这个方法就是合适的地方。

当然，请记住，如果 callable 作为`upload_to`参数提供，这个方法将被替换。不管`FileField`子类提供什么行为，这都是正确的；特定实例的需求总是胜过其类的行为。因此，尽管覆盖这种行为可以提供一个更有用的缺省值，但这并不能完全消除单个开发人员替换它的能力。

### save_form_data(自身，实例，数据)

这是表单的一种实用方法，用作保存与模型实例关联的文件的快捷方式。它接受该字段附加到的模型实例，以及由表单提供的上传文件数据。默认情况下，它只是从上传的文件对象中提取必要的信息，并将其传递给标准的文件保存方法。

`instance`参数是定义了`FileField`的模型的一个实例，而`data`参数是一个`UploadedFile`对象，如[第 8 章](08.html)所述。上传的文件包含一个`name`属性，该属性包含文件名和一个`read()`方法，该方法用于访问文件的内容，以便可以正确保存。

因为这是 Django 本身的大多数领域处理文件的主要方式，所以覆盖这个字段提供了一个极好的机会来绑定基于特定字段类型的扩展功能。比如 Django 自己的`ImageField`就以此为契机，将一张图片的宽度和高度存储在单独的字段中，这样就可以直接在数据库中对它们进行索引和搜索。其他文件类型可以采用相同的方法，将文件的某些属性存储在其他字段中，以便于以后访问。

因为这个方法可以访问整个文件的内容，所以可以将这些内容传递给大多数处理文件的库。任何可以读取打开的文件对象的东西都可以处理上传的内容，只需将它包装在一个`StringIO` [<sup>8</sup>](#Fn8) 对象中。这样，就可以访问这些内容，而不必先将它们写入存储系统，然后再将它们读回来。

### 删除文件(自己、实例、发件人)

虽然这可能看起来只是删除文件的一种方式，但它实际上有一个非常特殊的目的，这通过出现一个`sender`参数来暗示。`FileField`的`contribute_to_class()`方法将该方法设置为`post_delete`信号的监听器。它并不打算被单独调用，而是在每次删除带有`FileField`的模型实例时被调用。正如对`post_delete`的描述，`instance`参数是刚刚被删除的对象，`sender`参数是该实例的模型类。

触发时，它会检查指定实例上该字段引用的文件是否应被删除。毕竟，如果没有其他实例引用同一个文件，并且它不是新实例的默认值，那么很可能没有对该文件的引用。在这些情况下，文件将从存储系统中永久删除。

覆盖它的用途很清楚，因为何时删除文件的逻辑直接包含在这个方法中。如果一个`FileField`子类需要有不同的规则，简单地覆盖这个方法就足够了。

一个明显的例子是，由于历史原因，文件是否应该总是保留，即使在与它们相关联的模型实例被删除之后。提供该行为很简单，只需定义该方法的一个空实现。

`from django.db import models`

`class PermanentFileField(models.FileField):`

`def delete_file(self, instance, sender, **kwargs):`

`pass`

当然，这也有其他可能的用例，但是这些用例的细节将在很大程度上取决于单个应用程序的需求。

### 属性 _ 类别

作为一个简单的属性，而不是一个方法，`attr_class`可能看起来不会提供太多的功能或灵活性。令人欣慰的是，外表往往具有欺骗性，因为它实际上是一些非常有用的功能的门户。`attr_class`属性被设置为一个类，当在 Python 中被引用时，该类将用于表示字段的值。这意味着这个简单属性的值实际上是指定输入特定`FileField`实例的数据在公共 API 上可用的特性的主要方式。

下一节描述默认情况下为此属性指定的类的行为，以及如何重写其方法以提供附加功能。

### 自定义文件类

当一个模型定义了一个`FileField`时，在实际模型实例上作为属性可用的值是一个专门为管理文件而设计的特殊对象。位于`django.db.models.fields.files`的`File`类提供了许多独立于平台和存储的方法，用于访问文件的内容和内容的属性，以及保存新文件和删除现有文件。

因为它是用于访问文件的面向公众的 API，所以为需要经常引用的具有共同特性的文件类型提供附加功能通常非常有用。这提供了一种很好的、干净的、面向对象的方法来将公共代码封装在一个地方，而不是要求应用程序的其余部分一遍又一遍地编写它。

例如，Django 自己的`ImageField`提供了自己的子类`ImageFile`，它包含了访问图像宽度和高度的额外方法，以及缓存图像以加快后续访问的速度。这是一个很好的例子，说明提供这种额外的功能是多么容易。

但是，除了提供新的方法之外，还有许多现有的方法可以从被重写中受益。这些不太可能直接使用，但是正如`ImageFile`所示，它们可以用于执行一些重要的任务，比如更新缓存值或者使缓存值失效。

在很大程度上，接下来描述的方法直接映射到第 8 章中描述的文件存储方法。主要区别在于，它们特定于特定的文件类型，并且可以针对该文件类型特有的方面进行定制，而存储系统只是设计用于处理文件，而不考虑要处理什么类型的内容。

#### 路径(自身)

如果文件存储在本地文件系统上，这将返回文件的路径。对于存储在其他后端的文件，不能用 Python 内置的`open()`函数访问，这将引发一个`AttributeError`，因为相应的方法在相关的存储系统对象上不可用。

对于那些在引入这个新的文件处理系统之前编写的项目，这主要是作为与旧版本 Django 的兼容层提供的。在现实世界中，为较新版本的 Django 编写的项目应该避免使用这种方法，而是使用本节中列出的`open()`方法以更可移植的方式访问文件。覆盖它也没什么用，所以这里列出它是为了和 API 的其他部分一起完整。

#### 网址（自我）

此方法返回可以在 Web 上检索文件的 URL。它可能由 Django 项目本身提供，一个由网站所有者运营的媒体服务器，或者甚至是由第三方运营的存储服务。这个 URL 来自哪里的确切细节是由存储系统指定的，所以这个方法是访问文件的 URL 的一种可移植的方式。

在大多数情况下，忽略这一点没有什么好处，但是根据具体情况，有几个理由这样做。一个例子可能是管理具有特定结构的 HTML 文件的`FileField`子类，因此 URL 可能包含一个名称引用，以将浏览器指向文件中的特定点。

#### 尺寸(自身)

这将检索底层文件的大小，并将其缓存以供将来参考。虽然这是一个非常有用的特性，但是在子类中覆盖它没有什么价值。文件大小的本质是它不会随文件类型而变化，并且实际上无法定制如何获得大小，所以这里只是为了完整起见才包括它。

#### 打开(self，mode='rb ')

这将检索文件的内容并返回一个打开的文件或类似文件的对象，从而允许访问该文件。这是以可移植方式访问文件内容的首选方法，因为文件的大部分功能都是通过存储系统实现的。

`mode`属性采用与 Python 自带的`open()`函数、 [<sup>9</sup>](#Fn9) 相同的选项，可以用来打开文件进行读或写访问。重写此方法的一个用途是更改默认的访问模式，但仅用于更改默认情况下是否应以二进制模式打开它。默认情况下，至少应该打开文件进行读取，而不是写入。

子类化它的另一个潜在原因是为返回的类似文件的对象提供自定义行为。默认情况下，该方法将返回存储系统返回的任何对象，但是特定的文件类型可能会用于定制该对象上的方法，例如使用`write()`或`close()`来改变文件写入的方式和时间。因为这个方法负责返回一个打开的类似文件的对象，所以它可以将真正的类似文件的对象包装在另一个对象中，在完成任何需要做的额外工作后传递给真正的对象。

#### 保存(自己，姓名，内容，保存=真)

顾名思义，这将一个新文件保存到存储系统，替换模型实例上当前的文件。参数应该是不言自明的，其中`name`是新文件应该保存的名称，`content`是使用该名称写入的文件的实际内容。

*   当然，文件名中的无效字符或同名的现有文件可能会导致文件名被存储系统更改。这种变化将反映在存储在模型实例上的文件名中。
*   然而,`save`的论点值得进一步解释。因为这保存了一个与模型实例相关的文件，所以新的文件名将存储在该实例上，以供将来参考。然而，立即将更改提交给数据库并不总是有益的。
*   默认情况下，它会立即保存实例，但是如果将`save`设置为`False`，则会绕过它，允许在提交到数据库之前进行其他更改。但是，在执行此操作时要小心。该文件已经提交到存储系统，因此如果最终未能使用新文件名保存实例，将导致文件中没有对它的引用。
*   覆盖它可以提供一种方法来定制或记录将要使用的文件名，更改默认的数据库提交行为，或者最常见的是，检索有关文件内容的信息并相应地更新任何缓存的信息。默认的`File`对象为文件大小做这件事，并且`ImageFile`也更新它的维度缓存。

#### 删除(self，save=True)

同样不言自明的是，这将直接从存储系统中删除文件，而不管使用的是哪个存储系统。它还从模型实例中删除文件名，这样它就不再引用该文件。

`save`参数的工作方式就像来自`save()`方法的参数一样，决定模型实例是否被保存。同样像`save()`，如果提供了`False`，确保实例最终被保存是很重要的。否则，它将包含对已被删除的文件的引用。更糟糕的是，如果另一个实例保存了一个同名的文件，那么来自第一个实例的引用将不再是孤立的，而是实际上完全指向错误的文件。

覆盖它提供了与覆盖`save()`相同的大部分好处，因为它能够删除任何缓存的信息，这样如果以后访问它就不会引起混乱。

## 信号

第 2 章描述了与 Django 捆绑在一起的信号调度系统，以及信号一般是如何工作的。如前所述，信号可以在任何 Python 模块中创建和使用，并且可以用于任何目的。对于处理模型，提供了开箱即用的几种信号，可以在许多情况下使用。

下面的信号在`django.db.models.signals`都是可用的，每个都将模型类作为标准的`sender`参数发送给监听器。此外，许多信号包含一个模型实例作为附加参数。这些和其他附加参数在这里列出的每个信号的描述中有详细说明。

### 班级 _ 已准备

当 Django 的`ModelBase`元类处理完一个模型类时，这个信号被触发，表明这个类已经完全配置好，可以使用了。因为 Python 一遇到类声明，元类就开始运行，所以在 Python 继续处理包含该声明的模块之前，`class_prepared`就会被触发。

然而，需要考虑的一个重要注意事项是，这个事件正好发生在模型注册到`AppCache`之前。因此，如果一个`class_prepared`的监听器通过`AppCache`检查到目前为止已经被处理的模型，发出信号的模型将不会出现。在流程的这一点上，检查应用程序缓存可能有一些用途，但是如果没有完整的应用程序缓存，它的价值就非常有限。

与本节中列出的大多数其他信号不同，`class_prepared`只发送标准的`sender`参数。由于在触发信号的时间点上没有任何可用的实例，并且新模型类上的`_meta`属性包含了关于它是如何被声明的所有信息，所以模型本身就足以获得在那个时间点上可用的所有信息。

`>>> from django.db import models`

`>>> def listener(sender, **kwargs):`

`...     print('%s.%s' % (sender._meta.app_label, sender._meta.object_name))`

`...`

`>>> models.signals.class_prepared.connect(listener)`

`>>> class Article(models.Model):`

`...     title = models.CharField(max_length=255)`

`...     class Meta:`

`...         app_label = 'news'`

`...`

`news.Article`

像所有的信号一样，`class_prepared`的监听器可以注册一个特定的监听模型，也可以不注册，尽管这似乎是不可能的。毕竟，如果侦听器必须在发出信号之前注册，而信号是在 Python 甚至继续模块的其余部分之前发出的，那么它怎么可能注册到要侦听的类呢？即使可以，它又能达到什么目的呢？

这两个问题的答案都是`contribute_to_class()`。记住，模型上的属性有机会定制它们如何应用于模型。当遇到一个具有`contribute_to_class()`方法的对象时，它被调用，而不是通常的`setattr()`，在那里它被传递模型类和属性名，允许对象执行它想要的任何功能。

这里的关键是`contribute_to_class()`接收模型类作为参数。这是为正在处理的类注册一个`class_prepared`监听器的绝佳机会。事实上，根据手头的需要，这不仅是可能的，而且可能是绝对必要的。

考虑这样一种情况，一个类似字段的对象需要知道它所连接的模型的所有信息，以便正确地配置自己。由于不能保证在对相关对象调用`contribute_to_class()`时所有其他字段都已处理完毕，因此有必要推迟配置的剩余部分，直到该类完成处理。

### 前初始化和后初始化

当一个模型被实例化时，`pre_init`在任何其他工作被执行之前触发。它甚至在传递到模型中的任何参数被分配给适当的属性之前就被调度。这是一个在实际发生之前检查将分配给实例的参数的好机会，特别是因为这允许侦听器在遇到可能由指定的参数导致的任何错误之前触发。

因为这发生在任何字段值被填充到对象本身之前，所以当触发信号时，它不会发送新的对象。相反，除了`sender`之外，它还传递另外两个参数，这两个参数对应于传递给模型的位置和关键字参数。

*   `args`—包含传递给模型构造函数的位置参数的元组
*   `kwargs`—包含传递给模型构造器的关键字参数的字典

请注意，尽管这些名称与《T2》第 2 章中描述的多余参数技术的名称相同，但它们是作为显式关键字参数传递给听者的，而不是使用`*`和`**`。侦听器必须显式定义这些参数，以便它们能够正常工作。

`>>> from django.db.models.signals import pre_init`

`>>> from news.models import Article`

`>>> def print_args(sender, args, kwargs, **signal_kwargs):`

`...     print('%s(*%s, **%s)' % (sender._meta.object_name, args, kwargs))`

`...`

`>>> pre_init.connect(print_args, sender=Article)`

`>>> article = Article(title=u'Testing')`

`Article(*(), **{'title': u'Testing'})`

类似地，`post_init`作为模型实例化过程的一部分被触发，但是在结束时而不是开始时，一旦所有的参数都被映射到基于模型上定义的字段的适当属性。因此，顾名思义，对象在这一点上是完全初始化的。

因此，当`post_init`触发时，它会被传递给完全配置的模型实例以及标准的`sender`，后者是模型类。新对象作为`instance`参数传递给监听器，监听器可以根据应用程序对其进行任何必要的处理。

`>>> from django.db.models.signals import post_init`

`>>> from news.models import Article`

`>>> def print_args(sender, args, kwargs, **signal_kwargs):`

`...     print('Instantiated %r' % instance)`

`...`

`>>> post_init.connect(sender=Article)`

`>>> article = Article(title=u'Testing')`

`Instantiated <Article: Testing>`

### 预保存和后保存

当一个模型实例被提交到数据库时，Django 提供了两种方法来连接到这个过程，在开始和结束的时候。因此，两者之间的主要区别是在对象提交到数据库之前调用了`pre_save`,而在之后调用了`post_save`。根据应用程序的需要，这种简单的区别可能非常重要。

当被`pre_save`触发时，监听器接收模型类作为`sender`，以及模型实例作为`instance`。这允许监听器在实例到达数据库之前访问甚至修改将要保存的实例。这是一种为第三方应用程序提供的模型提供或覆盖默认参数的有用方法。

另一方面，`post_save`是在执行保存之后调用的，并且实例已经提交到数据库。这在两个方面都是有用的一步，因为它不仅确保了数据确实存在于数据库中，这在处理相关模型时是必要的，而且它还发生在 Django 决定是向数据库中插入新记录还是更新现有记录之后。

除了 sender 和 instance 参数的工作方式与在`pre_save`中相同之外，`post_save`的监听器可以接收另一个参数。`created`参数是一个布尔值，表示是否必须从头开始创建实例。值`True`意味着它是新插入到数据库中的，而`False`意味着已有记录被更新。当使用`post_save`信号跟踪数据库变化时，这是一个重要的区别，可以用来确定其他应用程序的行为。要了解这一点，请参阅本书第 11 章中的历史示例。

因为模型管理器的`create()`方法实际上确实向数据库提交了一个新实例，所以它触发了这两个信号。也可以假设任何时候使用`create()`时，`created`参数都将是`True`，但是请记住，很可能还有其他时候该参数也是`True`。

`>>> from django.db.models import signals`

`>>> from news.models import Article`

`>>> def before(instance, **kwargs):`

`...     print('About to save %s' % instance)`

`...`

`>>> signals.pre_save.connect(before, sender=Article)`

`>>> def after(instance, created, **kwargs):`

`...     print('%s was just %s' % (instance, created and 'created' or 'updated'))`

`...`

`>>> signals.post_save.connect(after, sender=Article)`

`>>> Article.objects.create(title='New article!')`

`About to save New article!`

`New Article! was just created<Article: New article!>`

A NOTE ABOUT COMBINING PRE_SAVE() AND POST_SAVE()

`pre_save`和`post_save`还有一个非常重要的区别，因为它们并不总是被称为一对。因为`pre_save`是在流程开始时触发的，所以您可以可靠地假设每次启动`save()`时都会调用它。但是，`post_save`只在最后发生，所以如果保存过程中出现任何问题，`post_save`不会被触发。

这是一个重要的区别，因为为模型保存信号注册一对侦听器似乎很方便，期望每次都调用这两个侦听器。虽然对于大多数情况来说这可能是真的，当然当没有出错时，有时事情确实会出错。示例包括具有重复主键或其他唯一列的条目、数据类型错误或数据库连接超时。

在需要这种类型行为的情况下，唯一合理合理的方法是覆盖模型上的`save()`方法。这允许在实际的数据库交互之前和之后运行定制代码，但是它也提供了一种方法来识别在这个过程中发生的问题。此外，它允许代码有更好的机会更充分地将两部分功能配对，因为如果确实出错了，就更容易识别，因此任何未完成的操作都可以被取消。

### 删除前和删除后

类似于上一节的精神，`pre_delete`和`post_delete`是与模型实例的删除相关的一对信号。除了都只提供了`sender`和`instance`参数之外，它们的功能与储蓄功能几乎相同。

使用`post_delete`时，请记住传递给监听器的实例已经从数据库中删除了，因此它的许多方法在使用时都会引发异常。如果它以前与其他模型的实例相关，则尤其如此。当`post_delete`被触发时，这些关系将会丢失，所以对这些情况的任何处理都应该在`pre_delete`中完成，或者通过覆盖模型上的`delete()`方法来完成。如果你覆盖了模型的`delete()`方法，你需要确保在调用父类的`delete()`方法之前访问模型及其关系。一旦你通过父类删除它，你将处于与使用`post_delete`信号时相同的情况。

此外，因为实例将被删除，所以它的主键值将不再与数据库中的任何内容匹配。然而，为了更准确地跟踪哪个对象被删除，主键值在实例上保持不变，并且可以使用本章前面描述的`pk`快捷方式读取。

### post_syncdb

与特定模型无关，`post_syncdb`作为`syncdb`管理命令的正常流程的一部分被触发。它为应用程序提供了一种方法来识别应用程序的模型何时被安装到数据库中，以便根据它们的定义执行其他任务。

虽然可能还有其他用途，但是`post_syncdb`的主要用途是在应用程序的模型第一次安装到数据库中时配置应用程序本身，或者识别正在安装的其他应用程序，并采取适当的措施。在 Django 内部，这两种类型的功能都有例子。

*   一旦模型安装完毕，`django.contrib.auth`应用程序就使用它将新模型的权限安装到数据库中，如果`auth`应用程序本身刚刚安装完毕，它还会创建一个新的超级用户。
*   `django.contrib.contenttypes`应用程序使用它来维护它自己的正在使用的模型的记录，因此它可以提供与任何已安装模型的关系。
*   `django.contrib.sites`应用程序使用它为所有使用该应用程序的新项目安装一个默认站点。

使`post_syncdb`相当有效的关键是它为伴随所有信号的`sender`参数使用不同类型的值。这个信号不是使用特定的模型，而是发送应用程序的`models`模块，这是 Django 用来标识应用程序的对象。这允许为所有应用程序配置侦听器，或者只为注册它的应用程序配置侦听器。

每次执行命令时，`INSTALLED_APPS`设置中列出的所有应用程序都会发出一个`post_syncdb`信号，即使没有任何变化。因此，除了`sender`，`post_syncdb`的听众还会收到三个额外的参数来更详细地指出`syncdb`被调用的情况，并帮助控制他们的响应行为。

*   `app`—应用程序对象(其`models`模块)代表刚刚与数据库同步的应用程序。这与`sender`参数完全相同，但是在这里命名为`app`是为了让监听器函数更具可读性。
*   `created_models`—Python`set`，包含在`syncdb`执行期间实际安装到数据库中的应用程序的所有模型。这就是监听器如何识别那些新模型的方法，这通常是`post_syncdb`处理者需要知道的最重要的事情。这将一直被提供，但是在没有新东西的应用程序中，它将只是一个空的`set`。
*   `verbosity`—一个整数，标识执行`syncdb`的用户所请求的详细级别。有效值为`0`、`1`和`2`，其中`0`为最小输出(大多数情况下没有输出)，`1`为正常输出，`2`为全部输出(包括指示正在执行的操作的消息，即使它们不需要用户输入)。`post_syncdb`的监听器应该总是准备好输出它们正在执行的活动，并且应该使用这个参数来确定何时应该显示不同的消息。

`from django.db.models import signals`

`def app_report(app, created_models, verbosity, **kwargs):`

`app_label = app.__name__.split('.')[-2]`

`if verbosity == 0:`

`# Don't do anything, because the`

`# user doesn't want to see this.`

`return`

`# Get a list of models created for just the current application`

`app_models = [m for m in created_models if m._meta.app_label == app_label]`

`if app_models:`

`# Print a simple status message`

`print('Created %s model%s for %s.' % (len(app_models)`，

`len(app_models) > 1 and 's' or ''`，

`app_label))`

`if verbosity == 2:`

`# Print more detail about the`

`# models that were installed`

`for model in app_models:`

`print('  %s.%s -> %s' % (app_label`，

`model._meta.object_name`，

`model._meta.db_table))`

`elif verbosity == 2:`

`print('%s had no models created.' % app_label)`

`signals.post_syncdb.connect(app_report)`

用于`post_syncdb`监听器的代码通常放在应用程序的`management`包中，每当`manage.py`用于包含该应用程序的项目时，该包就会自动加载。这确保了它不会在不需要的情况下被不必要的加载，同时也确保了它在必要的时候被加载。此外，因为是 Python，所以您的`management`包中的代码也可以做其他事情，比如检查`INSTALLED_APPS`设置并决定是否应该注册监听器。

## 应用技术

考虑到单个模型可以使用大量工具来定制它们的行为、它们与数据库的交互以及与数据库相关联的字段，选项几乎是无限的。接下来的技术仅仅代表了可能性的一小部分。

### 按需加载属性

当处理特定类型的数据时，构建一个复杂的 Python 对象来表示给定值有时会非常昂贵。更糟糕的是，应用程序的某些部分甚至可能不使用该对象，尽管模型的其余部分可能是必需的。现实世界中的一些例子是复杂的地理表示或嵌套对象的大树。

在这些情况下，我们必须能够在必要时访问完整的对象，但是如果不使用该对象，那么不构造它对性能非常重要。理想情况下，当模型被实例化时，数据将从数据库中加载，但是原始值将位于实例中，而不会被加载到整个对象中。当属性被访问时，它将在该点被构造，然后被缓存，这样以后的访问就不必不断地重新构造对象。

再次回顾《T2》第二章，描述符是完成这项任务的完美工具，因为它们允许代码在访问属性的准确时刻运行。必须注意确保完整构造的对象被正确缓存以备将来使用，但是通过使用单独的`name`和`attname`，这也相当简单。

为了说明这在实践中是如何工作的，考虑一个用于存储和检索任意 Python 对象的 pickled 副本的字段。没有办法预先知道 Python 表示会有多复杂，所以在这种情况下，理想的做法是推迟对象的构造，直到真正需要的时候。

#### 存储原始数据

第一步是告诉 Django 如何使用标准字段管理数据库中的原始数据。由于腌制对象只是字符串，某种形式的文本字段显然是谨慎的，而且由于没有办法预先知道腌制表示将有多大，几乎无限的`TextField`似乎是一个显而易见的选择。

当然，考虑到这个新领域还会有一些额外的工作要做，单靠`TextField`是不够的。相反，我们将创建一个继承数据库功能`TextField`的子类，同时允许在必要的地方进行额外的定制。因为字段和其他任何类一样都是 Python 类，所以它的工作方式和您预期的一样，但是有一点不同。为了使用与其他 Python 代码交互不同的值与数据库交互，`attname`属性需要与`name`属性不同。这是由一个自定义的`get_attname()`方法控制的。

`from django.db import models`

`class PickleField(models.TextField):`

`def get_attname(self):`

`return '%s_pickled' % self.name`

仅此一项就足以为数据库正确设置字段。在这一点上，甚至可以将一个`PickleField`实例分配给一个模型，并将其与数据库同步，并且所创建的列在这个示例的持续时间内将完全可用。当然，它只管理到目前为止的原始数据；它根本不能处理真正的 Python 对象，更不用说处理必要的酸洗和拆洗了。

#### 酸洗和反酸洗数据

为了在完整的 Python 对象和可以存储在数据库中的字符串表示之间进行转换，Python 的 pickling 模块 [<sup>10</sup>](#Fn10) 将是首选工具。实际上 Python 为此提供了两个独立的模块:`cPickle`，用 C 编写以提高性能，和`pickle`，用纯 Python 编写以提高灵活性和可移植性。两者之间有一些细微的区别， [<sup>11</sup>](#Fn11) 但是可以互换使用。

有两个可用的模块使得导入比平常更棘手。由于显而易见的原因，拥有更好的性能是非常有价值的，但是 Python 和 Django 的一个关键方面是跨多个平台和环境使用的能力。因此，当希望导入一个酸洗模块时，最好先尝试更高效的模块，必要时再使用更便携的模块。

`try:`

`import cPickle as pickle`

`except ImportError:`

`import pickle`

有了一个可用的`pickle`模块，我们可以给`PickleField`实际上提取和反提取数据的能力。通过提供几个基本方法，可以以更加面向对象的方式与底层模块进行交互。此外，可以有把握地假设，当准备提交到数据库时，字段的值将是完整的 Python 对象，这显然必须经过处理。

另一方面，当使用 QuerySet 的`filter()`方法与数据库中的值进行比较时，经过酸洗的数据将毫无用处。从技术上讲，将查询的值与数据库中找到的值进行比较是可能的，但是比较的是经过提取的值，而不是原始的 Python 对象，这可能会导致不正确的结果。

更重要的是，即使保证了在必要时可以正确地解除对一个已标记值的拾取，但是在不同的场合或者可能在不同的机器上标记的同一个值很可能会有不同的字符串来表示原始对象。这是酸洗工作方式的副作用，必须加以考虑。

考虑到这一点，允许对经过标记的数据进行任何类型的比较都是不合理的，所以如果试图进行这样的比较，应该抛出一个异常。如本章前面所述，该行为由`get_db_pre_lookup()`控制，它可以被覆盖以抛出这样的异常。到目前为止，整个字段如下:

`class PickleField(models.TextField):`

`def pickle(self, obj):`

`return pickle.dumps(obj)`

`def unpickle(self, data):`

`return pickle.loads(str(data))`

`def get_attname(self):`

`return '%s_pickled' % self.name`

`def get_db_prep_lookup(self, lookup_type, value):`

`raise ValueError("Can't make comparisons against pickled data.")`

注意`pickle`和`cPickle`只支持 pickled 数据字符串作为纯字节字符串，不支持完整的 Unicode 字符串。由于 Django 中的所有内容都尽可能地被强制转换成 Unicode，包括从数据库中检索，`unpickle()`需要采取额外的步骤将其强制转换回字节字符串，以便正确地解包。

WHY THE EXTRA METHODS?

当 pickling 模块已经在模块的名称空间中可用时，定义单独的`pickle()`和`unpickle()`方法似乎有点奇怪。毕竟，对于开发人员来说，这不仅需要编写额外的代码行，而且 Python 还需要执行额外的函数调用来完成工作，这稍微减慢了速度，而且看起来没有必要。

这样做的最大好处是，如果任何其他应用程序需要继承`PickleField`的子类，并且希望覆盖数据是如何被提取和取消提取的，那么拥有显式的方法会使这个过程变得更加容易。它们可以像普通的一样被覆盖，只要其余的`PickleField`只是引用这些方法，子类就可以很好地工作。

这让我们更近了一步，因为`PickleField`可以正确地在数据库中存储值。然而，它仍然没有解决将数据加载到 Python 对象中的主要问题，并且只在真正必要时才这样做。

#### 按需拆卸

如果我们不关心性能，很容易在`to_python()`方法中执行拆包步骤，只需使用`SubfieldBase`来确保每次实例化一个对象时都发生拆包，而不管它来自哪里。不幸的是，对于那些不能访问该字段的情况，这会导致大量不必要的开销，所以仍然值得按需加载它，只有在请求时才加载。

如前所述，Python 描述符特别适合这种场景。它们在访问属性时被调用，并且可以在那时执行自定义代码，用为手边的任务设计的东西替换标准的 Python 行为。

第一步是确定如何实例化描述符，这也意味着确定完成工作需要哪些数据。为了正确地从模型实例中检索原始数据，它需要访问 field 对象，从中可以收集字段本身的名称。

`class PickleDescriptor(property):`

`def __init__(self, field):`

`self.field = field`

它将存储对该字段所有功能的引用，这些功能在以后会很有用。有了这些，就有可能编写`__get__()`和`__set__()`方法，从长远来看，它们将真正完成艰巨的工作。实际上，`__set__()`是两者中比较容易实现的；它只需将原始数据直接分配给实例的名称空间。

`def __set__(self, instance, value):`

`instance.__dict__[self.field.name] = value`

`setattr(instance, self.field.attname, self.field.pickle(value))`

有了这些，整个过程中最棘手的部分就是描述符的`__get__()`方法，它必须能够执行以下任务才能正常工作。

*   确定是否需要创建完整的 Python 对象。
*   仅在必要时，通过分离原始数据来生成完整的 Python 对象。
*   缓存生成的 Python 对象以备将来使用。
*   如果对象的缓存副本可用，则返回它，否则返回新的副本。

最后一点实际上有点转移注意力，因为很容易确保在方法的末尾有一个 Python 对象可用，并且只返回它，而不考虑它来自哪里。其余的，虽然看起来像一个洗衣清单，但是用一个小的、可读的方法来执行所有这些任务并不困难。

`def __get__(self, instance, owner):`

`if instance is None:`

`return self`

`if self.field.name not in instance.__dict__:`

`# The object hasn't been created yet, so unpickle the data`

`raw_data = getattr(instance, self.field.attname)`

`instance.__dict__[self.field.name] = self.field.unpickle(raw_data)`

`return instance.__dict__[self.field.name]`

这个方法如何执行每个需求应该是相当清楚的。第一个块检查来自模型类的访问，引发适当的异常。第二个块执行另外三项任务，首先检查缓存副本的存在，否则继续执行。然后，它在一行中执行两次以上的操作，如果缓存中没有填充原始数据，就将它存储在缓存中。最后，它只是返回缓存中的内容，而不管该方法开始时它是否在缓存中。

#### 把这一切放在一起

要使整个工作正常进行，唯一要做的就是在正确的时间获取模型上的描述符，这样在访问属性时就可以调用它了。这正是`contribute_to_class()`的意图，Django 已经为第三方代码提供了一种方式，比如这样，来绑定到模型创建过程中。只要确保总是在父类上调用`conribute_to_class()`方法，以确保所有标准的 Django 功能以及应用程序更特殊的需求都得到应用。

`def contribute_to_class(self, cls, name):`

`super(PickleField, self).contribute_to_class(cls, name)`

`setattr(cls, name, PickleDescriptor(self))`

有了所有这些，我们总共有三个 import 语句、两个新类和一个新字段来执行一个非常有用的任务。这只是如何使用这种技术的一个例子，还有很多使用复杂 Python 数据结构的应用程序。从这个例子中得到的重要的东西是如何在必要的时候使用描述符来填充那些复杂的对象，这在不经常使用描述符的情况下是一个很大的优势。

`try:`

`import cPickle as pickle`

`except ImportError:`

`import pickle`

`from django.db import models`

`class PickleDescriptor(property):`

`def __init__(self, field):`

`self.field = field`

`def __get__(self, instance, owner):`

`if instance is None:`

`return self`

`if self.field.name not in instance.__dict__:`

`# The object hasn't been created yet, so unpickle the data`

`raw_data = getattr(instance, self.field.attname)`

`instance.__dict__[self.field.name] = self.field.unpickle(raw_data)`

`return instance.__dict__[self.field.name]`

`def __set__(self, instance, value):`

`instance.__dict__[self.field.name] = value`

`setattr(instance, self.field.attname, self.field.pickle(value))`

`class PickleField(models.TextField):`

`def pickle(self, obj):`

`return pickle.dumps(obj)`

`def unpickle(self, data):`

`return pickle.loads(str(data))`

`def get_attname(self):`

`return '%s_pickled' % self.name`

`def get_db_prep_lookup(self, lookup_type, value):`

`raise ValueError("Can't make comparisons against pickled data.")`

`def contribute_to_class(self, cls, name):`

`super(PickleField, self).contribute_to_class(cls, name)`

`setattr(cls, name, PickleDescriptor(self))`

### 在运行时动态创建模型

[第 2 章](02.html)展示了 Python 类如何像其他任何类一样是真正的对象，并且可以在运行时通过使用内置的`type()`构造函数和传递一些关于如何定义它的细节来创建。由于 Django 模型实际上只是以特定方式声明的 Python，因此有理由期望它们也可以在运行时使用相同的特性来创建。必须小心，但这在各种情况下都是非常有用的技术。

诀窍是记住 Python 如何处理类，Django 如何处理它的模型。第 2 章已经说明了完成这项工作所必需的基本工具，所以现在的问题只是将它应用到 Django 模型的具体细节上。有几件事情将模型与其他 Python 类区分开来:

*   所有型号子类`django.db.models.Model`。
*   字段在模型的声明中被指定为类属性。
*   额外的选项在模型声明中的`Meta`类中指定。

有了这些概述的需求，将模型声明映射到`type()`的参数就相当容易了。特别要记住，构造一个类需要三个参数:`name`、`bases`和`attrs`。模型的名字被清晰地映射到`name`，而`models.Model`的单个子类可以被包装在一个元组中并传递给`bases`。类声明的其余部分将放入`attrs`，包括一个用于任何附加模型级配置选项的`Meta`类。

#### 第一遍

为了第一次了解这个函数可能是什么样子，让我们从类创建的最基本的方面开始，然后从那里开始。首先，考虑一个生成具有正确名称和基类的类的函数，以说明动态创建一个类并返回它供其他地方使用的基本技术。

`from django.db import models`

`def create_model(name):`

`return type(name, (models.Model,), {})`

不幸的是，这实际上有点过于简单化了。在 Python 中尝试这样做将会产生一个`KeyError`，因为 Django 期望属性字典包含一个`__module__`键，其值是定义模型的模块的导入路径。这通常由 Python 为源文件中定义的所有类自动填充，但是因为我们是在运行时生成模型，所以它是不可用的。

这只是动态模型必须面对的一个小细节，没有办法完全避免它。相反，`create_model()`需要被更新以直接提供一个`__module__`属性。这也是为什么把这段代码放在一个地方是个好主意的另一个例子；想象一下，每次需要动态模型时都必须处理这个问题。下面是包含类的模块路径的样子:

`def create_model(name, module_path):`

`return type(name, (models.Model,), {'__module__': module_path})`

现在它可以接受一个模块路径，让 Django 高兴。只要模块路径已经被导入，它就能让 Django 高兴，这意味着它必须实际存在。在正常情况下，模型的`__module__`属性被设置为定义它的模块的路径。因为模型只会在执行模块时被处理，所以总是保证模块存在并且已经被成功导入。毕竟，如果没有的话，这个模型会在第一时间被发现。

现在，由于模块路径的唯一要求是它是有效的并且已经被导入，Django 自己的`django.db.models`将成为一个合理的候选。当然，应该在适当的时候覆盖它，但是在事情开始之前，这是一个不错的默认设置。

`def create_model(name, attrs={}, module_path='django.db.models'):`

`attrs = dict(attrs, __module__=module_path)`

`return type(name, (models.Model,), attrs)`

显然，这些动态模型在很大程度上改变了事物，绕过了 Python 通常如何处理这样的过程。`__module__`问题只是遇到的第一个问题，也是最容易解决的问题之一。值得庆幸的是，即使还有一些其他的问题需要处理，如果使用得当，也是值得的。

这个基本示例的下一步是包含一个属性字典，这些属性就像是直接在类定义中声明的一样。这将允许在模型中包含字段，以及自定义管理器和通用方法，如`__unicode__()`。因为我们已经传递了一个用作属性的字典，所以向该字典分配附加项是一个简单的过程。

`def create_model(name, attrs={}, module_path='django.db.models'):`

`attrs = dict(attrs, __module__=module_path)`

`return type(name, (models.Model,), attrs)`

通常，提供一个可变对象(比如字典)作为默认参数是不明智的，因为对它的修改会影响函数未来的所有执行。然而，在本例中，它仅用于填充一个新的字典，并立即被新的字典替换。正因为如此，使用默认参数是安全的，这样可以保持方法的简洁。

到目前为止，我们已经建立了一个 3 行函数来创建具有任意数量属性的基本模型，然后可以在 Django 的其他领域中使用。从技术上讲，这个函数本身可以用来生成任何可以想象的模型，但是它已经为设置`__module__`提供了一个快捷方式，所以通过`Meta`内部类为设置模型配置提供另一个快捷方式是有意义的。这样，创建模型的代码就不必直接设置那个类。

#### 添加模型配置选项

Django 模型通过一个名为`Meta`的内部类接受配置，该类包含所有指定选项的属性。这听起来应该很熟悉，因为这基本上也是模型本身所做的。不幸的是，由于 Django 处理`Meta`类的方式，我们不得不采用不同的方法。

在`Meta`中定义的属性被传递到一个特殊的`Options`对象中，该对象位于`django.db.models.options`。作为这个过程的一部分，`Options`确保没有提供它不知道如何处理的属性。不幸的是，因为`Meta`是一个类的事实只是将它的名称空间从主模型中分离出来的一种方式。`Options`只知道如何处理旧式 Python 类——即不从内置`object`类型继承的类。

这是一个重要的区别，因为直接调用`type()`会创建一个新样式的类，即使它不是从`object`或者任何子类继承的。这最终在类上创建了两个额外的属性，`Options`不知道如何处理，所以它引发了一个`TypeError`来指出这个问题。创建一个`Meta`类有两种选择:删除额外的属性或者使用其他方法创建一个旧式的类。

虽然可以删除冒犯`Options`的属性，但更好的办法是提供它所期望的:一个旧式的类。显然，使用`type()`是不可能的，这让我们只能使用标准语法声明一个类。因为这甚至在函数中也是可能的，而且它的名称空间字典可以用新的属性更新，所以这是解决这个问题的一个不错的方法。

`from django.db import models`

`def create_model(name, attrs={}, meta_attrs={}, module_path='django.db.models'):`

`attrs['__module__'] = module_path`

`class Meta: pass`

`Meta.__dict__.update(meta_attrs, __module__=module_path)`

`attrs['Meta'] = Meta`

`return type(name, (models.Model,), attrs)`

这将接受两个属性字典，一个用于模型本身，另一个用于`Meta`内部类。这允许随时创建完全定制的 Django 模型。虽然目前这看起来是一个相当抽象的概念，但是请参见第一章中的完整例子，了解如何在实践中自动记录模型的所有变更。

## 现在怎么办？

有了 Django 模型的坚实基础，下一步是编写一些允许用户与这些模型交互的代码。下一章将展示视图如何为您的用户提供对这些模型的访问。

Footnotes [1](#Fn1_source)

1 [`http://prodjango.com/sql-injection/`](http://prodjango.com/sql-injection/)

  [2](#Fn2_source)

2 [`http://prodjango.com/model-inheritance/`](http://prodjango.com/model-inheritance/)

  [3](#Fn3_source)

3 [`http:/prodjango.com/serialization/`](http://prodjango.com/serialization/)

  [4](#Fn4_source)

4 [`http://prodjango.com/timedelta/`](http://prodjango.com/timedelta/)

  [5](#Fn5_source)

5 [`http://prodjango.com/postgresql-interval/`](http://prodjango.com/postgresql-interval/)

  [6](#Fn6_source)

6 [`http://prodjango.com/db-api/`](http://prodjango.com/db-api/)

  [7](#Fn7_source)

7 [`http://prodjango.com/file-api/`](http://prodjango.com/file-api/)

  [8](#Fn8_source)

8 [`http://prodjango.com/stringio/`](http://prodjango.com/stringio/)

  [9](#Fn9_source)

9 [`http://prodjango.com/open/`](http://prodjango.com/open/)

  [10](#Fn10_source)

10 [`http://prodjango.com/pickle/`](http://prodjango.com/pickle/)

  [11](#Fn11_source)

11 [`http://prodjango.com/cpickle/`](http://prodjango.com/cpickle/)