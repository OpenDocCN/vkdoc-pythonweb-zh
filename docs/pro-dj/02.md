# 二、Django 就是 Python

Abstract

Django 和其他框架一样，是建立在底层编程语言上的——在这里是 Python——来完成它的工作。许多不熟悉 Django 的人也不熟悉 Python，Python 的自然感觉语法结合 Django 的节能特性可以使 Django 看起来像是使用了某种元语言，但事实并非如此。

Django 和其他框架一样，是建立在底层编程语言上的——在这里是 Python——来完成它的工作。许多不熟悉 Django 的人也不熟悉 Python，Python 的自然感觉语法结合 Django 的节能特性可以使 Django 看起来像是使用了某种元语言，但事实并非如此。

要想正确理解 Django 能做什么，首先必须知道 Django 就是 Python，就像所有的应用一样。在 Python 中可以完成的任何事情在 Django 中都可以完成，这使得可能性几乎是无限的。

这也意味着 Django 应用不仅可以访问整个 Python 标准库，还可以访问大量第三方库和实用程序。其中一些接口是随 Django 本身一起提供的，所以在很多情况下，现有的代码和文档足以快速启动并运行应用。

在本书的后面，将会介绍一些额外的实用程序，以及一些关于如何将它们集成到 Django 应用中的技巧。可能性不仅限于本书中概述的选项，所以请随意寻找有助于支持您的商业计划的 Python 实用程序，并使用本书中列出的技术将它们集成到您的应用中。

虽然学习 Python 超出了本书的范围，但是 Django 使用了它的一些高级特性。在这一章中，我将讨论其中的许多特性，以帮助你理解 Python 是如何帮助实现让每个人都更容易的目标的。

## Python 如何构建类

Django 所依赖的一些最先进的 Python 技术与 Python 如何构造其类有关。这个过程通常被大多数开发人员认为是理所当然的——也应该如此——但是因为它是 Django 的核心，所以它构成了这个探索的基础。

当 Python 解释器遇到一个类定义时，它会像读取任何其他代码一样读取它的内容。然后，Python 为该类创建了一个新的名称空间，并执行其中的所有代码，将所有变量赋值写入这个新的名称空间。类定义通常包含变量、方法和其他类，所有这些基本上都是类的命名空间的赋值。然而，这里几乎允许任何有效的代码，包括打印到控制台输出、写入日志文件甚至触发 GUI 交互。

一旦内容执行完毕，Python 就会有一个类对象，通常放在定义它的名称空间(通常是模块的全局名称空间)中，然后在这里传递或调用它来创建该类的实例。

>>>类正常类:

...打印(“加载正常类”)

...垃圾邮件= '鸡蛋'

...打印(“完成加载”)

...

正在加载普通类

完成加载

>>>普通类

<class></class>

> > > NormalClass.spam

鸡蛋

如您所见，代码在类定义中执行，一旦类准备就绪，任何赋值变量都显示为类属性。

### 以编程方式构建类

上一节描述的过程适用于任何源代码声明的类，但是 Python 处理它的方式提供了更有趣的可能性。在幕后，关于类声明的细节被发送到内置的`type`对象，该对象负责为类创建适当的 Python 对象。对于每个类，当它完成对类声明内容的解析时，这将自动发生。

`type`的构造函数接受三个参数，它们代表整个类声明。

*   `name`—以字符串形式提供给类的名称
*   `bases`—类的继承链中的类元组；可能是空的
*   `attrs`—类名称空间的字典

COMPATIBILITY: NEW-STYLE CLASSES IN PYTHON 2

本节描述的过程适用于新型 Python 类，Python 2.2 [<sup>1</sup>](#Fn1) 中引入的区别在 Python 3 中已经完全去除，但是如果您正在使用 Python 2，您将需要确保强制使用新型类。为此，只需确保该类继承自其继承链中某处的内置`object`类型。

Django 提供的所有子类都已经从`object`派生出来了，所以任何进一步的派生都将自动成为新类型的类，而不需要您做任何额外的工作。尽管如此，记住这种区别是很重要的，这样你的应用可能需要的任何自定义类都将表现出本章概述的行为。

像任何 Python 对象一样，新的`type`可以在任何时间从任何代码块实例化。这意味着您的代码可以基于运行时收集的数据构造一个新的类。下面的代码演示了一种在运行时声明类的方法，它在功能上等同于上一节中提供的示例。

> > > dynamic class = type(' dynamic class '，()，{'spam': 'eggs'})

>>>动态类

<class></class>

> > > DynamicClass.spam

鸡蛋

A WARNING ABOUT TYPE()

手动使用`type()`可以很容易地创建重名的类，甚至可以通过在字典的`attrs`参数中提供一个`__module__`键来定制模块的位置。尽管这些特性可能是有用的，正如本书后面将要展示的，但是它们会导致自省的问题。

您可以合理地拥有两个具有相同名称和模块的不同类，但是您的代码无法区分它们之间的区别。在某些情况下，这可能不是问题，但是需要注意。

### 元类改变了它

实际上是一个元类——一个创建其他类的类——我们所从事的被称为元编程。 [<sup>2</sup>](#Fn2) 本质上，元编程是在运行时而不是编程时创建或修改代码。Python 允许一个类定义一个不同的元类来执行它的工作，从而允许您定制这个过程。

如果一个类定义包含一个单独的类作为它的`metaclass`选项，那么这个元类将被调用来创建这个类，而不是内置的`type`对象。这允许您的代码读取、修改甚至完全替换已声明的类，以进一步定制其功能。从技术上讲，`metaclass`选项可以被赋予任何有效的 Python callable，但是大多数元类都是`type`的子类。元类接收新类作为它的第一个参数，并提供对类对象及其声明细节的访问。

为了帮助说明元类参数是如何从类定义中派生出来的，以下面的代码为例。

>>>类元类(类型):

-我...。def _ _ init _(cls、名称、基础、属性):

...打印('定义%s' % cls ')

...打印('名称:%s' % name ')

...print(' base:% s ' %(base，))

...打印('属性:')

...对于 attrs.items()中的(名称，值):

...打印(' %s: %r' %(名称，值))

...

> > > class RealClass(object，元类=元类):

...垃圾邮件= '鸡蛋'

...

定义<class></class>

名称:RealClass

碱基:(<class>，)</class>

属性:

垃圾邮件:“鸡蛋”

__ 模块 __: '__main__ '

__qualname__: 'RealClass '

> > > RealClass

<class></class>

注意，这个类在任何时候都没有被实例化；创建类的简单动作触发了元类的执行。注意属性列表中的`__module__`:这个属性是所有 Python 类的标准部分。

虽然这个例子使用了`__init__`方法来对新创建的类执行特殊处理，但是还有另一个更强大的方法叫做`__new__`，它有一组不同的可能性。如后面章节所述，Django 在配置它的许多类时使用了`__new__`。

COMPATIBILITY: METACLASSES IN PYTHON 2

Python 3 引入了将参数传递给类定义的能力，如这里的`metaclass`选项所示。在 Python 2 中，元类被分配给一个名为`__metaclass__`的类变量。两个版本的效果是相同的；这只是语法上的变化。

### 将基类与元类一起使用

元类可能非常有用，但是`metaclass`选项是一个实现细节，在定义类时不应该成为过程的一部分。另一个问题是，虽然每个类都由元类处理，但它们并不从任何具体的类继承。这意味着任何额外的功能，比如公共方法或属性，都必须在元类处理过程中提供才能发挥作用。

稍加小心，具体的 Python 类可以使用元类来解决这两个问题。因为子类从其父类继承属性，所以`metaclass`选项自动提供给定义它的类的所有子类。这是为任意类提供元类处理的一种简单有效的方法，不需要每个类都定义`metaclass`选项。按照上一节的例子，看看当我们子类化`RealClass`时会发生什么。

> > > class 子类(RealClass): #注意这里没有元类。

...及格

...

定义<class></class>

名称:子类

碱基:(<class>，)</class>

属性:

__ 模块 __: '__main__ '

注意这里的子类不必担心在幕后有一个元类在使用。通过指定一个基类，它继承了所有的好处。Django 使用这个行为来实现它最突出的特性之一，将在下一节中描述。

### 声明语法

Django 的一些更突出的工具具有“声明性语法”,读、写和理解都很简单。该语法旨在最大限度地减少“样板”重复语法，并提供优雅、可读的代码。例如，下面是一个典型的 Django 模型和更多可能的样子:

班级联系(模型。型号):

"""

向网站所有者发送消息时提供的联系信息。

"""

名称=型号。CharField(max_length=255)

邮件=模特。电子邮件字段()

这种声明性语法已经成为 Django 代码的一个识别特征，所以许多提供额外框架的第三方应用都使用类似于 Django 本身的语法。这有助于开发人员更容易理解和利用新代码，因为它让所有代码感觉更有凝聚力。一旦您理解了如何使用声明性语法创建一个类，您将能够很容易地使用 Django 的许多特性来创建类，包括官方和社区提供的特性。

单独看一下声明性语法，就会发现为 Django 创建一个符合这种模式的全新框架是多么容易。在您自己的代码中使用声明性语法将有助于您和您的同事更容易地适应代码，从而确保更高的生产率。毕竟，开发效率是 Django 和 Python 本身的主要目标。

虽然接下来的几节描述了一般的声明性语法，但是给出的例子是针对 Django 的对象关系映射器(ORM)的，详见第 3 章。

#### 集中访问

通常，一个包会提供一个单独的模块，应用可以通过这个模块访问所有必要的实用程序。这个模块可以从树中的其他地方提取单独的类和函数，所以它们仍然可以使用可维护的名称空间，但是它们都将被收集到一个中心位置。

从 django.db 导入模型

一旦导入，该模块至少提供一个类，作为基于框架的子类的基类。提供了附加的类作为新子类的属性。这些对象将共同控制新类的工作方式。

#### 基类

每个特性都以至少一个基类开始。根据框架的需要，可能会有更多，但是为了使这种语法成为可能，至少需要一个。如果没有它，您要求用户定义的每个类都必须显式地包含一个元类，这是大多数用户不需要知道的实现细节。

班级联系(模型。型号):

除了检查已定义的属性，这个基类还将提供一组子类将自动继承的方法和属性。像任何其他类一样，它可以根据需要简单或复杂，以提供框架所需的任何特性。

#### 属性类别

提供基类的模块还将提供一组要实例化的类，通常带有可选的参数来定制它们的行为，并被指定为新类的属性。

班级联系(模型。型号):

名称=型号。CharField(max_length=255)

邮件=模特。电子邮件字段()

这些对象提供的特性在不同的框架中会有很大的不同，有些特性的行为可能与标准属性大相径庭。通常，它们会与元类相结合，提供一些额外的幕后功能，而不仅仅是简单地分配一个属性。这些属性类的选项通常由元类在创建这个额外功能时读取。

例如，Django 的`Model`使用字段属性的名称和选项来描述底层数据库表，然后可以在数据库中自动创建该表。字段名称用于访问该表中的各个列，而属性类和选项会自动将原生 Python 数据类型转换为适当的数据库值。下一章将提供更多关于 Django 如何处理模型类和字段的信息。

##### 分类属性排序

使用声明性语法时，一个潜在的混淆点是 Python 字典是无序的，而不是遵守它们的值被赋值的顺序。通常这不是问题，但是在检查名称空间字典时，不可能确定键的声明顺序。如果一个框架需要遍历它的特殊属性，或者向用户或程序员显示这些属性，那么按照定义的顺序访问这些属性通常是很有用的。这给了程序员对属性顺序的最终控制权，而不是由编程语言决定的任意顺序。

一个简单的解决方案是让属性自己跟踪实例化序列；然后元类可以相应地对它们进行排序。这个过程的工作原理是让所有的属性类都从一个特定的基类继承，这个基类可以计算类被实例化的次数，并为每个实例分配一个数字。

class BaseAttribute(对象):

creation_counter = 1

def __init__(self):

self . creation _ counter = base attribute . creation _ counter

base attribute . creation _ counter+= 1

对象实例与类有不同的名称空间，所以这个类的所有实例都有一个`creation_counter`，它可以用来根据实例化的顺序对对象进行排序。这不是这个问题的唯一解决方案，但是 Django 是这样对模型和表单的字段进行排序的。

#### 类别声明

有了模块中的所有这些类，创建一个应用类就像定义一个子类和一些属性一样简单。不同的框架对于属性类会有不同的名称，并且对于哪些类是必需的或者它们可能被应用的组合会有不同的需求。它们甚至可能有保留名称，如果您使用该名称定义属性，这将导致冲突，但这种问题很少发生，并且在开发使用该语法的新框架时，通常不鼓励保留名称。一般的规则是允许开发者尽可能的灵活，没有框架的阻碍。

从 django.db 导入模型

班级联系(模型。型号):

"""

向网站所有者发送消息时提供的联系信息。

"""

名称=型号。CharField(max_length=255)

邮件=模特。电子邮件字段()

仅仅这些简单的代码就足以让框架给新类注入大量的附加功能，而不需要程序员手动处理这个过程。还要注意所有的属性类是如何从同一个基本模块中提供的，以及在分配给模型时是如何被实例化的。

类声明决不仅限于框架提供的那些特性。因为允许任何有效的 Python 代码，所以您的类可能包含各种方法和其他属性，与框架提供的特性混合在一起。

## 常见的鸭分型方案

你可能听过这句古老的谚语，“如果它走路像鸭子，说话像鸭子，那它就是鸭子。”莎士比亚在《罗密欧与朱丽叶》中更浪漫地发挥了这一思想，“就算我们把玫瑰叫做别的名字，它闻起来还是一样香。”这里反复出现的主题是，给一个物体起的名字与它的真实性质没有关系。这个想法是，不管标签是什么，你可以通过观察它的行为来合理地确定它是什么。

在 Python 和其他一些语言中，这个概念被扩展到对象类型。它不依赖于某个基类或接口来定义一个对象能做什么，而是简单地实现了按预期行为所必需的属性和方法。Python 中一个常见的例子是类似文件的对象，它是实现了至少一些与 Python 文件对象相同的方法的任何对象。以这种方式，许多库可以返回它们自己的对象，这些对象可以被传递给期望文件对象的其他函数，但同时保留特殊能力，例如只读、压缩、加密、从互联网连接的源拉取或任何数量的其他可能性。

此外，像其他语言中的接口一样，Python 对象一次可以是多种类型的 duck。例如，一个对象在某些方面表现为字典，而在其他方面表现为列表，这种情况并不少见。Django 的`HttpResponse`对象展示了这两种行为，并模仿了一个打开的文件对象。

在 Django 中，许多特性通过不提供特定的基类来利用 duck 类型。相反，每个特性都定义了一种协议，即一个对象为了正常工作而必须提供的一组方法和属性。这些协议中的许多都在 Django 的官方文档中有所介绍，本书将涵盖更多内容。您还将看到使用这种技术可以提供的一些特殊能力。

接下来的几节描述了一些常见的 Python 协议，这些协议贯穿于整个 Django，实际上贯穿于任何大型 Python 库。

### 可召回商品

Python 允许从许多来源执行代码，任何能够以与典型函数相同的方式执行的代码都被指定为可调用的。正如所料，所有的函数、类和方法都是可自动调用的，但是通过提供单个方法，任意对象类的实例也可以被指定为可调用的。

#### __call__(self[，…])

当实例化的对象被作为函数调用时，将执行该方法。它的工作方式和其他成员函数一样，只是调用方式不同。

>>>类乘数(对象):

...def __init__(self，factor):

...自身因素=因素

...def __call__(self，value):

...返回值*自身因素

...

> > > times2 =乘数(2)

>>>时代 2(5)

Ten

> > > times2(10)

Twenty

>>>乘以 3 =乘数(3)

> > > times3(10)

Thirty

Python 还提供了一个内置函数来帮助识别可调用对象。`callable()`函数采用单个参数，返回`True`或`False`，表示该对象是否可以作为函数调用。

>>>类基本(对象):

...及格

...

>>>类可调用(对象):

...def __call__(self):

...返回“已执行！”

...

> > > b =基本()

>>>可调用(b)

错误的

> > > c = Callable()

>>>可调用(c)

真实的

### 字典

字典是单个对象中键和值之间的映射。大多数编程语言都有某种形式的字典；其他语言称它们为“散列”、“映射”或“关联数组”除了通过指定一个键来简单地访问值之外，Python 中的字典还提供了许多方法来对底层映射进行更细粒度的操作。为了表现得更像一个真正的字典，一个对象可能会提供其他方法，在 Python 库参考中有记录。 [<sup>3</sup>](#Fn3)

#### __ 包含 _ _(自身，密钥)

由`in`操作符使用，如果指定的键出现在底层映射中，则返回`True`，否则返回`False`。这不应该引发异常。

#### __getitem__（自我，钥匙）

这将返回指定键引用的值(如果存在)。如果这个键不在底层映射中，它应该引发一个`KeyError`。

#### __setitem__(自身，关键字，值)

这将存储指定的值，以便以后由指定的键引用。如果这样的映射已经存在，这将覆盖由同一键引用的任何现有值。

> > > class CaseInsensitiveDict(dict):

...    def __init__（self， **kwargs）：

...对于 key，kwargs.items()中的值:

...self[key.lower()] =值

...def __contains__(self，key):

...return super(CaseInsensitiveDict，self)。__ 包含 __(key.lower())

...    防御 __getitem__（自我，密钥）：

...return super(CaseInsensitiveDict，self)。__getitem__(key.lower())

...def __setitem__(self，key，value):

...super(CaseInsensitiveDict，self)。__setitem__(key.lower()，value)

...

> > > d = CaseInsensitiveDict(SpAm = ' eggs ')

> > > d 中的“垃圾邮件”

真实的

> > d[“垃圾邮件”]

鸡蛋

> > d['垃圾邮件'] = 'burger '

> > d[“垃圾邮件”]

汉堡

字典也应该是可迭代的，当代码在字典的内容上循环时使用键的列表。有关更多信息，请参考即将到来的“Iterables”部分。

### 文件

如前所述，文件是访问信息的一种常见方式，许多 Python 库提供了类似文件的对象，用于其他与文件相关的函数。一个类似文件的对象不需要提供下面所有的方法，只需要提供那些正常工作所必需的方法。在文件协议的情况下，对象可以自由地实现读访问和/或写访问。这里没有列出所有的方法，只列出了最常用的方法。Python 标准库文档中提供了文件方法的完整列表，因此请务必查看该文档以了解更多详细信息。 [<sup>4</sup>](#Fn4)

#### 阅读(自我，[大小])

这将从对象或其信息源中检索数据。可选的`size`参数包含要检索的字节数。如果没有此参数，该方法应返回尽可能多的字节(通常是整个文件，如果可用的话，或者可能是网络接口上可用的所有字节)。

#### 写(自己，字符串)

这将指定的`str`写入对象或其信息源。

#### 关闭(自己)

这将关闭该文件，使其无法再被访问。这可以用来释放任何已分配的内存资源，将对象的内容提交到磁盘，或者只是满足协议。即使此方法不提供特殊功能，也应该提供它以避免不必要的错误。

A VERY LOOSE PROTOCOL

类似文件的对象有很多种，因为这个协议是所有 Python 中定义最宽松的协议之一。从缓冲输出到允许随机访问数据，有相当多的特性在某些情况下是不合适的，因此为这些情况设计的对象通常不会实现相应的方法。例如，Django 的`HttpResponse`对象，在[第 7 章](07.html)中描述，只允许顺序写入，所以它不实现`read()`、`seek()`或`tell()`，当与某些文件操作库一起使用时会导致错误。

在这种情况下，常见的方法是不实现任何不合适的方法，这样试图访问它们就会引发一个`AttributeError`。在其他情况下，程序员可能认为实现它们更有用，但是简单地抛出一个`NotImplementedError`来显示更具描述性的消息。只要确保总是记录你的对象遵守了多少协议，这样当用户试图将它们用作标准文件时，尤其是在第三方库中，如果出现这些错误就不会感到惊讶。

### 可重复的

如果将一个对象传递给内置的`iter()`返回一个迭代器，那么这个对象被认为是可迭代的。`iter()`通常被隐式调用，比如在`for`循环中。所有的列表、元组和字典都是可迭代的，通过定义下面的方法，任何新样式的类都可以成为可迭代的。

#### __iter__(self)

这个方法由`iter()`隐式调用，负责返回一个迭代器，Python 可以用它从对象中检索条目。通过将这个方法定义为一个生成器函数，返回的迭代器通常是隐含的，这将在接下来的“生成器”一节中描述。

>>>斐波那契类(对象):

...def __init__(self，count):

...self.count =计数

-我...。def __iter_(自我):

...a，b = 0，1

...对于范围内的 x(自计数):

...如果 x < 2:

...产量 x

...否则:

...c = a + b

...产量 c

...a，b = b，c

...

>>>对于斐波那契中的 x(5):

...打印(x)

...

Zero

one

one

Two

three

>>>对于斐波那契中的 x(10):

...打印(x)

...

Zero

one

one

Two

three

five

eight

Thirteen

Twenty-one

Thirty-four

#### 迭代程序

当用一个对象调用`iter()`时，它应该返回一个迭代器，然后这个迭代器可以用来按顺序检索该对象的项目。迭代器是一种简单的单向遍历可用条目的方法，一次只返回一个条目，直到没有更多条目可用。对于大型集合，逐个访问项目比首先将它们全部收集到一个列表中要高效得多。

##### 下一个(自己)

迭代器唯一需要的方法是返回一个条目。如何检索该项将取决于迭代器的设计目的，但它必须只返回一项。在那个项目被称为迭代器的代码处理之后，将再次调用`next()`来检索下一个项目。

一旦没有更多的项要返回，`next()`还负责告诉 Python 停止使用迭代器，并在循环后继续前进。这是通过引发`StopIteration`异常来完成的。Python 将继续调用`next()`，直到出现异常，导致无限循环。要么使用`StopIteration`优雅地停止循环，要么使用另一个异常来指示更严重的问题。

FibonacciIterator 类(对象):

def __init__(self，count):

self.a = 0

self.b = 1

self.count =计数

自电流= 0

def __next__(自己):

自电流+= 1

如果自身电流>自身计数:

提升停止迭代

如果自电流< 3:

返回自电流- 1

c =自我 a +自我 b

self.a = self

self.b = c

返回 c

下一个= __ 下一个 _ _

def __iter_(自我):

#因为它已经是一个迭代器，所以它可以返回自身。

回归自我

斐波纳契类(对象):

def __init__(self，count):

self.count =计数

def __iter_(自我):

返回斐波那契迭代器(self.count)

注意迭代器不需要显式定义`__iter__()`才能正确使用，但是包含该方法允许迭代器直接在循环中使用。

COMPATIBILITY: ITERATORS IN PYTHON 2

Python 3 中的迭代器只有一个非常小的变化。这里显示的`__next__()`方法以前叫做`next()`。注意缺失的下划线。这是为了尊重 Python 的习惯，即在方法名的前后使用双下划线来标识像这样的神奇方法。

如果您需要同时支持 Python 2 和 3，解决方案相当简单。在我们的 Fibonacci 示例中定义了`__next__()`之后，您可以直接将`__next__()`方法赋给该方法的下一个:`next = __next__`。这可以在类定义中的任何地方完成，但是最好是在`__next__()`方法结束之后，以保持整洁。

#### 发电机

如 Fibonacci 示例所示，生成器是创建简单迭代器的便捷方式，无需定义单独的类。Python 使用`yield`语句将函数标识为生成器，这使得它的行为与其他函数略有不同。

当调用生成器函数时，Python 不会立即执行任何代码。相反，它返回一个迭代器，迭代器的`next()`方法将调用函数体，直到第一个`yield`语句出现的地方。给予`yield`语句的表达式被用作`next()`方法的返回值，允许任何调用生成器的代码获得一个值来处理。

下一次在迭代器上调用`next()`时，Python 继续执行生成器函数，所有变量保持不变。只要 Python 遇到`yield`语句，这个过程就会重复，通常函数会使用一个循环来不断产生值。每当函数结束而没有产生值时，迭代器自动引发`StopIteration`来指示循环应该结束，剩下的代码可以继续。

### 顺序

虽然 iterables 只是描述一个一次检索一个值的对象，但是这些值通常都是预先知道的，并被收集在一个对象上。这是一个序列。最常见的类型是列表和元组。作为可迭代的，序列也使用`__iter__()`方法逐个返回它们的值，但是由于这些值也是预先知道的，所以一些额外的特性是可用的。

#### __len__(self)

有了所有可用的值，序列就有了特定的长度，这可以使用内置的`len()`函数来确定。在幕后，`len()`检查给定的对象是否有一个`__len__()`方法，并使用它来获得序列的长度。为了实现这一点，`__len__()`应该返回一个包含序列中项目数量的整数。

从技术上来说，`__len__()`并不要求预先知道所有的值，只需要知道有多少。因为不能有部分项目——一个项目要么存在，要么不存在——`__len__()`应该总是返回一个整数。如果没有，`len()`无论如何都会将它强制为一个整数。

> > > FibonacciLength 类(Fibonacci):

...def __len__(self):

...返回自我计数

...

> > len(fibonacclength(10))

Ten

> > len(fibonacclength(2048))

Two thousand and forty-eight

#### __getitem__(self)和 __setitem__(self，value)

序列中的所有值都已经排序，因此可以通过序列中的索引来访问单个值。因为用于这种类型访问的语法与字典键的语法相同，所以 Python 重用了前面针对字典描述的两种方法。这允许序列自定义如何访问单个值，或者可能限制为序列设置新值，使其成为只读的。

## 增强功能

除了标准的声明和调用，Python 还提供了允许您以有趣的方式调用函数的选项。Django 使用这些技术来帮助实现高效的代码重用。您也可以在您的应用中使用这些相同的技术；它们是 Python 的标准部分。

### 多余的论据

并不总是可能知道在运行时将向函数提供什么参数。在 Django 中经常是这种情况，类方法甚至在子类本身被适当定制之前就在源代码中定义了。另一种常见的情况是函数可以作用于任意数量的对象。在其他情况下，函数调用本身可以成为一种 API，供其他应用使用。

对于这些情况，Python 提供了两种特殊的方法来定义函数参数，这两种方法允许函数接受未由显式声明的参数处理的多余参数。这些“额外的”参数将在下面解释。

注意名字`args`和`kwargs`仅仅是 Python 的约定。与任何函数参数一样，您可以随意命名它们，但是与标准 Python 习惯用法的一致性使您的代码更容易被其他程序员访问。

#### 位置参数

在参数名称前使用单个星号允许函数接受任意数量的位置参数。

> > def multiple(* args):

...总计= 1

...对于 args 中的 arg:

...总计*=参数

...退货总额

...

>>>乘法(2，3)

six

>>>乘法(2，3，4，5，6)

Seven hundred and twenty

Python 将参数收集到一个元组中，然后可以作为变量`args`访问这个元组。如果除了那些显式声明的参数之外，没有提供任何位置参数，则该参数将用一个空元组填充。

#### 关键字参数

Python 在参数名称前使用两个星号来支持任意关键字参数。

> > > def accept(**kwargs):

...对于关键字，kwargs.items()中的值:

...打印(" % s--> % r " %(关键字，值))

...

>>>接受(foo='bar '，spam='eggs ')

foo ->

垃圾邮件->“鸡蛋”

注意`kwargs`是一个普通的 Python 字典，包含参数名和值。如果没有提供额外的关键字参数，`kwargs`将是一个空字典。

#### 混合参数类型

任意位置和关键字参数可以与其他标准参数声明一起使用。混合它们需要一些小心，因为它们的顺序对 Python 很重要。参数可以分为四类，虽然不是所有的类别都是必需的，但是它们必须按照下面的顺序定义，跳过任何不使用的类别。

*   必需的参数
*   可选参数
*   多余的位置参数
*   多余的关键字参数

def complex_function(a，b =无，*c，**d):

这个顺序是必需的，因为`*args`和`**kwargs`只接收那些不能放在任何其他参数中的值。如果没有这种顺序，当您调用带有位置参数的函数时，Python 将无法确定哪些值用于声明的参数，哪些值应被视为多余的位置参数。

还要注意，虽然函数可以接受任意数量的必需和可选参数，但它们只能定义一种多余的参数类型。

#### 传递参数集合

除了能够接收任意参数集合的函数之外，Python 代码还可以使用前面描述的星号标记来调用具有任意数量参数的函数。以这种方式传递的参数被 Python 扩展成一个普通的参数列表，这样被调用的函数就不需要为了像这样被调用而计划过多的参数。任何 Python 可调用函数都可以使用这种符号来调用，并且可以使用相同的排序规则与标准参数结合使用。

> > > def add(a，b，c):

...返回 a + b + c

...

>>>添加(1，2，3)

six

>>>相加(a=4，b=5，c=6)

Fifteen

> > > args = (2，3)

>>添加(1，*args)

six

总部，这里是总部

>>> add（a=7， **kwargs）

Twenty-four

> > > add(a=7，*args)

追溯(最近一次通话持续时间):

...

TypeError: add()获得了关键字参数“a”的多个值

>>>相加(1，2，a=7)

追溯(最近一次通话持续时间):

...

TypeError: add()获得了关键字参数“a”的多个值

如本例最后几行所示，如果显式传递任何关键字参数，同时还传递一个元组作为多余的位置参数，要特别小心。因为 Python 将使用排序规则扩展多余的参数，所以位置参数将首先出现。在这个例子中，最后两个调用是相同的，Python 不能确定哪个值用于`a`。

### 装饰者

另一种改变函数行为方式的常见方法是用另一个函数“装饰”它。这也经常被称为“包装”一个函数，因为 decorators 被设计成在原始函数被调用之前或之后执行额外的代码。

decorators 背后的关键原则是，它们接受可调用内容并返回新的可调用内容。装饰器返回的函数是稍后调用被装饰的函数时要执行的函数。必须小心确保原始函数不会在这个过程中丢失，因为没有任何方法可以在不重新加载模块的情况下恢复它。

装饰器可以以多种方式应用，要么应用于您直接定义的函数，要么应用于在其他地方定义的函数。从 Python 2.4 开始，新定义的函数上的 decorators 可以使用特殊的语法。在 Python 的以前版本中，需要稍微不同的语法，但是在两种情况下可以使用相同的代码；唯一的区别是用于将装饰器应用到预期函数的语法。

> > > def 装修(func):

...打印('装饰%s ... '% func。__name__)

...def wrapped(*args，**kwargs):

...print("调用带参数的包装函数:"，args)

-我...。return func(*args、**kwargs)

...打印('完成！')

...包装退货

...

Python 2.4 及更高版本的语法

> > > @装修

...定义测试(a，b):

...返回 a + b

...

装饰试验...

搞定了。

>>>测试(13，72)

调用带参数的包装函数:(13，72)

eighty-five

Python 2.3 的语法

> > > def 测试(a，b):

...返回 a + b

...

>>>测试=装修(测试)

装饰试验...

搞定了。

>>>测试(13，72)

调用带参数的包装函数:(13，72)

eighty-five

本例中较老的语法是修饰函数的另一种技术，可以在`@`语法不可用的情况下使用。考虑一个已经在其他地方声明过的函数，但它会从修饰中受益。这样一个函数可以传递给一个装饰器，装饰器然后返回一个新的函数，所有的东西都包装好了。使用这种技术，任何可调用的程序，不管它来自哪里或做什么，都可以被包装在任何装饰器中。

#### 用额外的参数装饰

有时候，装饰器需要额外的信息来决定它应该对收到的函数做什么。使用旧的修饰语法，或者在修饰任意函数时，这个任务相当容易执行。只需声明装饰器来接受所需信息的附加参数，这样它们就可以和要包装的函数一起提供。

> > > def 测试(a，b):

...返回 a + b

...

> > > def 装饰(func，prefix='Decorated '):

...def wrapped(*args，**kwargs):

...返回' %s: %s' %(前缀，func(*args，**kwargs))

...包装退货

...

>>>简单=装修(测试)

>>>定制=装饰(测试，前缀= '定制')

>>>简单(30，5)

装饰:35 英尺

>>>定制(27，15)

定制:42 英尺

然而，Python 2.4 装饰器语法使事情变得复杂了。当使用这种新语法时，装饰器总是只接收一个参数:要包装的函数。有一种方法可以将额外的参数引入 decorators，但是首先我们需要离题一点，谈谈“部分”

#### 函数的部分应用

通常，在执行函数时，调用函数时会使用所有必需的参数。然而，有时参数可能在函数被调用之前很久就已经知道了。在这些情况下，一个函数可以预先应用一个或多个参数，这样就可以用较少的参数调用该函数。

为此，Python 2.5 将`partial`对象作为其`functools`模块的一部分。它接受一个 callable 和任意数量的附加参数，并返回一个新的 callable，它的行为就像原来的 callable 一样，只是不需要在以后指定那些预先加载的参数。

>>>导入功能工具

> > > def add(a，b):

...返回 a + b

...

>>>添加(4，2)

six

> > > plus3 = functools.partial(add，3)

> > > plus5 = functools.partial(add，5)

> > > plus3(4)

seven

> > > plus3(7)

Ten

> > > plus5(10)

Fifteen

对于 than 2.5 之前的版本，Django 在位于`django.utils.functional`的`curry`函数中提供了自己的`partial`实现。该函数适用于 Python 2.3 及更高版本。

#### 回到装饰者的问题

如前所述，如果使用 Python 2.4 语法的 decorators 接受额外的参数，就会出现问题，因为该语法本身只提供一个参数。使用局部应用技术，甚至可以在装饰器上预加载参数。给定前面描述的装饰器，下面的例子使用`curry`(在[第 9 章](09.html)中描述)为使用较新的 Python 2.4 语法的装饰器提供参数。

>>>来自 django . utils . functional import curry

> > > @curry(装饰，前缀='Curried ')

...定义测试(a，b):

...返回 a + b

...

>>>测试(30，5)

咖喱:35 英尺

>>>测试(27，15)

咖喱:42 英尺

这仍然很不方便，因为每次使用这个函数来修饰另一个函数时，都需要运行这个函数。更好的方法是在装饰器本身中直接提供这个功能。这需要装饰者编写一些额外的代码，但是包含这些代码会使它更容易使用。

诀窍是在另一个函数中定义装饰器，该函数将接受参数。这个新的外部函数然后返回装饰器，Python 的标准装饰器处理使用这个装饰器。装饰器反过来返回一个函数，该函数将在装饰过程完成后被程序的其余部分使用。

由于这些都相当抽象，考虑下面的例子，它提供了与前面的例子相同的功能，但是不依赖于`curry`，使得处理起来更容易。

> > > def decorate(前缀='Decorated '):

...#此处传入的前缀将是

...#可用于所有内部函数

...定义装饰器(函数):

...#这是用 func 作为

...#被修饰的实际函数

-我...。def wrapper(*args、**kwargs):

...#每次都会调用这个函数

...#执行真正的功能

...返回' %s: %s' %(前缀，func(*args，**kwargs))

...#发送包装的函数

...返回包装

...#提供供 Python 使用的装饰器

...返回装饰者

...

> > > @装饰('轻松')

...定义测试(a，b):

...返回 a + b

...

>>>测试(13，17)

简单:30 分钟

>>>测试(89，121)

简单:210 英尺

这种技术在需要参数的情况下最有意义。如果在没有任何参数的情况下应用装饰器，为了让它正常工作，括号仍然是必需的。

> > > @装饰()

...定义测试(a，b):

...返回 a + b

...

>>>测试(13，17)

装饰:30 英尺

>>>测试(89，121)

装饰:210 英尺

> > > @装修

...定义测试(a，b):

...返回 a + b

...

>>>测试(13，17)

追溯(最近一次通话持续时间):

...

TypeError: decorator()只接受 1 个参数(给定了 2 个)

第二个例子失败了，因为我们没有首先调用`decorate`。因此，所有对`test`的后续调用都将其参数发送到`decorator`而不是`test`。由于这是一个不匹配，Python 抛出一个错误。这种情况可能有点难以调试，因为引发的确切异常将取决于被包装的函数。

#### 有或没有争论的装饰者

装饰器的另一个选择是提供一个单一的装饰器，它可以在前面两种情况下工作:有参数和没有参数。这个比较复杂，但是值得探讨。

目标是允许带参数或不带参数调用装饰器，所以假设所有参数都是可选的是安全的；任何带有必需参数的装饰器都不能使用这种技术。记住这一点，基本思想是在列表的开头添加一个额外的可选参数，它将接收要修饰的函数。然后，装饰器结构包括必要的逻辑来确定它是被调用来添加参数还是装饰目标函数。

> > > def 装饰(func=None，prefix='Decorated '):

...装饰定义(功能):

...#这将返回最终的修饰

...#函数，不管它是如何被调用的

-我...。def wrapper(*args、**kwargs):

...返回' %s: %s' %(前缀，func(*args，**kwargs))

...返回包装

...如果 func 为 None:

...#用参数调用了装饰器

...定义装饰器(函数):

...返回装饰(功能)

...返回装饰者

...#没有参数就调用了装饰器

...返回装饰(功能)

...

> > > @装修

...定义测试(a，b):

...返回 a + b

...

>>>测试(13，17)

装饰:30 英尺

> > > @修饰(前缀=“参数”)

...定义测试(a，b):

...返回 a + b

...

>>>测试(13，17)

参数:30 '

这要求传递给装饰器的所有参数都作为关键字参数传递，这通常有助于提高代码的可读性。一个缺点是，对于使用这种方法的每个装饰者来说，需要重复多少样板文件。

幸运的是，像 Python 中的大多数样板文件一样，可以将它分解成可重用的形式，因此可以使用另一个装饰器更容易地定义新的装饰器。以下函数可用于修饰其他函数，提供接受参数所需的所有功能，也可以不使用参数。

> > > def optional _ arguments _ decorator(real _ decorator):

...def decorator(func=None，**kwargs):

...#这是未来的装潢师

...#暴露于程序的其余部分

...装饰定义(功能):

...#这将返回最终的修饰

...#函数，不管它是如何被调用的

...定义包装(*a，**kw):

...return real_decorator(func，a，kw，**kwargs)

...返回包装

...如果 func 为 None:

...#用参数调用了装饰器

...定义装饰器(函数):

...返回装饰(功能)

...返回装饰者

...#没有参数就调用了装饰器

...返回装饰(功能)

...返回装饰者

...

> > > @optional_arguments_decorator

...def decorate(func，args，kwargs，prefix='Decorated '):

...返回' %s: %s' %(前缀，func(*args，**kwargs))

...

> > > @装修

...定义测试(a，b):

...返回 a + b

...

>>>测试(13，17)

装饰:30 英尺

> > > test = decorate(test，prefix='Decorated again ')

>>>测试(13，17)

再次装饰:装饰:30 '

这使得单个装饰者的定义更加简单明了。结果装饰器的行为与上一个例子完全一样，但是它可以带参数使用，也可以不带参数使用。这项新技术需要的最显著的变化是，被定义的真正的装饰器将接收以下三个值:

*   `func`—使用新生成的装饰器装饰的函数
*   `args`—包含传递给函数的位置参数的元组
*   `kwargs`—包含传递给函数的关键字参数的字典

然而，要认识到的一件重要的事情是，装饰器接收的`args`和`kwargs`是作为位置参数传递的，没有通常的星号符号。然后，当将它们传递给包装的函数时，必须使用星号符号来确保函数接收到它们，而不必知道装饰器是如何工作的。

## 描述符

通常，引用对象上的属性会直接访问属性值，没有任何复杂性。获取和设置属性会直接影响对象的实例命名空间中的值。有时，在访问这些值时必须做额外的工作。

*   从复杂的源中检索数据，如数据库或配置文件
*   将简单的值转换为复杂的对象或数据结构
*   自定义它所附着的对象的值
*   在保存到数据库之前，将值转换为可存储的格式

在一些编程语言中，通过创建额外的实例方法来访问那些需要它的属性，这种类型的行为成为可能。虽然这种方法很实用，但会导致一些问题。首先，这些行为通常更多地与属性中存储的数据类型相关联，而不是与它所附加到的实例的某些方面相关联。通过要求对象提供访问此数据的附加方法，包含此行为的每个对象都必须在其实例方法中提供必要的代码。

另一个重要问题是，当一个曾经简单的属性突然需要这种更高级的行为时会发生什么。当从简单属性更改为方法时，对该属性的所有引用也需要更改。为了避免这种情况，这些语言的程序员采用了一种标准的做法，即总是为属性访问创建方法，这样对底层实现的任何更改都不会影响任何现有的代码。

为了改变一个属性的访问方式而修改那么多代码并不有趣，所以 Python 提供了一种不同的方法来解决这个问题。与其要求对象负责对其属性的特殊访问，不如由属性本身来提供这种行为。描述符是一种特殊类型的对象，当它附加到一个类时，可以在访问属性时进行干预，提供任何必要的附加行为。

>>>导入日期时间

> > > class CurrentDate(object):

...def __get__(自身，实例，所有者):

...返回 datetime.date.today()

...def __set__(自身，实例，值):

...引发 NotImplementedError("不能更改当前日期。")

...

>>>类示例(对象):

-我...。date = CurrentDate()

...

> > > e = Example()

>>>电子日期

datetime.date（2008， 11， 24）

> > > e.date = datetime.date.today()

回溯(最近一次呼叫):

...

notimplemontederror:无法更改当前日期。

创建描述符就像创建一个标准的新型类一样简单(通过继承 Python 2.x 下的`object`),并至少指定以下方法之一。descriptor 类可以包含执行其负责的任务所需的任何其他属性或方法，而下面的方法构成了一种支持这种特殊行为的协议。

### __get__(自身，实例，所有者)

当检索一个属性的值(`value = obj.attr`)时，这个方法将被调用，允许描述符在返回值之前做一些额外的工作。除了通常的代表描述符对象的`self`之外，这个 getter 方法还接收两个参数。

*   `instance`—包含被引用属性的实例对象。如果属性被作为一个类的属性而不是一个实例引用，这将是`None`。
*   `owner`—分配了描述符的类。这将始终是一个类对象。

`instance`参数可以用来确定描述符是从一个对象还是它的类中访问的。如果`instance`是`None`，那么属性是从类而不是从实例中访问的。如果描述符被以不应该的方式访问，这可以用来引发一个异常。

此外，通过定义此方法，您可以让描述符负责检索一个值并将其返回给请求它的代码。否则将迫使 Python 返回其默认返回值`None`。

注意，默认情况下，描述符不知道在声明为属性时它们被赋予了什么名称。Django 模型提供了一种绕过这个问题的方法，这在第 3 章中有描述，但是除此之外，描述符只知道它们的数据，不知道它们的名字。

### __set__(自身，实例，值)

当给描述符(`obj.attr = value`)设置一个值时，这个方法被调用，这样一个更专门化的过程可以发生。像`__get__`一样，除了标准的`self`之外，这个方法还接收两个参数。

*   `instance`—包含被引用属性的实例对象。这绝对不会是`None`。
*   `value`—正在分配的值。

还要注意的是，描述符的`__set__`方法只有在对象上分配属性时才会被调用，而在第一次分配描述符的类上分配属性时永远不会被调用。这种行为是有意设计的，它禁止描述符完全控制其访问。外部代码仍然可以通过向首次赋值的类赋值来替换描述符。

还要注意来自`__set__`的返回值是不相关的。该方法本身只负责适当地存储所提供的值。

### 跟踪实例数据

因为描述符会缩短属性访问，所以在附加对象上设置值时需要小心。不能简单的用`setattr`在对象上设置值；尝试这样做将再次调用描述符，导致无限递归。

Python 提供了另一种访问对象名称空间的方法:`__dict__`属性。在所有 Python 对象上都可用，`__dict__`是一个表示对象名称空间中所有值的字典。直接访问这个字典绕过了 Python 关于属性的所有标准处理，包括描述符。利用这一点，描述符可以在不触发自身的情况下设置对象的值。考虑下面的例子。

>>>类描述符(对象):

...def __init__(self，name):

...self.name = name

...def __get__(自身，实例，所有者):

...返回实例。__dict__[self.name]

...def __set__(自身，实例，值):

...实例。__dict__[self.name] = value

...

>>>类 TestObject(对象):

...attr =描述符(' attr ')

...

>>> 检验 = 测试对象（）

> > > test.attr = 6

> > > test.attr

six

不幸的是，这种技术需要给描述符显式地给出属性的名称。您可以用一些元类技巧来解决这个问题；Django 的模型系统(在第 3 章中讨论)展示了一种可能的解决方法。

## 反省

许多 Python 对象在它们执行的代码之外携带元数据。这些信息在使用框架或编写自己的框架时非常有用。

当试图开发可重用的应用时，Python 的自省工具可以提供很大的帮助，因为它们允许 Python 代码检索关于程序员所写内容的信息，而不需要程序员重新编写。

本节描述的一些特性依赖于一个强大的标准库模块`inspect`。`inspect`模块提供了方便的功能来执行高级自检。

这里只详细介绍`inspect`的一些用途，因为它们对使用 Django 编写的应用最有价值。有关本模块中许多其他可用选项的完整详细信息，请参考 Python 标准库文档。 [<sup>5</sup>](#Fn5)

MORE ON OLD-STYLE CLASSES

本节中展示的例子都是针对新型类的，正如本章前面所描述的，新型类的行为不同于旧式类，特别是在内省方面。确切的区别超出了本书的范围，因为通常的建议是简单地使用新型类。

如果您的任何代码看起来与这里描述的行为不同，请确保您的所有类都从`object`继承，这将使它们成为适当的新型类。

### 常见的类和函数属性

所有的类和函数都提供了一些可以用来识别它们的公共属性。

*   `__name__`—用于声明类或函数的名称
*   `__doc__`—为函数声明的文档字符串
*   `__module__`—声明类或函数的模块的导入路径

此外，所有对象都包含一个特殊属性`__class__`，它是用于创建对象的实际类对象。该属性可用于多种目的，例如测试该类是否提供了特定的属性，或者是否在对象本身上设置了该属性。

> > > class ValueClass(object):

...source = ' class '

...

> > > value_instance = ValueClass()

> > > value_instance.source = '实例'

>>>值 _ 实例。__class__

<class></class>

>>>值实例.来源

'实例'

>>>值 _ 实例。__ 类 _ _。来源

“班级”

### 识别对象类型

因为 Python 使用动态类型，所以任何变量都可以是任何可用类型的对象。虽然 duck typing 的一般原则建议简单地测试对象对特定协议的支持，但是识别您正在处理的对象的类型通常是有用的。有几种方法可以解决这个问题。

#### 获取任意对象类型

使用前面描述的内置`type`很容易确定任何 Python 对象的类型。用单个参数调用`type`将返回一个类型对象，通常是一个类，它被实例化以产生对象。

>>>类型('这是一个字符串')

>>>类型(42)

>>>类 TestClass(object):

...及格

...

>>>型（测试类）

>>> obj = TestClass（）

>>>类型(对象)

<class></class>

这种方法通常不是确定对象类型的最佳方式，尤其是当您试图根据对象的类型来决定执行的分支时。它只告诉你正在使用的一个特定的类，即使子类可能被考虑用于同一个执行分支。相反，这种方法应该用在对象的类型不是决策所必需的，而是输出到某个地方的情况下，也许是输出到用户的日志文件中。

例如，在报告异常时，包含异常的类型及其值非常有用。在这些情况下，`type`可以用来返回类对象，然后它的`__name__`属性可以包含在日志中，很容易识别异常的类型。

#### 检查特定类型

更常见的是，您需要检查特定类型的影响，一个类是否是它的后代，或者一个对象是否是它的实例。这是一个比使用`type`更健壮的解决方案，因为它在决定成功或失败时考虑了类继承。

Python 为此提供了两个内置函数。

*   `issubclass(cls, base)`—如果`cls`和`base`相同，或者如果`cls`继承了`base`的某个祖先，则返回`True`
*   `isinstance(obj, base)`—测试对象是否是`base`的实例或其任何祖先

> > > class CustomDict(dict):

...pass #假装这里有更有用的东西

...

> > > issubclass(CustomDict，Dict)

真实的

> > > issubclass(CustomDict，CustomDict)

真实的

> > > my_dict = CustomDict()

>>实例(my_dict，dict)

真实的

>>事件(my_dict，CustomDict)

真实的

`issubclass`和`isinstance`有明确的关系:`isinstance(obj, SomeClass)`相当于`issubclass(obj.__class__, SomeClass)`。

### 功能签名

正如本章前面所描述的，Python 函数可以用多种方式声明，直接在代码中访问关于它们声明的信息是非常有用的。

在检查函数时特别重要的是`inspect.getargspec()`，这个函数返回关于函数接受什么参数的信息。它接受单个参数，即要检查的函数对象，并返回以下值的元组:

*   `args`—为函数指定的所有参数名称的列表。如果函数不接受任何参数，这将是一个空列表。
*   `varargs`—用于多余位置参数的变量的名称，如前所述。如果函数不接受多余的位置参数，这将是`None`。
*   `varkwargs`—用于多余关键字参数的变量的名称，如前所述。如果函数不接受多余的关键字参数，这将是`None`。
*   `defaults`—为函数参数指定的所有默认值的元组。如果没有参数指定默认值，那么这个值将是`None`而不是一个空元组。

总之，这些值代表了知道如何以任何可能的方式调用函数所必需的一切。当接收一个函数并用适合它的参数调用它时，这是很有用的。

> > > def 测试(a，b，c =真，d =假，*e，**f):

...及格

...

>>>进口检验

> > > inspect.getargspec(测试)

ArgSpec(args=['a '，' b '，' c '，' d']，varargs='e '，keywords='f '，defaults=(True，False))

#### 处理默认值

正如前面的例子所说明的，默认值是在一个独立于参数名的列表中返回的，因此如何区分哪些参数指定了哪些默认值似乎并不明显。然而，有一种相对简单的方法来处理这种情况，这是基于前面关于多余参数的讨论中的一个小细节:必需参数必须总是在可选参数之前声明。

这很关键，因为这意味着参数及其默认值是按照它们在函数中声明的顺序指定的。所以在前面的例子中，有两个默认值的事实意味着最后两个参数是可选的，默认值按顺序排列。下面的代码可以用来创建一个字典，将可选参数名映射到为它们声明的默认值。

> > > def get_defaults(func):

-我...。args、varargs、varkwargs、defaults = inspection . getagspec(func)

...index = len(args) - len(defaults) #第一个可选参数的索引

...return dict(zip(args[index:]，默认值))

...

> > > get_defaults(测试)

{'c ':真，' d ':假}

### 文档字符串

如前所述，类和函数都有一个特殊的`__doc__`属性，它包含被指定为代码的 docstring 的实际字符串。不幸的是，它的格式与原始源文件完全一样，包括额外的换行符和不必要的缩进。

为了以更可读的方式格式化文档字符串，Python 的`inspect`模块提供了另一个有用的函数`getdoc()`。它删除了不必要的换行符，以及任何额外的缩进，这是编写 docstring 的副作用。

缩进的去除值得稍微解释一下。实际上，`getdoc()`查找字符串中最左边的非空白字符，计算该字符和它所在的行首之间的所有空白，并从 docstring 中的所有其他行中删除该数量的空白。这样，得到的字符串是左对齐的，但保留了为了格式化文档而存在的任何附加缩进。

>>定义 func(arg):

..."""

...对参数执行函数并返回结果。

...

...银

...要处理的参数

..."""

...及格

...

>>>打印(func。__doc__)

对参数执行函数并返回结果。

银

要处理的参数

> > > print(inspect.getdoc(func))

对参数执行函数并返回结果。

银

要处理的参数

在需要向用户显示文档字符串的情况下，比如自动化文档或帮助系统，`getdoc()`为原始文档字符串提供了一个有用的替代品。

## 应用技术

有无数种 Python 特性的组合可以用来完成大量的任务，因此这里展示的几种决不能被认为是通过组合 Python 的许多特性可以完成的工作的详尽列表。然而，就 Django 而言，这些都是有用的策略，并为本书中列出的其他技术提供了坚实的基础。

### 跟踪子类

考虑一个应用，它必须在任何给定的时间访问一个特定类的所有子类的列表。元类是一种很好的方式，但是它们有一个问题。记住，每个带有`metaclass`选项的类都会被处理，包括这个新的基类，它不需要注册(只需要注册它的子类)。这需要一些额外的处理，但是很简单:

> > > class SubclassTracker(类型):

-我...。def _ _ init _(cls、名称、基础、属性):

...尝试:

...如果 TrackedClass 不在基中:

...返回

...除了名称错误:

...返回

-我...。TrackedClass(跟踪类)。_registry.append(cls)

...

> > > class tracked class(meta class = subclass tracker)

..._registry = []

...

>>类类跟踪类:

...及格

...

> > trackedclass。_ registry-登录

[ <class>]</class>

>>类 2:

...及格

...

> > trackedclass。_ registry-登录

【<class>、<class>】</class>T3】</class>

元类执行两个功能。首先，`try`块确保父类`TrackedClass`已经被定义。如果还没有，就会引发一个`NameError`，表明元类当前正在处理`TrackedClass`本身。这里，可以为`TrackedClass`做更多的处理，但是这个例子简单地忽略了它，允许它绕过注册。

此外，`if`子句确保另一个类没有将`SubclassTracker`明确指定为它的`metaclass`选项。应用只想注册`TrackedClass`的子类，而不是其他可能不符合应用要求的类。

任何想要使用类似 Django 的声明性语法的应用作者都可以使用这种技术来提供一个公共基类，从这个基类可以创建特定的类。Django 的模型和表单都使用了这个过程，因此它的声明性语法在整个框架中是相当一致的。

如果 Python 通过了这些测试而没有提前退出，那么该类将被添加到注册表中，在注册表中可以随时检索到`TrackedClass`的所有子类。任何`TrackedClass`的子类都会出现在这个注册表中，不管子类是在哪里定义的。执行类定义就足以注册它；这样，应用可以导入任何可能包含必要类的模块，元类完成剩下的工作。

虽然它的注册表提供了比简单列表更多的特性，但是 Django 使用了这种技术的扩展来注册模型，因为它们必须各自扩展一个公共基类。

### 一个简单的插件架构

在可重用的应用中，通常希望有一组定义良好的核心特性，并能够通过使用插件来扩展这些特性。虽然这可能看起来是一个可能需要大量插件架构库的高要求，但它可以非常简单地完全在您自己的代码中完成。毕竟，一个成功的、松散耦合的插件架构可以归结为提供三样东西:

*   一种清晰、易读的方式来声明一个插件，并使它对需要使用它的代码可用
*   访问所有已声明插件的简单方法
*   一种在插件和使用它们的代码之间定义一个中间点的方法，在这里插件应该被注册和访问

有了这个简单的需求列表和对 Python 必须提供的内容的正确理解，几行简单的代码就可以满足这些需求。

类别插件数量(类型):

def _ _ init _(cls、名称、基础、属性):

如果没有 hasattr(cls，' plugins '):

#此分支仅在处理挂载点本身时执行。

#因此，由于这是一个新的插件类型，而不是一个实现，这

# class 不应注册为插件。相反，它设置了一个

#列出以后可以注册插件的地方。

cls 插件= []

否则:

#这必须是一个插件实现，应该注册。

#只需将它添加到列表中即可

#以后再追踪它。

cls.plugins.append(cls)

这就是让整个事情工作的全部，跟踪注册的插件并将它们存储在一个列表中的`plugins`属性上。剩下的工作就是找出如何实现前面列出的每一点。对于下面的例子，我们将创建一个应用来验证用户密码的强度。

第一步是中间访问点，我称之为挂载点，等式的每一端都可以从这里访问另一端。如前所述，这依赖于元类，所以这是一个很好的起点。

类 password validator(meta class = plugin mount):

"""

扩展这个类的插件将被用来验证密码。

有效的插件必须提供以下方法。

验证(自我、密码)

接收要测试的密码，然后静默完成或引发

如果密码无效，则返回 ValueError。可能会显示异常

所以要确保它充分地描述了问题所在。

"""

如果您愿意，您可以添加更多的内容，但是这里的内容是使流程正常工作所必需的唯一部分。当你想给它添加更多的东西时，只需要知道单个插件会继承它的子类，从而继承你在这个类上定义的任何东西。这是一种提供附加属性或辅助方法的便捷方式，对所有插件都有用。无论如何，单独的插件可以覆盖它们，所以没有什么是一成不变的。

还要注意，插件挂载点应该包含与插件预期行为相关的文档。虽然这不是明确要求的，但这是一个很好的实践，因为这样做会让其他人更容易实现插件。只有当所有注册的插件都符合指定的协议时，系统才能工作；确保它被指定。

接下来，设置您的代码来访问任何已注册的插件，以对应用有意义的任何方式使用它们。因为挂载点已经维护了它自己的已知插件列表，所以它所要做的就是遍历插件，并使用任何适合手头任务的属性或方法。

def is_valid_password(密码):

"""

如果密码正确，则返回 True，如果有问题，则返回 False。

"""

对于 PasswordValidator.plugins 中的插件:

尝试:

插件()。验证(密码)

除了值错误:

返回 False

返回 True

def get_password_errors(密码):

"""

返回一个消息列表，指出发现的任何问题

有了密码。如果没问题，这将返回一个空列表。

"""

错误= []

对于 PasswordValidator.plugins 中的插件:

尝试:

插件()。验证(密码)

除了值错误为 e:

errors.append(str(e))

返回错误

这些例子比大多数要复杂一些，因为它们需要错误处理，但是这仍然是一个非常简单的过程。简单地遍历列表将提供每个插件供使用。剩下的就是构建一些插件来提供这种验证行为。

class minimum length(password validator):

定义验证(自我，密码):

"如果密码太短，将引发 ValueError . "

如果 len(密码)< 6:

提高值错误('密码必须至少有 6 个字符。)

class special characters(password validator):

定义验证(自我，密码):

"如果密码不包含任何特殊字符，将引发 ValueError . "

if password.isalnum():

raise ValueError('密码必须至少包含一个特殊字符。)

是的，真的很简单！下面是这些插件在实践中的样子。

> > > for password in ('pass '，' password '，' p@ssword！)):

...打印(('正在检查%r ... '% password)，end= ' ')

...如果是 _ 有效 _ 密码(password):

...打印('有效！')

...否则:

...print() #强制换行

...对于 get_password_errors(密码)中的错误:

...打印(' %s' %错误)

...

检查“通过”...

密码必须至少包含 6 个字符。

密码必须包含至少一个特殊字符。

正在检查“密码”...

密码必须包含至少一个特殊字符。

正在检查“p@ssword！”...有效！

## 现在怎么办？

对 Python 必须提供的东西有了坚实的理解之后，您就可以深入了解 Django 如何使用这些工具来实现它的许多特性，以及如何在自己的代码中应用相同的技术。模型构成了大多数 Django 应用的基础，利用了许多这些高级 Python 特性。

Footnotes [1](#Fn1_source)

1 [`http://prodjango.com/new-style-classes/`](http://prodjango.com/new-style-classes/)

  [2](#Fn2_source)

2 [`http://prodjango.com/metaprogramming/`](http://prodjango.com/metaprogramming/)

  [3](#Fn3_source)

3 [`http://prodjango.com/dict-methods/`](http://prodjango.com/dict-methods/)

  [4](#Fn4_source)

4 [`http://prodjango.com/file-methods/`](http://prodjango.com/file-methods/)

  [5](#Fn5_source)

5 [`http://prodjango.com/inspect-module/`](http://prodjango.com/inspect-module/)