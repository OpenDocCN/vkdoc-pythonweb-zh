# 3.微服务剖析

现在，我们对微服务的鸟瞰图有了一个模糊的概念，是时候放大并仔细观察各种服务以及它们如何在内部相互交互了。为了更容易理解我们的架构，我们将把重点放在 3 个主要类别上，因此在讨论整个系统时，推理会更容易一些

首先，我们将查看特定服务在您的体系结构中的位置。我们将检查 3 种类型:

*   前端服务

*   混合服务

*   后端服务

先从用户看不到的说起。你会明白为什么。

## 后端服务

每个系统都有用户不直接与之交互的组件，只是通过许多抽象层。例如，您可以想象一个状态机，它计算用户在当前系统中是如何表示的。他们是以前的客户，还是目前的客户？也许他们以前从未在你的网站上使用过付费功能，但出于营销目的，存储他们的数据是很重要的。

后端服务为您的应用程序提供主干。其中大多数封装了公司核心业务逻辑的功能。他们经常提供数据或者与数据转换有关。他们更可能是其他服务的数据提供者，而不是消费者。

设计纯粹的后端应用程序有时感觉像是一个微不足道的挑战，我们将从我们的 pizza 应用程序中查看几个例子，以确保我们理解这意味着什么。在图 [3-1](#Fig1) 中，您可以看到连接到数据存储的 pizza 微服务，该数据存储包含我们在前一章中定义的 pizza Django 应用程序下的模型。

![../images/481995_1_En_3_Chapter/481995_1_En_3_Fig1_HTML.png](../images/481995_1_En_3_Chapter/481995_1_En_3_Fig1_HTML.png)

图 3-1

想象中的 tizza 应用程序后端系统

嗯，至少是其中的一些，我们将在几章中看到。您可以在图中看到的另一个服务是 auth 服务，我们将使用它来处理所有用户相关信息和身份验证。一些团队也使用类似 auth 的服务进行授权，根据您的喜好，您也可以将该层移动到您架构的一个单独部分。但是请记住，存在于相似或相同业务领域中的数据通常应该保持接近。

这里值得一提的是，这些服务的设计是由它们托管的数据和它们工作的领域共同驱动的。在构建微服务时，创建仅托管单一特定数据类型的服务是一个非常常见的错误。当不同类型的数据位于相似的业务领域时，它们应该在物理上和逻辑上彼此靠近。然而，这总是一个艰难的决定。这里有几个案例，你可以在午休时和同事一起哀叹:

*   比萨饼和比萨饼店应该托管在同一数据存储中的同一服务上吗？如果我们开始储存比萨饼的配料呢？在那种情况下，你的观点会改变吗？

*   我们应该在哪里存储权限？它应该绑定到比萨饼上还是绑定到我们系统的用户上？

*   我们应该把喜欢的东西存放在哪里？

以上所有问题都有多个好答案。我的建议是这样考虑:如果数据不是耦合的或者是松散耦合的，那么您可以安全地将其分解。如果耦合紧密，试着测量耦合有多紧密。例如，您可以随时测量从数据存储中一起查询不同资源的次数，这可能有助于您做出决定。

将所有数据保存在同一个地方可以为您的公司工作一段时间。事实上，在开始时，将数据保存在同一个地方会大大加快操作速度。然而，过一段时间后，我们在第 [1](1.html) 章提到的问题和故事会一次又一次地出现。如果您的数据库中只有一个不是非常关键的表，但却填满了您的存储空间，导致您的核心业务中断，那就太遗憾了。另一方面，将所有内容分开将会使您无法创建连接和在存储级别进行快速操作，您将需要从不同的源获取数据并手动连接它们，有时会编写低效的查询。

这个演讲可能会给你一个在不同的存储器中进行数据复制的想法。让我们绕过这个话题快速说一下。

### 关于数据复制的一个注记

既然我们已经谈了很多关于数据服务如何工作的内容，我想稍微绕一下，谈谈当您迁移到微服务时，您将使用的不同数据存储之间的数据复制。

使用微服务时，数据复制会变得非常自然。毕竟，您的服务中确实需要电子邮件地址，对吗？为什么不在创建用户时存储它，这样您就可以确信这些数据在任何时候都是可用的。

这样的想法可能很有欺骗性。当你使用微服务(实际上，软件中的任何东西)时，你总是想减少的一件事就是维护工作。当您在服务中引入一个新的数据库、表甚至只是一个字段时，您正在为自己创建所有权和维护工作。在上面提到的电子邮件示例中，您需要确保电子邮件始终保持最新，这意味着您必须确保如果您的用户在 auth 服务中更改了它，您也需要在自己的服务中更改它！当客户想要使用他们被遗忘的权利时，您也需要确保删除或匿名化您数据存储中的电子邮件地址。从长远来看，这会导致很多不一致和令人头痛的问题。

在许多系统中保持数据一致是一个非常困难的问题。几十年来，数据库工程师一直在与上限定理作斗争，创造了像暗示移交或草率仲裁这样的算法，最终实现了各种数据库副本之间的一致性。在您的应用程序中实现这样复杂的一致性算法值得吗？

如您所知，我不太喜欢数据复制。当然，有些情况是你无法避免的，但是，我通常会推荐以下替代方案:

*   虚拟对象:如果您可以存储一个标识符，使用该标识符可以从另一个系统查询该对象，那么为什么您需要存储整个用户对象呢？

*   客户端和服务器端缓存:想想你正在处理的数据。跟上时代有多重要？数据的所有者服务总是可以很容易地实现一个缓存层，但是同样的事情也可能发生在客户端！

在开始从其他服务复制数据之前，请考虑替代方案。从长远来看，这可能会让你付出昂贵的代价。

既然我们已经很好地理解了数据将存储在哪里以及如何存储，那么让我们来看看将消费它们的服务类型。

## 前端服务

前端服务的存在是为了将呈现在用户机器上的前端应用程序容器化。乍一看，它们的存在可能没有多大意义，但是，有几个原因可以解释为什么设计(几乎)完全前端的服务对您和您的团队来说可能有意义:

*   关注点分离——您可能还记得(或者仍然使用)MVC 模型，以及它们将应用程序的各个部分分离开来的好处。在某种程度上，您可以将前端服务视为 MVC 的“视图”层。开发人员可以专门处理这些服务，只利用其他人的接口并与他们不拥有的数据进行交互。

*   独立的工具——如果有不同的团队在前端服务上工作，那么将会有不同的工具围绕着它，并且有更多的专业人员在这个领域工作。并不是所有熟悉 gradle 的人都熟悉 Webpack。然而，这并不一定意味着他们不能互相学习！

前端服务可以直接使用来自后端服务和系统的数据，后端服务和系统可以将后端服务提供的数据集成为由特定业务逻辑定义的更易于理解的格式。让我们来看看混合服务。

## 混合服务

按照 SoA 的理念，有时我们需要系统只为我们的业务做一件事，而且它做得很好。没有前端或后端专业知识的工程师需要负责这些服务。也完全有可能这些业务组件没有严格地绑定到工程部门。这本书的主要焦点将围绕后端和混合服务。

如果所有权或者缺乏维护系统的人，我们完全可以考虑系统，我喜欢称之为“混合服务”。在野外，它们有时被称为后端到前端服务，或 BFF。

混合服务将大量前端和后端组件连接在一起，以实现简单的业务目标。在开始编写代码之前，让我们先看一个例子:

让我们想象一个世界，在遥远的未来，我们成为 tizza 中最重要的团队之一的技术领导，这就是 tizza-admin 团队。我们的使命是确保所有的披萨创建者可以轻松管理他们的披萨，并可以在应用程序中推广营销活动。他们需要一个单页应用程序来使体验更加流畅。阅读规范后，可能会出现以下问题:

1.  这里有很多数据，我们应该从哪里获取呢？

2.  我们应该从前端分别调用所有的服务端点吗？

3.  移动呢？他们能处理所有的数据吗？

所有这些都是每个全栈(和非全栈)在构建具有多个数据源的单页面应用程序时应该问自己的有效问题。我们不想做的第一件事是连接到现有的数据库(我们将在本章的后面有更多的推理)，所以我们将限制自己调用 API。在这里，我们可以选择从单独的数据源或从单个数据源调用数据的端点(在这种情况下，例如，我们需要比萨饼的列表、许可、活动选项和支付细节等)。借助事件循环和线程的力量，我们可以轻松地运行第一个选项，同时并行获取所有信息，但是，我们正在消耗大量网络带宽。

为什么这是一个重要的问题？2017 年，美国 63%的网络流量是通过移动设备完成的，其中很多是通过移动网络完成的。移动网络是变化无常的小生命。它们很脆弱，往返时间很长，人们把它们带到很少阳光照射的地方，这使得网络带宽优化成为我们作为工程师需要考虑的首要问题之一。

更改当前已有的端点来支持部分响应负载可能有点麻烦，因此出现了一个服务的想法，该服务将为我们聚合数据并以紧凑的响应进行响应。弊端？我们已经向 BFF 引入了额外的呼叫。

随着独立服务而来的是另一个美好的东西，那就是所有权。BFF 通常是系统中拥有最多业务逻辑的部分，这使得它成为产品团队所有权的完美候选。

现在，我们已经熟悉了如何对微服务进行分类的基本概念，我们将深入了解服务的高级架构应该是什么样子。

## 设计原则

我们将看看像 SOLID principles 这样的方法——最初用于整体服务来管理代码复杂性——以及它们如何提供一种考虑服务的有用方式。我们还将看看在服务设计过程中出现的一些常见的设计模式。

请记住，我们在这一部分要看的例子应该有所保留和思考。这些模式并不能解决设计服务时的所有困难。在实现过程中保持开放的心态，在将这些原则集成到您的系统中时专注于您的业务问题。

### 实心积木

你们中的一些人可能听说过传奇软件工程师制定的坚实原则，如 Sandi Metz 和 Robert C. Martin，如果没有，这可能是一个令人大开眼界的小片段。

坚实的原则本质上是关于如何设计您的代码和代码架构的指南，以便在未来的功能开发和维护上花费最少的时间。我们将通过一些例子简要介绍 5 项原则。如果你想了解更多，我强烈推荐罗伯特·c·马丁的《清洁建筑》作为阅读材料。这些原则与微服务设计没有严格的联系，但是在思考我和我的团队正在构建的系统时，我从中找到了大量的灵感。同样，理解并应用它们(如果需要的话)会客观地让你成为一个更好的程序员。

***1。*** ***单一责任原则***——声明你系统中的一个成员(类、方法，甚至是整个微服务！)应该只有一个改变的理由。这是什么意思？考虑一个负责从数据存储中获取数据并将其显示在 web UI 上的函数。现在，这个组件可能有两个改变的理由。首先，如果它读取的数据或数据存储发生变化，比如向数据库表中添加新列。第二，如果显示数据的格式发生变化，比如允许使用“json”格式以及“xml”数据作为响应。理想情况下，您希望将这些层分开。因为它们变得更容易推理。

**2。** ***开闭原则***——声明你系统的部分应该对扩展开放，但对修改关闭。现在，这并不意味着你应该编写将来不可能修改和修复的代码，而是意味着如果你想给你的软件增加新的功能，你不需要修改已经存在的代码。

```py
def pizzas(request):
    if request.method != 'GET':
        # we are post (I guess)
        return update_pizzas(request)
    else:
        return get_pizzas(request)

Listing 3-1Not conforming to open-close

```

向上面的代码中添加一个新的方法类型需要进行大量的修改

```py
def pizzas(request):
    if request.method != 'GET' and request.method != 'PUT':
        # still post! (I guess)
        return update_pizzas(request)
    elif request.method == 'PUT':
        return create_pizzas(request)
    else:
        return get_pizzas(request)

Listing 3-2Still not conforming to open-close

```

相反，考虑下面的(仍然不是最好的，但是足够了):

```py
PIZZA_METHOD_ROUTER = {
    'GET': get_pizzas,
    'PUT': create_pizzas,
    'POST': update_pizzas,
}

def pizzas(request):
    return PIZZA_METHOD_ROUTER.get(request.method)()

Listing 3-3Conforming to the open-close

```

***3。*** ***利斯科夫替换原则***——声明如果你的程序中有包含子类型的类型，那么该类型的实例应该可以被子类型替换，而不会中断你的程序。这是 5 的更面向对象的原则之一，本质上是说如果需要的话，你的代码的抽象应该被具体的成员替换，这样从长远来看确保了系统的正确性。我发现，如果工程师使用 IDE 来告诉他们是否违反了超类的规则，那么 Liskov 替换原则是很容易遵循的。使遵循这个原则变得容易得多的另一件事是尽量减少元编程的使用。这一点我们将在本书后面讨论。

***4。*** ***接口分离原则***——声明许多特定于客户端的接口比一些具有许多功能的大型抽象接口要好。换句话说，你不希望你的客户依赖于他们不需要的东西。这是现代软件工程中一个非常非常重要的原则，但却经常被忽视。基本上是面向服务架构原则背后的思想。

假设你是一名后端开发人员。您的工作是编写原始的、多用途的 API，供数百个内部和外部客户每分钟使用。这些年来，您的界面已经成长为巨大的怪物，其中一些没有限制它们返回的关于客户的数据量。从名字到他们去过的餐馆数量，每次访问的朋友列表都会在响应中返回。现在，这可能对你来说很容易，数据库就在你的下面，在你的 MySQL 集群上有了聪明的查询，你就能够保持 API 的高速运行。然而，移动团队突然开始抱怨。他们说，你不可能指望客户每次打开应用程序时下载数百千字节的数据！的确，大规模的 API 被分割成较小的 API 肯定会更好。这样，查询的数据更加具体，这种后端服务的重构和扩展将会更快。构建 API 的时候，一定要从客户端开始！

***5。*** ***依赖倒置原则***——声明系统应该依赖抽象，而不是具体化。可能是 5 个中最著名的一个。基本上是说你应该在你的代码中使用明确定义的接口，你的组件应该依赖于这些接口。通过这种方式，您可以在实现层获得灵活性。

微服务——应该——都是关于依赖性反转原则的。在理想情况下，系统使用契约(如 API 定义)进行通信，以确保每个服务都在相同的页面上提供和使用哪种数据。可悲的是，现实世界并不总是充满阳光和幸福，但我们将看看如何实现这一目标的方法。

关于微服务设计，人们经常忘记的一件事是，它不允许你编写糟糕的代码，并在底层遵循糟糕的设计模式。确保你为你在低层和高层抽象上设计的系统感到自豪，并且这个服务不仅仅是可替换的，而且是可维护的。

### 12 个因素

更流行的服务设计方法之一是遵循 12 因素应用程序的规则。最初由 Adam Wiggins 编写，后来由 Heroku 负责维护，12 因素应用程序是一个微服务设计方法集，它为我们提供了构建可扩展和可维护的服务时应该遵循的 12 点。现在，这些方法涵盖的范围比这个厨师所能深入涵盖的要广得多，所以我建议在 12factor.net 多读一些。

***1。版本控制系统中应该有一个被跟踪的代码库，被多次部署***

我认为现在没有太多的代码库没有被各种修订系统跟踪，例如 Git 或 Subversion。如果你是一个还没有采用这些技术的人，我强烈建议你检查一下，并把它们集成到你的工作流程中。一个应用程序应该由一个代码库和一个或多个部署组成。在面向对象的术语中，你可以把你的代码库想象成一个类，而部署则是你的类的一个实例，带有各种参数，使它能够在生产、开发或测试环境中运行。

您的代码库在不同的部署中可以有不同的版本。例如，当您构建应用程序时，您的本地开发部署可以在不同版本的代码库上运行。

***2。依赖关系应该被隔离并明确声明***

正如我们将从本书的后面部分了解到的，依赖性管理是构建微服务的最大和最困难的问题之一。12 条规则中的第二条可以给我们一些经验法则，我们可以遵循这些法则来开始。

在 python 世界中，我们通常使用 pip 结合需求或设置文件作为依赖管理器。这条规则规定所有的依赖项都应该有固定的版本。这是什么意思？想象一下下面的情况:您在您的应用程序中使用带有一个非固定版本的包 A。一切都进行得很顺利，直到在包中发现了一个关键的安全性，而您却从未得到通知。此外，该项目的唯一维护者已经在 8 个月前失踪，导致您的所有用户数据被盗。现在，这听起来像是一个极端的情况，但是如果你曾经和依赖管理器如 **npm** 和版本指示器如 **^** 和 **~** 一起工作过，你就会知道我在说什么。为了安全起见，使用==作为依赖项。

***3。*** ***店铺配置*** ***环境***

为了遵守规则#1，我们需要将依赖于部署的配置与部署本身分开存储。依赖于部署的配置可以是多种多样的，它们通常是您的应用程序运行所必需的。我们指的是以下变量:

*   数据库和其他外部系统的 URIs

*   证书

*   日志记录和监控设置

***4。将外部服务视为资源***

外部服务可以从数据库和缓存到邮件服务，甚至是为应用程序提供某种服务的完全内部的应用程序。这些系统需要被视为资源，这意味着您的应用程序应该支持按需改变它们的来源。应用程序应该在第三方环境之间没有区别。

想象一下下面的情况:有一个大规模的营销活动即将到来，而你的第三方电子邮件提供商无法承担这一负担。升级您的计划可能需要一些时间，但是在第三方构建一个新的(更高吞吐量的计划)应用程序似乎是一个可行且快速的解决方案。一个 12 因素的应用程序应该能够没有太多问题地处理切换，因为它不关心它所处的环境，只关心它使用的配置。在本例中，更改应用程序的身份验证凭证挽救了局面。

***5。非开发部署创建应支持构建-发布-运行周期**T3*

一个包含 12 个因素的应用程序将部署创建分为 3 个独立的阶段

*   构建——当您的代码和依赖项被组装成可执行文件时。

*   release——当您的可执行文件与环境配置组合在一起，并创建一个可以在给定环境中执行的版本。

*   run——汇编的可执行文件和配置现在在给定的环境中运行。

为什么我们分享这个过程如此重要？这是一个非常好的问题，我能给出的最简单的答案就是对应用程序进行推理。想象一下:你的支付系统在生产中有一个严重的缺陷。团队立即开始查看您的版本管理系统上的应用程序代码，检查还原发生时最近的提交。没有任何迹象表明这个问题应该在第一时间发生，但是团队仍然决定不重新发布损坏的版本，直到找到 bug。仅仅几天后，团队得知一名工程师修改了支付系统的生产代码。这是 12 因子应用程序希望通过此规则避免的示例之一。

现在，如果不对生产系统进行适当的安全限制，上述问题很难解决，但是，有一些工具可以阻止工程师首先这样做。例如，你可以使用一个合适的发布管理系统，其中应用程序的回滚很简单，比如 Kubernetes 的“helm”。此外，你的所有版本都应该附有版本和时间戳，最好存储在一个 changelog 中(我们将在后面的章节中更深入地研究这类系统)。

***6。12 因子 app 分别是*** ***无状态流程***

12 因素应用程序假定没有东西会长期存储在主应用程序旁边的磁盘或内存中。同样，这样做的原因是能够推理出应用程序以及它将来可能会出现的错误。当然，这并不意味着您不能使用内存，建议将它视为单个请求缓存。如果您在内存中存储了许多东西，并且您的流程由于某种原因(例如新的部署)而重新启动，您将丢失所有这些数据，这可能对您的业务没有好处。

在具有持久会话的应用程序中，用户数据可以跨请求多次重用，这些应用程序仍然应该存储在某种数据存储中，在这种情况下，这可以是一个缓存。在本书的后面，我们将探索一些 python 包和框架，如 **asyncio** 和 **aiohttp-jobs** ，在这里很容易进入将请求存储在内存中并在进程重启时完全丢失请求的危险区域。

***7。使用*** ***端口绑定*** 导出您的服务

更具体一点的 web 开发(但是，嘿，这本书的大部分内容都是关于 web 开发的)，这个规则规定应用程序应该是完全自包含的，不应该依赖于 web 服务器的运行时注入，而是通过绑定到一个端口并通过该端口服务请求来导出它的接口。

在我们的情况下，姜戈会处理所有的事情。

***8。使用流程**向外扩展*

每个应用程序的基础应该是进程，它应该被解释为类似 Unix 的服务守护进程。应该设计各种类型的进程来处理各种类型的有效负载。计算量大、运行时间长的任务可能需要工作进程或其他异步进程，而 HTTP 请求可能需要 web 进程来处理。

这并不意味着你的进程运行时不鼓励线程，在 Python 的情况下，你的应用程序完全可以利用“线程”库，或“asyncio”。另一方面，您的应用程序需要能够扩展为在相同或多个物理和/或虚拟机上运行的多个进程。

确保不要在操作系统层面上使事情过于复杂，只需使用标准的工具来管理您的流程，如“systemd”或“supervisor”。

第 6 点实现了这一点。

***9。流程应该易于启动和处理***

不要依赖你的 12 因素应用程序的流程，因为它们应该很容易摆脱，也很容易创建。一接到通知。不过，这有几个要求。

*   启动应该很快——进程应该只需要几秒钟就能启动。这是简化缩放和快速发布过程所需要的。实现这一点可能相当棘手。您应该确保在加载应用程序时没有昂贵的操作——比如远程调用不同的 web 服务器。如果你正在使用许多模块，你可能想研究一下 **importlib** 的 **lazy_import** 方法。

*   关闭应该是优雅的——当你的进程从操作系统接收到一个 **SIGINT** (或者甚至是 **SIGTERM** )时，它应该确保一切按顺序关闭，这意味着正在运行的进程/请求在你的应用中结束，网络连接和文件处理程序关闭。在 django 的例子中，选择的 WSGI 服务器将会为您处理这些。

***10。保持********尽可能接近*****

 **确保生产环境中运行的代码尽可能地接近开发机器上运行的代码。为了避免误解，我们所说的接近是指运行的应用程序版本之间的差异。根据 12 因素应用程序，要实现这一目标，您需要努力缩小 3 个“差距”:

*   时间:开发人员将一个特性交付到产品中所花费的实际时间——无论对你和你的公司来说这是几天还是几周，目标是将它减少到几个小时甚至几分钟。

*   人员:运营工程师部署 12 因素应用程序的代码开发人员应该能够参与部署过程并监控应用程序，而不需要运营工程师。

*   工具:开发过程中使用的工具与生产中使用的工具(如数据库、远程系统等)。)-尽可能保持开发和生产工具的紧密联系。

你可能会认为这些大多说起来容易做起来难。十年前，如果运营人员不在几分钟内到位，几乎无法想象服务的部署。大多数持续开发和部署系统都是使用从运营人员那里收集的各种脚本手工构建的，这些人厌倦了每次有人更改代码库时运行“rsync”。如今，整个行业和技术分支都在发展，以使部署体验更快、更简单、更不容易出错。有些系统可以直接连接到您的 git 存储库，并为您的集群提供自动化部署，如 AWS CodePipeline、CircleCI 或 Jenkins。

### 注意

如果您不熟悉持续集成(CI)或持续部署(CD)管道，我建议您阅读一下。在 devops.com 上可以找到极好的资源。

关于工具，今天，在容器化的时代，您和您的开发人员可以使用多种工具来简化它。在我们浏览它们之前，让我们先来看看为什么这很重要:

想象一下下面的情况:您的一个开发人员正在处理一个非常复杂的查询，而您的系统的 ORM 无法处理这个查询，所以您决定使用一个原始查询作为解决方案。开发人员启动他们的本地系统，开始在本地 SQLite 数据库上构建查询。几天后，数百行查询就完成了，覆盖了自动和手动测试，一切都运行得很好。开发人员在他们的拉式请求上获得批准，并且在部署之后，您的监控系统提醒团队该特性不可操作。经过一些调试后，开发人员得出结论，他的本地 SQLite 数据库和生产环境中运行的 Postgres 之间存在语法差异，这是他所不知道的。

在过去，在您的本地开发部署上运行轻量级支持服务是有意义的，因为您的机器上的资源通常是有限且昂贵的。今天，有了我们使用的巨型开发机器，这不再是一个问题。另一个问题可能是后端服务类型的可用性。在您的本地机器上维护 Postgres 集群可能看起来很乏味，如果您没有工具备份的话，这是很乏味的，因为现在虚拟化，尤其是容器化的力量已经提供了工具备份。

如今，在本地机器上设置 Postgres 数据库就像编写一个 Docker compose 文件一样简单，如下所示:

```py
version: '3'
services:
  postgres:
    image: postgres:11.6.1
    ports:
      - "5432:5432"

Listing 3-4Sample yaml to spin up a database with Docker Compose

```

再也没有借口了！确保在您的所有部署中使用类似的生态系统，以减少上面详述的错误类型。

***11。*** ***日志*** ***应该由别的东西管理***

这一点很简单。一个 12 因素的应用程序不应该关心管理和写入各种日志行，而应该把所有的日志作为一个事件流写入“stdout”。这使得开发非常容易，因为在本地机器上，开发人员可以看到他们的应用程序中发生了什么事件，从而加快了调试过程。

在登台和生产环境中，流由执行环境收集，然后发送以供查看和/或存档。这些目的地不应由 12 因素应用程序配置。

如今，有几十种优秀的日志解决方案供您使用。如果你不确定从哪里开始，我建议查看 Logstash、Graylog 或 Flume。

***12。运行您的*** ***行政流程*** ***作为一次性流程***

出于维护目的，开发人员经常需要在 12 因素应用程序上运行手动流程/脚本。一些例子包括:

*   **manage.py migrate** 用于 Django 应用程序上的数据库迁移

*   修补数据库中用户数据的一次性脚本

*   **manage.py shell** 让 Python shell 检查应用程序状态和数据库

这些进程应该在与应用程序的长时间运行的进程相同的环境中运行。它们需要相同的代码库和相同的配置。管理代码必须与应用程序代码一起发布到各种环境中。

### 结论

现在我们已经了解了 12 因素应用的规则，我们可能对高性能微服务有一个模糊的概念。理想情况下，你已经听说过这些要点中的大部分，并认为它们是值得添加到你的设计服务库中的东西。在本书的某些部分，我们将会观察到，由于发展或业务的限制，这些规则是如何被打破的。无论我们在哪里打破 12 因素的规则，我都会让你知道，你可以评估自己是否值得。

我们采纳了一些高层次的设计理念，从鸟瞰的角度来看，我们的服务应该是什么样的。现在，我们将放大图片，了解它们应该如何相互交流。**